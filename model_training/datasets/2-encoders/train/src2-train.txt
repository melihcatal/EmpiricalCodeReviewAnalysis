Rikkola If TYPE_1 class managed exclusively class possibility override behavior I suggest put private visibility method Anyway choice
minor Do prefer _CODE_ VAR_4 long VAR_2 long VAR_3 Im asking constructor also TYPE_1 VAR_4 first argument
This distracting trycatch caused use Threadsleep Just make test methods throws Exception
These lines shouldnt
_CODE_ fine
This property used _CODE_ class used nested formats It would better _CODE_ _CODE_ instead
This condition seems backwards I think index arraylength
Please include null check VAR_1 like VAR_1 null return false
How using _CODE_ something like
Maybe shouldnt keep block nothing
Do need methods public
Nitpicky stuff This method performs key lookup twice could operation one TYPE_1 node jsongetkey return node null _CODE_ null
What think using telescoping constructor since one prefix Inject public _CODE_ VAR_2 thisVAR_2 _CODE_
need anylonger
maybe use _CODE_ instead see
What thread safety I might mistaken looking code snippet looks like one thread could check condition receive false contains method execute code block That might reason blocking _CODE_ method used
Debug leftover
We make _CODE_ implement TYPE_1 method create lamda return instead
Please put creation TYPE_2 else branch omit variable return new instance right away
Just noticed problem _CODE_ This VAR_1 _CODE_ index _CODE_ That variable renamed _CODE_ index I say latter Again doesnt need happen _CODE_ What different _CODE_ index _CODE_s gaps elements get deleted Examples _CODE_s 0 1 2 4 7 Indexes dont gaps would naturally change elements get deleted ussually wont Examples index 0 1 2 3 4 5
This method throw exception end say original operation top layer errors transaction rolledback We dont swallow exception
The
This place decision fully rebuild module made move logging reporting responsible code
This unused
I would rather remove METHOD_1 shouldnt costly _CODE_ queries could add since hot path
Looks better 1
Cosmetic Please follow projects coding convention keep braces new lines Thanks
maintain value part timeline VAR_5 Memory pressure already high brokers maintaining serverview timeline Is way could get information requested opposed storing time
Can assign VAR_5 VAR_6 constructor null instead always variable non null
Including VAR_3 check seems like odd way write code Why simply java VAR_3 return VAR_2 VAR_3 true
TYPE_1YPE_1he attVAR_2ibute type needs exact heVAR_2e suggestion public TYPE_1YPE_1 void _CODE_YPE_1 attVAR_2ibuteTYPE_1YPE_1ype TYPE_1YPE_3 supeVAR_2 TYPE_1YPE_1 VAR_2
VAR_18 null none given server This standard convention _CODE_ since day one
I think check happen applying wrapper ie current status code 200 dont apply wrapper 200 dont let modified Otherwise multiple calls METHOD_1 first one may work second fail
probably _CODE_
Is really necessary wait INT_1 milliseconds Why Threadsleep1 Why Threadyield
Formatting else I wont repeat occurrences please check diffs make sure changes respect coding conventions
suggestion VAR_1
Should use _CODE_ instead empty string comparison
It would better check METHOD_1 checking VAR_1 error message specific
Why 08 setting INT_2
Again Javadocs added describe Row
Should always overwrite _CODE_ I mean could put new value case VAR_5 null return true otherwise return false Not sure bigger performance impact We also store password maybe empty String would sufficient value
Why change Should minimally depend table transactional What happens call nontransactional table
This could even VAR_4 VAR_3
uuid creatable
Same issue variable names
I think log longer use
Please dont assignement comparison within expression You also avoid break testing nullness kind condition assignement body
You could save lines moving return null default case instead break
Die folgenden Methoden bitte im scope auf private stellen diese werden und sollen ja nur dieser Test Methode verwendet werden
Suggestion want avoid align method parameterscall arguments multiline dilemma format like java protected VAR_1 long VAR_2 TYPE_1 unimprovedTYPE_1DifferenceThreshold TYPE_2 VAR_4 body This compatible align multiline thats part _CODE_ Java Conventions Geoffreys _CODE_ settings keep ignoring _CODE_ Java Conventions regard wink I dont like aligning either I chose follow _CODE_ conventions I rule checked I always format like keeps rule applying
Same TYPE_4 closeable using trywithresources statement closing object maybe good idea
This cast necessary others
What configuration used Can remove redundant
Since Tombstone longer hierarchy result removing proxy method probably either return null throw exception
vmaletta test found
The first superfluous instanceof always false null therefore null value bypasses instanceof checks returns null end method already
The synchronized block needs include read map Thread 1 reads VAR_3 gets null Thread 2 reads VAR_3 gets null Thread 1 enters critical section creates new TYPE_3 containing listener 1 stores VAR_3 Thread 2 enters critical section creates new TYPE_3 containing listener 2 stores VAR_3 Listener 1 lost
Probably didnt mean leave
expect new violations Can explain appeared deleted package name class
This part java spec Im familiar Is VAR_2 1 0 value 0 VAR_2 value 0
Why access method staticly
maybVAR_1 loggVAR_1rdVAR_1bughandling VAR_1xcVAR_1ption _CODE_ VAR_1 would print thVAR_1 stacktracVAR_1 aftVAR_1r Handling VAR_1xcVAR_1ption BazingaExcVAR_1ption
Should new VAR_1 instead
This technically backward incompatible Not sure whats parseqs policy contrib project
Why couldnt written using simple loop I dont see odd exit conditions
I think overiding METHOD_1 _CODE_ probably better approach I think kind thing I implemented
I think check omitted
Now VAR_2 need change something like suggestion _CODE_ VAR_2 null Otherwise user selects Expression type leaves expression blank _Expression component_ wont loaded
縮排多一格
Same comment
This new parameter unused
rename instance var well
Name
Can remove throws TYPE_1 wont affect callers They already expecting TYPE_1 dont throw anymore thats fine
TYPE_2 int
Why final variable level
You dont need worry whether player logged scripts start method invoked player game
may want consider making VAR_2 first line match params order
The result variable neededthe block within finally still invoked even return
Please change log remove
This could METHOD_4
Format consistency public int VAR_1 return thisVAR_1
Maybe would good consistent _CODE_ return deleted entity response well
This check superfluous superconnect check We safely remove block
Sure could taken put another draft _CODE_
These 2 constructors using different order parameters eg would good keep consistent As correlation expression new parameter I would add 2nd
Should add another version constructor preserves previous signature sends empty set That would help preserve backwards compatibility class part public _CODE_
You dont need fill body method need use lambda
Should moved ifresult null block sorting nonexisting result make sense even throw exception TYPE_2
HVAR_10rVAR_10 thVAR_10 important innVAR_10r VAR_10xcVAR_10ption gVAR_10ts lost plVAR_10asVAR_10 pass VAR_10 JadbExcVAR_10ption constructor
Should third parameter VAR_2 variable created
This isnt going return null would better wrap METHOD_2
_CODE_ Some minor points remove throws TYPE_5 since method already catches exceptions return also redundant final class VAR_5 combined assignment
Could good idea accept calling class instead name log class name METHOD_3 logs Just ensure names pass locking arent arbitrary useful tracing flow scheduler
Unnecessary
Should return VAR_4
You annotate parameter Nullable dont need handle null argument dont need METHOD_2
I dont think rendering byte bunch ints useful maybe omit include length perhaps
Does get called Is worth caching even transient
Why defined changed next line
want add _CODE_
I think d_quantiles1 d_quantiles2 d_quantiles1
brace newline
might obsolete _CODE_ implemented
It seems like might cleaner move METHOD_4 logic _CODE_ method performs METHOD_3 _CODE_ well child batches
Can create new Resource config management
nit TYPE_3 closed closing credentials providers dependent resource add last VAR_1
_CODE_ _CODE_ info
Another nonpermissible change
null check
one Override
use _CODE_ In way need remove last build method
synchronized access _CODE_ METHOD_1 cool transaction performance impact want initialize without invoking full thing without resource
Looks like logic already done delegating METHOD_2 Isnt
Adding TYPE_3 arguments METHOD_1 seems make sense But replace previous _CODE_ override also modify call sites Passing VAR_1 indirectly via class property thread safe mixes class state call specific parameters
drop used TYPE_2 parameter signature change private method
_CODE_
Let describe potential data race Lets verify together whether real issue The race happens logics jump line 44 line 48 time series thread2 called _CODE_ get _CODE_ 1 thread1 metadataget_CODE_ get _CODE_1 thread2 execute finish commit update _CODE_2 exit fully _CODE_ threadxx called _CODE_ since VAR_5 empty _CODE_2 gets _CODE_ 2 thread1 called VAR_5puthandle VAR_4 Then enters unsafe state since _CODE_ actually 1 _CODE_ get 2
Since one argument _CODE_ efficient
This cast useless Mathlog10 returns double already
Usage collection ineffective plan modify flight Use _CODE_ instead code
isnt check already done METHOD_2
Auch dieser Block kannst du als Lambda ersetzen Du kannst dir dazu auch mal das TYPE_2 Interface anschauen und dieser Stelle lambdas mit einem Interface mit genau einer Methode zu tun hat
Do need set VAR_2 position initial offset
Throwing TYPE_3 may lead unexpected behaviour So way throw checked exception deal explicitly case
Please remove unused param
Why public
Use _CODE_ align parser
You could also put METHOD_3 method call VAR_1 instanceof checks perform better youd avoid calling synchronous method Nexus events Also maybe add brackets make clear whether status check applies events registry one
VAR_3 looks like unused variable ie remove
also provide method get single method helper class
I believe necessary This happen autoamtically pipeline Verify thats case remove
I dont really like use static VAR_4 I think would cleaner METHOD_4 METHOD_1 return boolean values indicating whether tuning error create new exception type _CODE_ thrown indicate tuningspecific errors
nan
Is expected create VAR_3 every time Maybe cache
Two spaces context
Just return _CODE_ idsplit
All _CODE_ environment variable PRESTO_ lets make PRESTO_HISTORY_FILE
The member variables class scoped unnecessarily Not sure style preference pointing Looks like true couple classes _CODE_ well
Id thisorigin _CODE_ VAR_1 Note I like using static imports We others use much static imports clear enough goes things like _CODE_ tests
Space missing several places variable value assingments Please format class correctly
nitpick replace suggestion return VAR_3 optionsVAR_3 VAR_5 optionsVAR_5 VAR_7 optionsVAR_7
デバッグ用コード
This full explanation improved I think meant clicking notification makes disappear Why done _CODE_ need consistency
move null check back first action method change behaviour
A _CODE_ used well
I dont think call METHOD_4 work item likely wont failed execute
moved called Resolved
final VAR_3
In case rather print errors since supposed valid test sheet assert errors empty enough If isnt empty I believe prints error map
I think could set TYPE_2 Application
Since dont override _CODE_ METHOD_3 MAX_VALUE subcsription noop removed If intention METHOD_3 downstream actually METHOD_3s I think prestart upstream meet
please catch specificexplicit exceptions In case original exception passed embedded totally lost
How control drawing debug lines It conditioned global variable sets editor debug pass command line argument
VAR_1 used VAR_4 options arent fileoriented use streams etc isnt good place put imo replace reset called places reset currently called like _CODE_ With one addition needs called first file
So pointed line problem The problem _CODE_ never called This never done method anyway
This looks like leftover hasnt usage Can remove
shouldnt VAR_3 null
Cant call _CODE_ _CODE_ TYPE_2 VAR_1 remove
nit _CODE_ instead _CODE_
I dont get change test case The behavior handling fields changed changes Moreover class TYPE_3 imported unknown method call changes meaning test
TYPE_3 removed
VAR_1 used
make packageprivate
What If I want set velocity zero
suggestion TYPE_2 VAR_1 new TYPE_2POST hotels Please make change affected test methods
empersistmember enough need wrap _CODE_ needing access methods exposed _CODE_ _CODE_
Is VAR_1 field used I see set dont see used anywhere
No block required either
_CODE_ keep _CODE_ happy
switch instead else
As far I understand get rid explicit type parameters calls
times1 default METHOD_8
Not good idea sets thread local could interfere tests Also I suspect _CODE_ wont run _CODE_ _CODE_ never submitted executor Another reason let _CODE_ fail gracefully used outwith _CODE_ _CODE_
Parameters annotated Nullable
In locations code interprets null forever lets maintain convention fix code _CODE_ java default VAR_1 _CODE_ VAR_4 throws VAR_5 return duration null VAR_2 VAR_2VAR_4toMillis
nit _CODE_ _CODE_ VAR_2 _CODE_
You dont need METHOD_2 youve Mocked
remove VAR_2 TYPE_2 need take screenshot
Override annotation line
This doesnt parameterized Just create TYPE_10 explain always set true
simply delete _CODE_ formatter invoke needed That avoid creating String log level METHOD_3 dMETHOD_3abled although _CODE_ thMETHOD_3 case shouldnt matter much pointing _CODE_ looks suspicious
suggestion VAR_1 _CODE_ Extract days VAR_1 add outdays int VAR_3 int VAR_1 _CODE_ VAR_1 VAR_3 _CODE_ outdays VAR_3
Is TYPE_2 needed
I believe selector mobile desktop Please use invisiblehighimpactwrapperinterstitial providercontainer iframe
The argument order quite strange Do data offset length instead
I think separate _CODE_ _CODE_ issue needs unit test
Can return copy
Im versed _CODE_ required I thought _CODE_ already perworld making redundant
This backwards want expected condition
call variable _CODE_
This looks like fixing bug datasketches right
Shouldnt synchronized
nit move VAR_2 first constructor parameter
findByLoginId은 구조적으로 null을 return 하지 않음 방어코드를 줄이기 위해 _CODE_ Pattern이 쓰였는데 나중에 도입된거라 조금 아쉽게 만들어져 있긴 함
Bit nit since end using expression branches pull
I thought non ssl return bytebuffer
qeesung nit merge 2 lines
This conditional probably necessary even performance point view The meaning might clearer put call conditional
TYPE_2 removed
yes getter interface _CODE_
casting would faster
Cruft It doesnt matter unused variable
Id use equals make clear dont care identity semantics readers wont verify value set fine either way java TRUEequalsrequestgetAttributesgetPRESERVE_AUTHORIZATION_KEY
Is particular reason _CODE_ used instead instanceof instanceof less restrictive may better choice
Remove extra line
Why use constructor right away ie without reflection
danielezonca Since always cast possible directly set _BaseDMNTypeImpl_ type instead _DMNType_
In get method calls _CODE_ use _CODE_ instead _CODE_ key VAR_3 map Can make consistent sure theres discrepancy prefixedunprefixed
Why simply VAR_2 0 simpler VAR_2 And simple test ver see becoming
This duplicates initialization VAR_2 constructor thats called previous line
Each getters _CODE_ like return type private member variables expose In case Id recommend VAR_1 dateformat _CODE_ TYPE_1s member variable types getter types Our Jackson _CODE_ deserialization automatically take care setting missing field empty TYPE_1 resulting Java object
Should init group cache first Because devices reference
use ternary operator
Должен быть public
return directly
Just semantically correct return type TYPE_1 extends TYPE_2 Its way builder yet backwards compatible change changed point
This static instead transient
Do really need METHOD_1 every change Currently dont anything case would undesirable forint i0 i10000 _CODE_
We may want add public support custom reporter implementations based _CODE_
This might premature optimization I worry data structure used One option would view list revolving buffer essentially maintain index oldest valid item You replace increment add start search wrapping back around
Use equality comparison token types
Unless want tristate TYPE_1 boolean I dont see need tristate go boolean
Might valid spot use package private level access instead public Since test package enginetests Cant entirely recall works way
When I expungetrue jboss7 VAR_1 I saw logging METHOD_4 20140128 221847089 _CODE_ brooklynmanagementinternalLocalEntityManager2524e205 call stop management METHOD_4 unknown VAR_1 already METHOD_9d JBoss7ServerImplidmPXYvab1 skipping descendants This _CODE_ also METHOD_9 So want ifelse mgmtgetEntityManagerMETHOD_9VAR_1 else block
If dont use _CODE_ doesnt looks like need See Mockitos _CODE_ _CODE_
could return _CODE_ remove trailing whitespace
wonder would interesting false see correctly jumping catch
art Personally I would lean toward using guard statement java VAR_1 null return null
evacchi Id vote creating output set outputs Here _CODE_ always created matte outputs This produce empty bpmn2dataOutput tag cases catching event dont outputs doesnt cases process saved user dont yet completed event definition Same happens start events uses VAR_1 events like _CODE_ doesnt outputs And I believe reasoning makes sense _CODE_ events like _CODE_ _CODE_ doesnt inputs
VAR_1 around try
I think method could private
braces
_CODE_ sufficient
simplify return
nit merge line METHOD_1 returns VAR_2
prop I would use taskId01toString since testing taskId01toString method Our assumption METHOD_10 folder name METHOD_10 equal result taskId01toString 0_1
static import METHOD_1
This makes VAR_3 required break exiting users Why required You dont check METHOD_1 pass METHOD_2 doesnt null check
You dont need condition It else
_CODE_ subclass TYPE_6
METHOD_5 removed contents included METHOD_1 device metadata
need synchronized
bulb Considering _CODE_ omits check I think safe us well
Just merge else make else
Invert statement please
Brackets please part code convention always use
Minor nit The names num VAR_1 seem used opposite purpose VAR_1inator divisor
add comment need METHOD_2
really minor symmetry _CODE_ maybe use VAR_3 _CODE_
Remove TYPE_1 signature
I dont think needed
Same _CODE_
You dont need
Please add also blocks one statement
No need use fully qualified name since import class already
Add instanceof check
There variant simplify code _CODE_ sql _CODE_ _CODE_ Nullable VAR_7 args
Last one
Any particular reason remove final one param leave another I guess leave
I dont see Nullable
As anyway touching lines lets reformat add space around
Can call _CODE_ rather require separate method retrieve _CODE_
return _CODE_ consistency
instead equals instances would make nullsafe
Just information could use assertEquals4
nit check appears twice
Would nice create integer constant assign INT_1 use Eg public static int WINDOW_HEIGHT INT_1 Itd explicit another person magic numbers
This bit convoluted imo adding METHOD_3 METHOD_3s list initialized empty And remove _CODE_ call
Maybe little test case helper
Move METHOD_3 finallyblock
If TYPE_4 take argument
Technically bind exactly free variables _CODE_ part The _CODE_ use VAR_7 nothing else
у _CODE_ есть метод принимающий id строки
Shouldnt line swapped one _CODE_ block
Please replace occurrences _CODE_ Indeed code style using recommend add prefix function call function current object
null values omit
The properties individual fields _CODE_ class
Is needed If consider dropping
erdemedeiros lets remove system outs
newline
Please METHOD_7 stdoutstderr Please log instead output silenced build infrastructure
Hasnt second parameter true _CODE_ forgotten go
There parameters though I really want go make final since configured checkstyle I also dont see big benefit I dont think Ive ever accidentally modified exception reference catch clause
rm public
You setting endpoints client
Unless variable created make code easier read could simplified _batchIdsputnew _CODE_ _CODE_ _CODE_
Nice wondering would work overloaded methods appears ie _CODE_1 defined previous _CODE_ exists
Why class many methods protected Does subclasses Otherwise use package protected modifier private
TYPE_3 may classpath We another method conditional serializer property set jackson Only case autowire object mapper optional depencency OptionalTYPE_3 Alternatively could dynamic lookup using _CODE_ ensure happens _CODE_ created case safe assume presence Jackson
remove final modifier
suggestion _CODE_ multicast capability removed Jenkins More information
use statements even singleline ones
dont needs propagated finding VAR_4 best effort
new TYPE_5
pynicolas Are sure method name As I understand opposite
prop I would add VAR_1 already contained set
something throws exception probably propagate vs wrap
Sorry I wasnt clear Need keep oshi prevent conflicting possible properties files class path But define string final instead changing
You switched order cores read replicas
move _CODE_
Im sure still fix issue A java Clock object offset added See If duration negative could cause return negative extended period time I dont think use offset method anywhere would good guard I think keeping code one line fine Maybe instead simply update return VAR_5 0 return VAR_5 0 value value VAR_5 actually since simply return value within first minute maybe java return VAR_5 60 ConstantsSECOND_MS value value VAR_5
chaviw skip check null If VAR_2 null instanceof check also fail
You use utility method introduced 10626
VAR_2 null empty cause problem
VAR_1 unused
dont think setter type function return
I would use _CODE_ VAR_1
perhaps arrange lines alphabetical order _CODE_ VAR_2 _CODE_ VAR_2 _CODE_ VAR_2 _CODE_ VAR_2 _CODE_ VAR_2 _CODE_ VAR_2 _CODE_ VAR_3 _CODE_ VAR_2 _CODE_ VAR_2
seems like constructors set protected properties base class Theyre called via super
I think return new TYPE_1 Otherwise hit _CODE_
Dont make public visible testing Remove public modifier leave default scope
This right violates _CODE_ discussed _CODE_ yesterday
Elasticsearch _CODE_ impl types per packages They accessed
Do need call _CODE_ This particular line code going implicitly convert primitive int back TYPE_2
Think would easier read without negations return CHECK_CLIENT_TRUSTED_MATCHERmatchesmethodTree CHECK_SERVER_TRUSTED_MATCHERmatchesmethodTree _CODE_
return _CODE_ _CODE_ _CODE_
Better name _CODE_ string
Please use braces
If shouldnt possible store Application without slug abstract implementation control rely implementation calling method
Method body return _CODE_ without ending slash later path used combination modulexml string
This looks like maybe accidentally included unrelated change
You need call _CODE_ method
TYPE_2
shouldnt constants removed source code
Do need super class inheriting super class
Please dont cleanups commit bugfixesfeaturesimprovements
static must return type java private static VAR_1 buildUnixVAR_1
format
Shouldnt order parameters way Since first argument expected might mislead see assertion error
need
I think 1 parameter version constructor use instead passing null
We need VAR_2 contain partition key We need debug error cause see two different values Can bring debugger set breakpoint
You dont need set TYPE_1 done setup method harm makes test clearer
Can removed initialized next line
apc999 This needs public reflection work
delete line call _CODE_ required assertion
METHOD_3 invoked twice METHOD_1
When method get instance byte argument Why TYPE_3 generic argument I think TYPE_3 always _CODE_ invoke copy _CODE_ Java 9 _CODE_ method cant use regrettably I wonder buffering delegate decision stage
I dont know internals likely case Form Preview returned never reached But i18n appreciable case
Shouldnt test fail scenario I pass according code erickgonzalez
Please add overloaded constructor keep comparibility like _CODE_
yesamer I think would easier read methods caller called name former simply delegating latter situation I would call _getFocusedContext_
static import METHOD_2 array METHOD_3 see everything fit one line
What column name refer The plan _CODE_ shouldnt references column names using column handles instead
Nit else redundant since branch returns conditionally We generally prefer write expressions java return return
Is VAR_2 always non empty Is asked chat assume
Thats actually VAR_2 Sorry I though already mind proposed reference field directly
The _CODE_ function lets add parameters You dont need use Stringformat
use final
Can explain Entity Outbound requires _CODE_ _CODE_ service
I thVAR_1k VAR_1 null return null slightly better way deal
METHOD_10 pretty weak Cant METHOD_8 pass right _CODE_
You could possibly check values I guess equals method broken really screwed
benzonico may METHOD_4 better highlight VAR_1 includes
Fixed done
This reason builds fail It trying load VAR_2 without workbench Could request VAR_2 fly method calls instead avoid issues context tests It annoying mock _CODE_ stuff I got work single test class executing test suites complains _CODE_ library already loaded another classloader wants execute _CODE_ _CODE_ And I idea solve I tried get _CODE_ suppress mock _CODE_ call _CODE_ VAR_1 without success
Same Add clarifying parenthesis
Missing case x3 labels cases
always use curly brackets even one line
I dont understand rationale case dont save original value annotation deployment config
TYPE_3 TYPE_1
Use switch instead ifs
Static import
reason synchronized whole method
nit Nullable
I think may overlap concurrent updates authorities threads
VAR_1 nonnull
_CODE_ Make METHOD_1 static method rule
Can add _CODE_ mark id deprecated
duplicate
Need _CODE_ true well run failures Edit Also VAR_1 null
Need remove leftover debug output
reason use _CODE_ annotation thats thought settled bgrozev
With Folder abstraction _CODE_ opaque strings _CODE_ numbers implementation detail _CODE_ So replace interface something flexible lets keep interface clean Also sometimes eg emptying Trash folder unconstrained _CODE_ makes sense So Id keep original method add new one better describes My suggestion java public void _CODE_ uids throws TYPE_3
Всегда надо иметь возможность закрывать ресурс снаружи См интерфейс Closeable
Shouldnt need specify _CODE_ anymore
none parameters final class please remove
Im wondering even need method VAR_3 additional check VAR_3removedOrganizationalUnitEvent similar check filteractive _CODE_ Can happen 2 different _CODE_ equal dont identifier I think remove newly added private VAR_3 remove check behave
nit merge lines METHOD_1 return given argument
Shouldnt rather throw _CODE_ case Or rather create interface without support extend interface methods
doesnt need ability effect optional ability fine
Rather adding callback could override either _CODE_ methods update _CODE_ class add class SUBCLASSES_WITH_NO_CALLBACK map This would cleaner probably result less overall code
I think stay nonfinal since possible provide efficient implementations subclasses
close finally block
Did want leave
private
bad result VAR_1 null someone _CODE_ probably better like return VAR_1 null VAR_1 VAR_1 new TYPE_3
Please either use curly braces put return true line VAR_2
METHOD_4 used Lambda Method Reference like Thats reason ObjectsMETHOD_4 introduced Java 18 Simple better Therefore null
VAR_2 longer used
I think line _CODE_ block
I think new version slightly confusing A less confusing middleground would int offset VAR_4 return VAR_2 arrayoffset
The public cant removed This class public class would breaking change
Unnecessary null check path trivial ignoring
_CODE_ Severity _CODE_ Remove unused private METHOD_1 method rule
It might little cleaner use builder pattern
call _CODE_
Actually changes master previous version doc needs retained
Should final char VAR_1
caithagoras I understand _CODE_ true change change
You could call protected constructor one
Not sure change necessary
Please add spaces geti _CODE_ And arround VAR_1 also good practice
used removed import removed
set true value field declaration
replaced _CODE_
Maybe would better override method public like _CODE_ example It really smells bit publish kind options _CODE_
Looks like dont need TYPE_2 TYPE_3
We _CODE_ keep
Looks like code wouldnt triggered return
reverse order
missing final
expected value first parameter _assertEquals_
Think easier read reverse ifelse avoid
Is cast necessary
azizmb9494 It looks like Amazon implementation slightly different Google implementation Sometimes happen Gradle copy script doesnt execute properly youre building Google variant Could try rebuilding project using Google build variants oba agencyx agencyy regenerate Amazon code push new version
Move private method public analyze methods
Is failed still useful enough
This simplified new _CODE_ _CODE_
Why extra VAR_2
I wonder switching parameters would readable
I suspect isnt dealing _CODE_ usual way The _CODE_ able highlight single failure group group usually meant operations current transaction Its probably easy apply _CODE_ usual way normally would handle failure something like operations A B C failed B somehow suggesting C wasnt executed In case various operations might applied order collect successfail operations forge new kind error state
Shouldnt name Nonnull well As far I see topic name used various Map lookups internally fail _CODE_ name null And I noticed _CODE_ annotates name Nonnull absence Nonnull method probably oversight
suggestion public int VAR_2
_CODE_ many java return _CODE_ _CODE_ true _CODE_ _CODE_ HttpHeaderValuesKEEP_ALIVE true
Is reason couldnt make executor TYPE_4
oh I see I dont think need feature start current step number
In context GUVNOR2821 I would expect _CODE_ please update METHOD_2 method achieve Let know dont see point
default constructor longer needed
So model change listener called twice single modification I like monperrus Could explain good
Nested ternaries Please consider using normal ifs
You call value value
Double variant class uses VAR_3 null null better
Javadoc mention non existing type
change java _CODE_ length
There need local variable Just return directly detected os family
Should METHOD_2 Consistency good thing
I dont think want pass TYPE_5 ZipTYPE_5InputStream call end
I dont think VAR_1 lines useful longterm If VAR_1 message said Starting METHOD_1 test would helpful looking console output jenkins etc
Dont need _CODE_
Return Stringjoin directly without creating new String
message parameter could final
This throws clause redundant
Same
You logging already logged METHOD_6
needed
Public constructor without _CODE_
_CODE_ obj Fall back delegate VAR_3 VAR_3release obj
Something weird happening whitespace
I would delete version check master The logic simple unlikely cause clashes hard resolve even VAR_2 unlikely event someone addVAR_2g another field VAR_2 lifetime 7x
It VAR_8
nan
No reason return null make void
I dont see could problem readonly commands
String VAR_4 Priority VAR_1
Could _CODE_
как на счет записи в одну строку _CODE_
Remove unneeded logging
Original query cacheable This one I think third param false
minor move fail line 144 remove return line 147
set final
change longer necessary
Does fix problem I dont see _CODE_ parameter changed related could please explain
Why pass thisentry twice Better use one parameter theyre going value
This right Branches Since local clone determines calls remote repo I suspect jgit always using origin So test needs _CODE_
_CODE_ move VAR_1 first place ie call viewinit add next line calls _CODE_ _CODE_ false
Just single line enough _CODE_ return _CODE_ else VAR_1
need call _CODE_
I see another bug probably unlikely maybe even possible superstop called VAR_4 null
This line code useless
throws VAR_2 писать необяазетельно Пробел перед
Only VAR_4 update remain METHOD_1 method The remainder part moved inside _CODE_
Prefer _CODE_
Hmm would like achieve keeping void interface
This also never happen
Same
I dont think call super method needed
rm 36
Nit return _CODE_ message title
There need hide methods tests makes reusing code difficult using discovery features _CODE_ like _CODE_ method names
I think want null instead empty arrays
Why lose _CODE_
This parameter unused
add _CODE_ constructor
_CODE_ around retire methods believe already sets reason
nit TYPE_2 unused
There many unneeded changes mostly code style _CODE_ Removing needed adds unnecessary noise _CODE_ Maybe move another _CODE_
Remove null cases There default case
Why two lines
Beware invoking VAR_3I18NgetLocale different invoking VAR_3
Dont change sample Its meant indicator simple case We dont want users copypasting VAR_14 apps
Can really null TYPE_3 looks like METHOD_3 list validation nulls
Can return _CODE_ instead lookup twice
Id remove whole guard simply return null VAR_1 _CODE_ set null session left realm already course must null transport detached
I dont think ever called VAR_1 false I suggest removing parameter I would also suggest reversing parameter METHOD_2 _CODE_ even _CODE_
If VAR_1 already started I think return true Same stop return true VAR_1 already stopped dont try stop
logged instead printed
add new line 134
leftover
new line needed
always use thisdelegate directly avoid extra local variable would make things shorter less confusing
I think METHOD_3 called first Then METHOD_2 users call get get updated derived value
Dont need separate function oneliner _CODE_
METHOD_1 doesnt modify mod time theres value return probably returning None encoded json null long get 200 reply command succeeded
Move trycatch VAR_6
path pathsubstring0 _CODE_
Better use nonmin version available Wicket use min one production mode Ie put js files js folder use jssuperfishjs It facilitate debugging
_CODE_ Isnt exactly remove Removing equals
Please remove unnecessary null check name Its already checked constructor
Isnt VAR_3 VAR_2
Nit Typo
If last parameter true need overwrite _CODE_
remove line
Is reason use METHOD_1 mapper level METHOD_4 enginebackend level
If variable name normalized set method necessary normalize get well
nit remove final usually params
Checkstyle Parameter VAR_1 final
Sorry I mean theres constructor used VAR_2 function _CODE_ VAR_2getSqlKeyword thisalias VAR_2getSqlKeywordreplaceAll _ _ _CODE_ Right
nit Implementation protected avoid introducing extra shadow _CODE_
быть может это более уместно в самом _CODE_ чтоб он не возвращал никогда нуллов
java _CODE_
You _CODE_ callable
Удали пожалуйста все такие комментарии
This bytecode equivalent using foreach syntax array
minor qualifiers required
return VAR_1 instanceVAR_1f TYPE_2
Do need extract array You exploit _CODE_ comparison
_CODE_ VAR_1
Should three lines actually happen branch I dont see would need get VAR_1 VAR_2 compact
You want avoid returning optional collection Just return empty collection
Can add version _CODE_ takes _CODE_ since providing timestamp dimension specs seems like common
Why need static
use _CODE_ discussed
I dont think objects representing date one created string would include microseconds This compared string representations
private static
I think method need static
Debugging Remove
Just want ask whether public purpose _ElementDefinition_ class protected
Not critical maybe better invert VAR_1 null
This check necessary compute MD5 hashes directories
Since build instead get return null instead
empty line
Please add constraint parameter description well ideally could method delegate method takes String instead TYPE_1 object suggest whole VAR_3 object needs populated sent server
VAR_9 always different null
Please reformat
Delete
Same I dont think throwing _CODE_ instead empty implementations
Nitpicking I suppose new condition slightly costly next one I would put new condition last
In current situation want implement behavior remove two trycatch _CODE_ VAR_8 catched _CODE_ fail fast needed However case _CODE_ change anything last step visit really want report issue file fails _CODE_ checks
Revert
This line redundant
Please revert according policy Please refrain modifying classes orgspringframeworkasm orgspringframeworkcglib orgspringframeworkobjenesis Those include repackaged forks thirdparty libraries _CODE_ _CODE_ Objenesis Any refactoring classes take place upstream originating repository The Spring Framework pick changes syncing official updates forked thirdparty libraries
Minor parentheses needed
validation I tired keep mind
Why need care entry VAR_6 The test full control whats VAR_6 Right
Close called cleanupafterexceptionalcondition situations job If complain anything last thing
This behavior If someone calls _CODE_ builder calling build would modify map Could set VAR_4 null prevent future use Or could call _CODE_
I think constant rather parameter Im pretty sure values used class example _CODE_ would work anymore used 2 decimal scale
You also check first _CODE_ null case
looks like bad merge assigning VAR_2 already included
minor using ternary could clear
I would also use two argument constructor keep default visibility provide factory method creates VAR_1 production executor service
This expects localization key
Extract Priority constant dont change 2 places
Need add new constructor preserve _CODE_ compatibility
This code simplified _CODE_ VAR_2 There one thing map removing key isnt map noop Its also faster _CODE_ provide O1 amortized performance versus iterating every single entry
_CODE_ handle interruptions essentially noop VAR_2 already executing
Is possible METHOD_4 one ones method created To avoid problems adding new methods I see code paths also METHOD_4 eg _CODE_ _CODE_ _CODE_
Hmmm impact every messaging gateway I wonder could mapper return builder perhaps default method Or provide overloaded method takes extra VAR_2 Or create new converter thats used Redis
Using Systemout strictly forbidden This line deleted
change protected static This order really unconventional
Shouldnt two TYPE_2 messages one using _CODE_ another using _CODE_ using condition ones _CODE_
shouldnt method static seems like ordinary utility function reasons manage singleton instance class spring
make convenience method _CODE_
use private fields getterssetters Move doc setter
suggestion _CODE_ _CODE_
dont need VAR_3 already
Please remove METHOD_3
inlined
TYPE_2 nonstatic inner class already reference necessary pass
I suppose _CODE_
true VAR_2 could also null would cause null point exception suggestion VAR_2 null VAR_2isEmpty
Listsort usage
Statement rewritten inline
Exiting early help flatten multiple nested statements simplify complex conditional statement In case arent nested statements early exit slightly complicated What think java Override public void _CODE_ VAR_1 _CODE_ _CODE_ toggleCompletedViewVAR_1
Based understanding calling _CODE_ VAR_10 _CODE_ guaranty return VAR_1 calling _CODE_ another type message would throw _CODE_ By consequence seems null check useless Am I missing something
dont need METHOD_4 VAR_2 individually configurationVAR_2METHOD_4METHOD_4r otherwise abstract store VAR_2 serialized
Please add curly bracers Also please check places I saw also places You could use _CODE_ formatting highlights
Why change necessary I dont see reason use VAR_4 later
These breaking particular reason need input name The target name rejects go As multiple files targeted single patch spit multiple rej files
What Is used anywhere
Dont need keep second value null one array seems required previously class constructor
_CODE_
comment
btw please format nicely _CODE_ style eg spaces like VAR_4 VAR_5 delegategetVAR_4s
Should moved _CODE_ aaudiber
I think would better expressed switch statement
Unnecessary cast Could also avoid unchecked warning declaring VAR_6 VAR_3 generic parameters String String
This check still redundant Youve already checked value null valueequalsnull false anyway
method lowercase idem VAR_4 C
Could please use field instead f consistent line
Looks like class wrong instanceof comparison Here _CODE_ generated equals want use Override public boolean _CODE_ return true null _CODE_ o_CODE_ return false superequalso return false TYPE_4 TYPE_4 return _CODE_ _CODE_ suggestion obj instanceof TYPE_4 return false
In old new situation line seems duplicated
dont need local variable using value like VAR_2
Same I think something like java return new _CODE_ enough
May make static invoke like _CODE_ instead _CODE_ _CODE_
suggestion _CODE_
nit You overload constructor avoid modifying signature many places
I Prometheus user I want understand public It appears used _CODE_ package
This replace first byte metric name 0 Also total iterations VAR_3 1 Starting 1 may fix
Is recursive call METHOD_6 calls METHOD_1 calls METHOD_6 I checked deeper I understand first sight
il semble quau début de la session sétait dit que les usages de essayait de les limiter au assignations dans le constructeur
default Mockitoverify already uses times1 need inform
unnecessary cast long
Im wondering push implementation methods leaf types instead _CODE_ providing default implementation UTF8_CODE_ overrides would UTF8_CODE_ StringWrapping_CODE_ simply provide implementation
Seems little overcautious might reason doublewrapped _CODE_
Move static _CODE_ use everywhere
Why instead using headers given constructor
static
I dont think method called constructor
instanceof still needed
properties already please replace true
Maybe space
Do need TYPE_1
Can make accessors final
Since parameters referred lets keep style _CODE_
This cause merge conflict 4244 Please change file
Do switch instead ifs Also cant really compare strings like Java
Can use diamond operator _CODE_ _CODE_ VAR_2 VAR_4 new VAR_5
nit try avoid switching order arguments eg VAR_4 second arg method first arg one wrapping
see
Other audit event classes following annotation empty constructor java _CODE_ used jackson mapper
Why trycatch let fail Also cast necessary
Why move logic KindFILE_INPUT inside METHOD_2
Is needed
This change potentially significant The execution context change execution new context derived current one produced please keep L108L109
Why dont use _CODE_
Nit please alphabetise
include error message
Minor point Should version simply call clientget Should version takes version require version Would seem keep things bit simpler way
Why add line breaks
TYPE_5 already imported beginning looks like directly use METHOD_7
explain _CODE_ description line enough fix problem What purpose remaining changes
dont need function use constructor directly
Actually intention place _CODE_ front make null check unnecessary _CODE_equalsIgnoreCasename would enough If null value problematic setcontains check could return early method name null
particular reason make anything public private packageprivate case
Please remove TYPE_9 _CODE_ memberresource groupresource attribute modules api abstract If passed entities mismatch programmers fault We want exceptions mostly used outer api Api Entry sometimes _CODE_ Then please catch exceptions modules implementation wrap TYPE_5 This result lowering exceptions usages normal methods _CODE_ back normal managers
Unwanted final
I think overcomplicating things Try keep simple logical read introducing variable need minimizing number validation need In case simply nest 2 statements put definition VAR_9 variable within body first remove VAR_9 null test
could even go constructor Test classes get instantiated individual test
Ditto
Small detail Please update _CODE_ VAR_10 new VAR_11 fix type warning Adding java compiler use receiving type set VAR_8 impl use _CODE_ _CODE_ checks find fix warnings
Change unrelated _CODE_
Not fan would seem add noncongruent VAR_4 So inventory would appear holes A better way may using add instead indexed add
I confused supposed
If get reviewed youll _CODE_ wont need VAR_5 Or _CODE_ could even extracted _CODE_
atomically
private public
Is possible avoid copy pasting code reuse code topnresultbuilders
We normally check null set nonnull _CODE_ code handles null differently
move null check first action method ensure also throw VAR_3 null VAR_2 null
Please revert according policy Please refrain modifying classes orgspringframeworkasm orgspringframeworkcglib orgspringframeworkobjenesis Those include repackaged forks thirdparty libraries _CODE_ _CODE_ Objenesis Any refactoring classes take place upstream originating repository The Spring Framework pick changes syncing official updates forked thirdparty libraries
debug level remove
Found lambda conversion could less verbose use VAR_2 VAR_3 compiler seems able infer argument types Or purpose help reader
Like _CODE_ class Im missing initialization _CODE_ column
I know Sonar flag around block This tricky read logic coming back later date
In original code static final const value It probably big deal would nice keep possible
METHOD_2 TYPE_1 VAR_3 METHOD_2 TYPE_2 VAR_4 VAR_3getTYPE_2 String VAR_5 VAR_3getAuthenticationToken This 4 lines present every method dont tell didnt copypaste Maybe extract methods
please reconsider log message s_loggererrorStringformatUnable create directory template sn path _CODE_ _CODE_ especially sn part logging exception string newline semms want I would like stack trace message
An int type never null maybe want use Integer type null On places comparing value 0 maybe wrong written condition
I know directly part _CODE_ could changed new _CODE_ avoid one useless append TYPE_2 constructor create TYPE_2 capacity 16 immediately expand next append
TYPE_4 thrown method
public TYPE_1 addint x int
Looking I dont think anything actually throws exception get rid entire throws part This allow remove exception handling _CODE_ possibly get rid new exception class isnt used anywhere else
Its kinda weird pull configuration every property Looks like thats code needless Lets fix get configuration
_CODE_ suggesting method reference _CODE_ rather METHOD_3
marked final
This actually logic error It must possible empty itemstack shadow inventory override existing one shadowed one
java _CODE_ ready port 80 _CODE_
Dont use equals attachment instances
try outside try catch getting instance packagemanager
This operator changed bitwise _CODE_ logical _CODE_
_CODE_ weird way writing _CODE_ using strange Java feature lets call static methods like METHOD_3 methods specific objects So please replace latter
dont retry getting hcatclient blocking queue timeout used
please move line outside _CODE_
apparently queue would queue would VAR_5 method
This VAR_2 replace one since theyre string length checks
Please respect surrounding code style
That doesnt seem necessary either
Should done _CODE_ instead This method could called want ensure set environment config one time per task The _CODE_ methods seems like good place unless reason
If add line break use curly brackets well Everything else errorprone
There slight perf cost going look resource bundles resolve languages someone calls METHOD_1 Again Im sure use case done _CODE_ properly resolves label
Looks line extra BundlePListNode_KeyCol
bug url _CODE_
Please use preference store specifically dialog This reduces probability name collisions _CODE_ SHARE_DIALOG_PREFS ContextMODE_PRIVATE
_CODE_ please format like tests java public void METHOD_1 VAR_1
StringvalueOfDEFAULT_CONNECTIONS would straightforward
Should condition VAR_11
This constructor removed It make sense create constraints state type table time provide table name
Maybe could also pass root cause creating new exception
final für locals kann entfallen
_CODE_ prone check VAR_5 null Also need check VAR_5 contains one simply call get suggestion VAR_5 null return VAR_5getkey
shouldnt _CODE_ VAR_1 like changes super class break
You could consistent use final class
private
dont need VAR_2 field anymore
I would argue ok name empty contract loosened little
Enabling indexing even VAR_1 false Maybe autoenabling happen VAR_1true
please dont remove explicit initialization
Move line outside loop
might want add newline
jomarko A couple question 1 ticket description seems somehow _CODE_ _CODE_ managed different way I see _CODE_ managed elsewhere different way 2 kind interaction specific ot _CODE_ Is grid editor If behavior different component better METHOD_2 buildergetter somewhere else abstractparent class avoid duplicate snippet
Unnecessary _CODE_ parameterization
jodygarnett aaime still discourage use _CODE_ etc since _CODE_ introduced I think _CODE_ like tests flood console perhaps line removed
_CODE_
_CODE_ Thanks looking Taking look _CODE_ looks like may opportunity cleanup well What would think making two methods look something like java strategy null return strategy url null return null strategy get default strategy return strategy I believe would get rid dead branches well keep statement simple
call _CODE_ consistency
ivange94 sorry bad please turn guard clause Test empty execute code else clause Reads nicer less nested
I would prefer initialize inline field declaration rather constructor If I nitpicking much
These readable inlined assignment Im sure worked Guava Preconditions Java METHOD_1 returns reference work Example java thisbuffer ObjectsMETHOD_1buf buf argument null But stick whatever minimal change merges master easiest
要改用 attach file dao TYPE_3 要拔掉
I get _CODE_ public This leads _CODE_ set null making hard distinguish either VAR_3 null actual reference invalid exist
I created ticket fixed
This wrong _CODE_ migrated count 1
May safer assert exists assert doesnt delete
TYPE_1 reason vs boolean Just asking Use TYPE_1 mind always makes think trivalue boolean true false null
Why INT_1 128
ivandalbosco better remove call super nothing
erdemedeiros lets remove system outs
Dont need Stringformat
Move _CODE_
Can make private people use static method
This
_CODE_
Keep map fieldfield VAR_2 lookups O1
The response available TYPE_4 object part TYPE_1
VAR_4 1 enough You dont need mutate VAR_4
nan
info vs METHOD_1
This VAR_3 doesnt reflect reality We come even file doesnt exist So move METHOD_3 condition inside
shouldnt report exception something
Check crash code contains call _CODE_ method empty string myCookie_CODE_
This private
_CODE_
minor Can static
Checking METHOD_7 calling remove redundant removed
redundant synchronization
TYPE_3 throwable treated combine catch clauses
Can never get given logic flow
Could format code intellij
Alias never null
Did miss attach _CODE_ class
Indeed commit fixing sonar issue apparently part _CODE_ No idea
I think null default
Since async possibility VAR_1 happen require healthy resource
Should finally case
fixed D per line 56
Two suggestions printing standard pass boolean argument control stack trace printed consider using logger instead could configured write file controlled logging level
As know method METHOD_2 getting VAR_2 testing Is cover case unknown METHOD_2 If case I would prefer test using _CODE_ Moreover case covered test cases The remarks apply VAR_4
VAR_1 alias names defined user configurations I dont think wantneed format
Im still scared something stupid using result result METHOD_1 implementations youre happy youll one scratching head _if_ _CODE_ start rolling _CODE_ going crazy
The cast longer needed
Are null checks really needed
Switch order arguments _CODE_ actual assertEquals1 _CODE_ _CODE_ _CODE_ _CODE_emailcom _CODE_
1
check equality based _CODE_
Still Futilbcastmsg means Public chat get code report
If want use exitearly pattern invert condition Otherwise please use else statement
wasnt alphabetized would nice
nit Initialize initial capacity number workers
return _CODE_
Duplicate throws clause fixed master
_CODE_
In case zero
This type check removed There storage provider types build top AMAZON_S3 implementation would different type would still work well streaming For example using _CODE_ provider spaces used snapshots left S3 could support Also 4Scienceproposed AMAZON_ONE type would fit category
remove return statement redundant
Maybe VAR_5 VAR_6 _CODE_ _CODE_ little clearer
nit merge lines METHOD_1 return given argument
cleanout
rename VAR_4 item
Is intended master temporary code
Call super first
Now youve added _CODE_ Autowired probably remove null check since shouldnt ever null
offtopic doesnt seem related _CODE_ trying compete Radim longest _CODE_
remove else
Sorry case exception 325 345 lines eg assertion fails VAR_5 restored Looks like Before After better suits
change argument order back original
This wrong _CODE_
Should set null
minor semicolon end line
Nit else redundant remove thus original line remain unchanged
VAR_2 VAR_3
maybe remove TYPE_2 method signature
url used I guess could use inline ie _CODE_
tests function
Check calling get
please dont remove explicit initialization
VAR_5 used
Why use _CODE_ one Why deserialize one thing
throw
Im sure safe change fake nonfake sequences Im trouble working mind
_CODE_ I know copypasted old code methods type parameter fully description license url name For consistency I would name parameter least url well
I would check first value null
I think return object needs updated return new VAR_1
I think class possible
It seems like itll build versions match tag names like v02190 create stable version recent release latest pointing current develop branch Probably safest return latest know wont broken link next release though
Does need public Please introduce new public members without cause
required _CODE_ method empty anyway Writing TYPE_1 done immediately
comment
new VAR_6 explicit type longer necessary
This outer optional shouldnt needed
Have call METHOD_1 method
Should final
Is performance difference original code
VAR_1 specific variable name Add javadoc comment explaining new param Is list ignore bool true If someone adds new list without making changes work
hide remove doesnt inverted
Why public
Could add nullable VAR_5 VAR_3
You could x x This call _CODE_ returns null x null _CODE_ nonnull Perhaps make code cleaner since seems like common pattern Refer
This would easier reason raised exception Why return null
nit usually would write thisstate _CODE_
Can VAR_3 null
Nit No need final
Use METHOD_1 method rather new date
dont need check previous comment
suggestion _CODE_ result new TYPE_3
see Why introducing new variable VAR_1 You use value
Since lot VAR_2 null checks throughout entire class I would suggest making VAR_2 final throwing _CODE_ VAR_2 null I thinks best equivalent Kotlin behavior makes lot null checks class unnecessary
Tiny thing mention cause Ive seen alot _CODE_ Its sorta useless use _CODE_ We either pass specific error message throw new _CODE_
Any parcitular reason still need typeregistry youve removed class
new TYPE_3 subject body get random
You remove public modifier since class packageprivate
This private class TYPE_1 passed used
throws TYPE_1 removed _CODE_ testing remove well
I find original version easier read case
This need public lets keep private
Why change existing _CODE_ Arent adding another implementation _CODE_ Dont backward compatibility risk modify _CODE_
You return mock supplier test SuppliersofInstance6ac1e746b1ea4da5a24ecaf1a978789d This way dont need overhead starting mock server creating context etc
pass PropertiesemailQaart4 argument need create additional string
Why using empty string first argument
Can simplified return new _CODE_
Use values creating _CODE_
Looks like _CODE_ check redundant
ha new construct I thought thatid private field
nit merge lines METHOD_2 return given argument
Why use delete name method overloaded version additional parameter
Please log Bundle _CODE_ data
If reverse order would prevent races blindly delete check still METHOD_2
stream needs closed
Can info VAR_4
This doesnt need synchronized right
What static import
_CODE_
fail
unrelated commit
This redundant
You return actual type _CODE_ type
Maybe METHOD_5 could take long parameter This could avoid need downcast without reason
Primitive types cant null dont mark Nullable
since 110
inheritance
suggestion return _CODE_ brbr VAR_3
result variable never used could removed right Currently _CODE_ method called twice
_CODE_ inline null
I dont think need TYPE_2
Remove
consider leave old constructor add new one
forgot remove watchstart
return SUPPORTED_SERDEScontainsserdeName
Please add VAR_1 VAR_2
I think use diamond operator
delete null
putting default case switch switches without default know
_CODE_ required
For scalar value could 10 0 also qualifies
VAR_13 isnt used
Good catch null check I forgot Maps null key
Eeek eatin away exceptions
Only _CODE_ _CODE_ enough
use return _CODE_
Overdid foo String already smile
see Dont use get prefix ever I would use _CODE_ instead
Is cleaning METHOD_2 necessary I mean VAR_4 search results useful METHOD_2 anyway user could choose reset
Diamond operator missing statement
Shouldnt Logger may see weblog test
All setters TYPE_1 param check null since _CODE_ fail _CODE_ We safely set null base object instead
Should private
This method simplified java BuildVERSIONSDK_INT BuildVERSION_CODESLOLLIPOP return _CODE_ BuildVERSIONSDK_INT BuildVERSION_CODESFROYO return Abi2WrappergetAbi1andAbi2 return BuildCPU_ABI Also worth wrapping BuildCPU_ABI array output format always consistent regardless _CODE_ level
Shouldnt VAR_5 instead thisVAR_5 If yes would possible overload VAR_2 instead changing signature
Thank fast turnaround neetkee Well _CODE_ must first way Otherwise end _CODE_ already first _CODE_ Please fix together name author list update Copyright current year 20022017 After merge
Please call constructor thisname new TYPE_1 VAR_2 VAR_3 No need duplicated code
I think need return VAR_4 bc value specified max degree DEFAULT_MAX_DEGREE_OF_PARALLELISM return 1 say 40
I would suggest making method synchronized
It seems like could change free definition VAR_2 private final _CODE_ VAR_2 avoid copy
Since entire body synchronized put synchronized method
I dont think exception swallowed
Its better use shift operators Instead java value int Mathpow20 double better java value 1 The leftshift operator equivalent 2 nth power 2 1 advantage requiring conversions floatingpoint back also avoids expensive operations happen inside Mathpow The leftshift operator single assembly instruction
Why use strings instead enums color In places opposite example _CODE_ represented string
ivandalbosco casting TYPE_4 useless
Ok lets move back methods dont benefits extracting Sorry
useless parenthesis around _CODE_
You could optimize way like dont saving extra list VAR_3 added This may implemented ticket resolve tickets Just understand creating new list afterwards returning property list Think something like Pseudo Code _CODE_ iterate_over_lists _CODE_ conflict_found _CODE_ true _CODE_ _CODE_ _CODE_ _CODE_ return false
Package access Want mag alleen aangeroepen worden door de Builder klasse
make sure nonbreaking provide overloaded signature matches original public void execute TYPE_1 VAR_1 execute VAR_1 null And course make sure passing null wont break anything
final
Do method need public Would protected suffice
If acls supported noop similar _CODE_
suggestion _CODE_ m_associatedAlarmsaddnew _CODE_ VAR_3
You forgot change parameter
You dont need
This cast feels bit place I dont really better suggestion maybe autowired could add separate bean return type TYPE_3 returns object normal _CODE_ bean
Spotbugs doesnt like _CODE_ _CODE_RETRY_PREDICATE isnt final _CODE_ At _CODE_ 58 MS_SHOULD_BE_FINAL
VAR_3
Better extract local variable _CODE_ avoid noise Sonar defer _CODE_ calling method several times
please add braces
keep code consistency may use testKv2
That doesnt look right
es gibt ein _CODE_
It necessary check value compressed vector zero It guaranteed nonzero values store Which means need rename METHOD_1 _CODE_ class Please also make sure _CODE_ uses proper iteration method _CODE_ It METHOD_1
pynicolas switch
The build method necessary I see _CODE_ right
I think get rid two methods favour one way creating METHOD_1 TYPE_2 VAR_1 new TYPE_2BuilderidFoobuild The second method could replaced something like following TYPE_2Builder METHOD_1 VAR_1toBuilder
cannot verify right warnings suppress _CODE_ cast TYPE_2 removed asking TYPE_2hank _CODE_
I wonder possible simple wrap comparator Orderingreverse works would simple _CODE_ class wraps base comparator
At point throw Exception fine Its test
Remove public modifier
nit merge lines METHOD_1 return given argument
Why calling METHOD_4 I would worry would prevent _CODE_ optimization
Youre already getting boolean result check adding ternary operation true false redundant
Dont need something slightly opposite Check data instance TYPE_5 always call METHOD_2 since MessageTYPE_5ener anyway
It always good return empty list instead Avoids _CODE_
Same We keep scopedObjects_ since _CODE_ would weird
Why need VAR_5 node get system provider
use return VAR_1startsWithquery_VAR_1replace query_ _CODE_ VAR_1 style
These changes go away
The purpose publicate
I guess longer need VAR_1 _CODE_ implementation fully locking
_CODE_
Is line _CODE_ correct You arent ever checking VAR_2
sure _CODE_ TYPE_2 correct Im sure well tested
For Max Min Size I think synchronized removed setter methods make variables volatile instead
I think constructor doesnt need public
could bit shorter return _CODE_ And also remove profile param filter method _CODE_
If line 33 throws error line wont reached Prior _CODE_ delete would always executed finally block
need content constructor
I guess null check also nice see Like java _CODE_ null _CODE_ _CODE_ b _CODE_
I think method deserves protected tested
This constructor moved packagescope Then youre able insert mocked TYPE_1 testcases could spy backendcalls use SimpleTYPE_1createNonLoggingAllPermittingBackendinstead _CODE_
_CODE_ 0 _CODE_
Why synchronizethis since method synchronized
Change _CODE_ get rid casting stuff
dont seem find VAR_3 used could slid final code different designrefactorings
Not sure something need debug The Javadoc METHOD_1 explicit forbids calling METHOD_3 since called _CODE_
This _CODE_ method accepts TYPE_1 object dont need unbox TYPE_1TRUE
I found also fixed changing TYPE_1YPE_3 extends TYPE_1 TYPE_1YPE_3TYPE_1 TYPE_1hat might nicer introducing another cast
_CODE_ Severity _CODE_ Complete task associated _CODE_ comment rule
Hi Could please use diamond operator We try use wherever possible Thank
length checking looks redundant
suggestion thisVAR_3 VAR_3 null null CollectionsunmodifiableMapVAR_3
Im pretty sure super used simple identifier see JLS11112 It impacts fix code compile bothering bit
metalnow bug Activity call _CODE_ directly
Is line really necessary Isnt response property already logged _CODE_ level worker starts via VAR_11 rather _CODE_ _CODE_ constructor
need _CODE_
I would change bit logic always call _CODE_ check return null return String case
I think cleaner public long size return VAR_1
Should protected Knowledge link text belongs Page model classes A Page class expose _CODE_ method rather _CODE_
Shouldnt annotated _CODE_
Not critical METHOD_3 method implicitly performs clientMETHOD_3 also METHOD_5 method queries need return result check _CODE_ class
inverno Why dont use else With else without reading implementation methods _CODE_ know cases covered always hit one 2 cases Further advantage either two methods _CODE_ removed
VAR_2 null would best invert equals check java bucketsequalsVAR_2
drop unnecessary else private TYPE_1 METHOD_1 TYPE_1 key thiskey key null _CODE_ throw new PrestoExceptionGENERIC_INTERNAL_ERROR Spill cipher already destroyed return key
Please create useless variables readable directly use java return _CODE_ VAR_2 date VAR_3
Move brace line function
concurrency issue
Why method need new argument used method
suggestion new _CODE_ _CODE_
I believe VAR_4 always either nonempty string null never empty string since _CODE_ returned _CODE_ either _CODE_ based _CODE_ Generic_CODE_ already map empty null
Is constructor still use
We need declare throws TYPE_2
user may authenticator configured name kerberos hardcoded eg configs _CODE_ _CODE_ set _CODE_ I think
I assume change reverted
Is beeline thing I assume mean one use run _CODE_
Have tested I wonder whether index useful one _CODE_ _CODE_ I tried indexes least postgres doesnt think difference _CODE_ cost0001047985 rows315 width24 actual time00190019 rows0 loops1 Index Scan using publiclogs__myria_indexesSending_0_1_4 _CODE_ cost0001041718 rows5952 width24 actual time00180018 rows0 loops1 Index Cond _CODE_ 4 Total runtime 0055 ms _CODE_ cost0001047985 rows315 width24 Index Scan using _CODE___CODE___CODE__destWorkerId_idx _CODE_ cost0001041718 rows5952 width24 Index Cond _CODE_ 4 _CODE_ cost10476701047985 rows315 width24 actual time00220022 rows0 loops1 Index Scan using _CODE___CODE___CODE__idx _CODE_ cost0001041718 rows5952 width24 actual time00210021 rows0 loops1 Index Cond _CODE_ 4 Total runtime 0069 ms
could private
nan
VAR_2 might null probably better compare way
Flip X null style Camel
Meh methods could package private
ah yes course
static
Upside f override accepts tested first
I think underscore dash
Please move _CODE_ end method
VAR_5 redundant VAR_5Losers call _CODE_ removing line
This VAR_3 seems unused
else redundant
I find body readable size asserted first TYPE_1 ordered get0 operation appear deterministic know length one
nit remove brackets consistent 2 lines
Can private
realized dont need METHOD_1
Same _CODE_ _CODE_ need cloned undo change
Use new _CODE_ lose stacktrace cause
need static
please leave way intentionally referencing deprecated version
This method could take boolean This would allow tests executed order instead encryption staying enabled
private
reuse existing constructors _CODE_ false
Instead modifying signature _CODE_ _CODE_ change callers would simpler inject _CODE_ _CODE_ It looks like _CODE_ already injected Guice eg _CODE_ however miss eager singleton binding _CODE_
private
minor Do need calling methods
superfluous
shouldnt synchronized _CODE_
Could put _CODE_ used 3 times local variable
Descriptor never null Better throw exception
Why need print _CODE_ Would _CODE_ better
_CODE_ consistent BiomeType_CODE_
The order args little weird old first position last buffer
Theres need instantiate new list using set interface
This also longer needed
remove VAR_2 parameter METHOD_5 method VAR_2 parameter screenshot taken thus test execute longer possibly omit taking screnshoots increases execution tmie
We watch _CODE_ returning null suggestion event instanceof TYPE_3 TYPE_3 _CODE_ _CODE_
Ditto always restricting kvstore
Generics suggestion VAR_2 new TYPE_1
Let thing fail Ideally TYPE_5 shouldnt contain hive types partition handle materialized exchange
please order equals obvious whether equals required
It needs METHOD_2 value predicate
_CODE_
Missed one also extra version doesnt take boolean argument
I dont think part public _CODE_ Do need outside unit tests If please make packageprivate
Same previous comment
Swap arguments java _CODE_ j TYPE_1 VAR_1
Check null missing
arent VAR_3 syncronized Resolved
_CODE_ new TYPE_1
static
Use logger instead METHOD_2 calls
Do need 2 lines
Shouldnt _CODE_ part constructor Options
Should core swap inside VAR_1 block Seems like core swapped regardless optimize enabled
You probably leave part java _CODE_ _CODE_
METHOD_5 finally block could use _CODE_
1 format
I dont understand purpose local variable VAR_1 _CODE_ remove variable first
I think would make sense create immutable copy Iterable _CODE_ constructor instead
I think would clearer connectionsremove outside block I dont think throwing TYPE_2 unless think METHOD_4 always done even problem linkedlistremove case perhaps connclose try block
The TYPE_2 used constructor
Id really really like _CODE_ objects immutable use lot places
Remove parameter completely constructor initiate publisher null
Not sure right place code Is generic place eg _CODE_ predicate TYPE_1 target obviously class called Callables already guava I dont yet see common enough thing METHOD_1 justify first class method TYPE_2
Same
Wouldnt contains method reliable case spacing different beginning end line
Please make java _CODE_ current thread handle _CODE_ Your version raise _CODE_ failure case I consider _CODE_ bad idea gives illusion object fact null If want keep version needs java _CODE_ current thread handle _CODE_ _CODE_
This isnt strictly public _CODE_ balancer one internal points code injection users change Accumulos default behavior If _CODE_ change avoided preferred
Fix spacing try block Also dont want eat exception wed want code calling method get exception figure
Ditto
dont need already called super method
You check VAR_5 null calling VAR_5getFocusedStopId prevent potential _CODE_
And instance equality Does make sense credentials without _CODE_ key
One unnecessary save restore system property value Please remove consistent entire test suite use _CODE_
see comment
We unpack inequality operators Because assume assumption higher bits always zero Therefore dont think downcast byte needed
I think probably better update VAR_4 caller code access cache
Im sure allow set null bean class If remove _CODE_ method throw _CODE_ resulting string
Unneeded cast
Since earlier commits enhanced serialization avoid losing multitypes test simplified _CODE_ expectednorm cases
_CODE_ awaitlatches0 awaitlatches1
isnt contradictory line right
TYPE_2 _CODE_ TYPE_3 I guess simplify
Same remove leave value false
You return _CODE_ result directly making ternary true false redundant
Can add logerror catch statement
creating new empty VAR_16 could expensive _CODE_ well mem usage Should consider using null empty map
would useful mark methods final
To conform team standard would please prefix field
This public _CODE_ lets change If need VAR_1 VAR_4 test create static method _CODE_ make That keep change confined test code
The parameter bee removed
Confused wait context loaded notifications happening background thread By time method VAR_12 run full initialization happened already
file systems path case sensitive
TYPE_1 needed
final
needed
Package private visibility preferred injection constructors Change java Inject _CODE_ _CODE_ VAR_3
url
How following simplify string construction java String VAR_3 SystemgetPropertyZK_SASL_CLIENT default VAR_7 String VAR_5 SystemgetPropertyZK_LOGIN_CONTEXT_NAME_KEY default VAR_8
I think race _CODE_ _CODE_ shutdown population jobs added _CODE_ called Result leak population jobs It might guarded higher stack But I think guarded explicitly Either _CODE_
I would remove since exception fails test better reported hide
move assignment check first method change behaviour
This private unless plans use outside class
Naming suggestion _CODE_
Duplicated line probably global replace
I dont see using VAR_2
suggestion private final _CODE_ extends TYPE_3 TYPE_4 VAR_1 new TYPE_5
Is possible get rid
seem use datacenters colos throughout code I think stick one consistency colo seem colloquial Im sure
I sure good practice create TYPE_1 _CODE_ TYPE_1 really tied Activity We recreating every Activity Thats needs done So I sure makes sense
In general injection constructors package protected Just remove public modifier java Inject _CODE_ VAR_2
I dont think need check Just always log info The VAR_8 going check enabled anyway enabled useful log line work
nit merge lines METHOD_2 return given argument
I would take This distraction could better solve tool like errorprone divert someone wondering hmm String Instead focusing real code theres distraction Id note potential snafu ps take Nullable
return loop var greater INT_1 One way also get rid set could use switch switchc case case case nb break ifnb INT_1 return true return false
Remove unnecessary final modifier local variables
We use single line ifstatements throughout project Yes nitty point Id prefer change curly braces
Can VAR_3 null since explicitly check null adding _CODE_ _CODE_
implemented decodeBucketIndexEXTENDED_PREFIX_BITS VAR_1
seems like youre calling constructor couple places Is really necessary construct one TYPE_6 object per VAR_2
rename VAR_2
This call _CODE_
looks like need pass VAR_2 VAR_2urationVAR_2 baseLocationVAR_2 propertiesVAR_2 usage field set first line constructor
Id extract service method _CODE_
Remove
VAR_1 also synchronized Move VAR_1 METHOD_2s METHOD_2 method The thing execute method See
Its preferrable changed state setting parameter VAR_2 check parameters Although VAR_2s may store live reference parameter others may resulting undesired behaviour Furthermore Im aware VAR_2s use _CODE_ set behaviour
This use constructor version _CODE_ Throwable Otherwise lose stack trace underlying TYPE_6
As touching code base remove logging statement beginning exiting method
Is VAR_1 parameter Java 8
Is intended It could hide problems current runner wont stopped
Specs cant public ctors access factory methods
logger
Leave blank line methods
I think static
reset finally block
This cMETHOD_1 METHOD_1 java return METHOD_1params TYPE_9 null
It side effects connectors When sources compile
synchronized block redundant remove method synchronization
This method static
While I appreciate explicitness Id rather value inlined method call If want specific java _CODE_ value false _CODE_ encode
The TYPE_1 never thrown
bVAR_3ttVAR_3r suggVAR_3stion catch final TYPE_3 TYPE_5 VAR_3
_CODE_ Merge statement enclosing one rule
supposed VAR_1 null VAR_1toString _ _CODE_ _CODE_ _CODE_
Cleaner push constructor
vbradnitski use VAR_4 variable instead recall METHOD_3 VAR_1 method
Sorry nitpick make final consistency I also prefer parameters separate lines hard fast convention
nan
wrong casting
Im wondering instead would make sense unit test concrete _CODE_ Would cheaper execute probably also determinMETHOD_5tic Weve full integration tests already make sure filtering works everything METHOD_5 integrated
Is way simplify combination new code old code
typo
Why return emrapititle
VAR_4 descriptive name please use something like _CODE_ really number configurations executed test
If remove true method _CODE_ invoked anymore
Here neither
removed Line 278 279 already done _CODE_
Nit It necessary convert value String
Do change interface given critical path
_CODE_ nonnull Objectsequals designed accepts nullable arguments less confusing use _CODE_equalsDimensionHandlerUtilsnullToZerorhs Same Double Long
This backwards It logwarnex _CODE_
Need consider file extension upper case like _CODE_
There VAR_1 reason catch exceptions like thVAR_1
This Systemout probably caller Btw isnts logging preferred Systemout even tests
Given testing _CODE_ VAR_6 instance could removed altogether
nit Just write VAR_4
Cant simpler java return _CODE_ VAR_4 And move null checkcopy VAR_1 implementation java static boolean VAR_1String _CODE_ String VAR_4 VAR_4 null return false String _CODE_ ArraysasListVAR_4 _CODE_ null _CODE_startsWith_CODE_ return true return false Just means logic isnt two separate places I know changes time array copied make immutablethread safe If worried I guess get copied soon gets passed configuration
big deal dont put final variables even explicit good reasons folks make conventions like leaving keeps line shorter focuses attention test code risk someone shellgame references
Account instead Accoun
weird increment VAR_1 inside METHOD_1 How class inheriting Offset rather _CODE_
Can use curly braces
comment removed
suggest final
In 1294 currently targeted 413 proposing updating class collect assumption VAR_3 counts I sure make change
Add VAR_1 _CODE_ STANDARD_ALIASES list top class These get added criteria used _CODE_
Do really need casting String
I spidersense tingles If user table claims twice without checking METHOD_1 never resize Putting assert might provide better safety future devs
probably use VAR_4 directly without TYPE_5 conversion
A better fix would isolate null handling _CODE_ setter subsequent METHOD_2 calls never return null dont fix cases getter called
suggestion return _CODE_ VAR_1
inline VAR_2
listbox
Formatting looks wrong
never null
This variable necessary since using next line
I think false needs get changed true For reason default preferences doesnt work otherwise It shows checked doesnt actually work uncheckcheck Im sure works way Tested 500 51
Why equality check done equals
work tail command show last INT_2 byte I think java byte VAR_7 BufferUtilsgetIncreasingByteArray10000 INT_2 INT_2
I guess VAR_4 method param VAR_4 right You make method simpler
Mesmo que anterior Se funcionar essas duplicações podem ser removidas
return right away initialized already
looks like static method
Remove warning _CODE_ suggestion noinspection unchecked return _CODE_ TYPE_2
rather 1 inline whole statement 2 split significant different statements _CODE_ _CODE_
Potential _CODE_ Also wont useful _CODE_ set migration Could append _CODE_ object base _CODE_s METHOD_1 VAR_1 unique key also
Should trim suggestion _CODE_ _CODE_
Would make sense return intlong
The Override line
spreventing apreventing
Just case possible VAR_1 null
Redundant else blocks
Just note reviewers getkey throw exception key value null null check needed Im sure want make succinct though java return _CODE_ Im personally fan local variables used
Should put finally
Is condition ever false tests
_CODE_
In _CODE_ dont throw _CODE_ subclasses general remove
nit position offset length VAR_2 1
For sanity check make sure _CODE_ equal _CODE_
I think missed updating parenthesis one
I think simplify functions Something like java private static byte _CODE_ buffer TYPE_2 VAR_1 TYPE_3 VAR_2 throws TYPE_4 bufferremaining 1 _CODE_ VAR_1 VAR_2 return bufferget private static long _CODE_ buffer TYPE_2 VAR_1 TYPE_3 VAR_2 throws TYPE_4 bufferremaining 10 VAR_2value 0 _CODE_ VAR_1 VAR_2 return _CODE_ private static int _CODE_ buffer TYPE_2 VAR_1 TYPE_3 VAR_2 throws TYPE_4 bufferremaining 10 VAR_2value 0 _CODE_ VAR_1 VAR_2 return _CODE_ I think shouldnt need one call METHOD_2
Theres probably small overhead translate method reference call Im sure significant avoid altogether passing _CODE_ instead method Then mock test java _CODE_ random Mockitomock_CODE_class _CODE_ int invocationgetArgument0 return 2
_CODE_ enough
pls use diamond new VAR_7
Also use Privilege Exception You calling Bl method need throw Privilege Exception
You could call super since code identical
This true actually
Yes would nice
Why use new _CODE_ worldeditproperties
We use _CODE_ format
suggestion public void _CODE_ VAR_1
Variable never used
Looking 3 methods I dont see need synchronized All state appears methodscope
Il reste un sysou de trop
Seems point could pass VAR_2 instead
Redundant parenthesis Also know isnt calling _CODE_
could extract extra method _CODE_ instead repeating 4 times
Dont need _CODE_
VAR_1 true happen call superMETHOD_1 since base class METHOD_1 throw exception
I would check equality first add runable needed avoid unneeded runs
We dont need call _CODE_
need return statement
instead creating new object every time might make sense store constants predefined granularity string
Make static
Code style add space always use new line
There true
Does compile really important
nit private
Please remove This probably due incorrect etchosts file test environment
Can use _CODE_ map directly
This cast shouldnt necessary since catch declaration guarantees type block
Use braces see
Please remove condition keep content exit kill We handling There seems problem dont exit kill process More details
cant check size match VAR_3 Empty This also avoids _CODE_ next constructor
They mutually exclusive Or micro optimization
Please use braces Checkstyle pick
Forgot set set VAR_2 VAR_1
VAR_1 null redundant VAR_1 instanceof VAR_2 already returns false VAR_1 null
try resource
The VAR_1 unused
inline assignments
synchronization error
Typo And I think mainly use arg name situation ie _CODE_ VAR_2
Thats fine youre dealing internal implementation If youre going use ordering built type VAR_8 identical natural order enum seems confusing Id actually argue right answer define Comparator specific use case build precedence type But dont Id rather use natural order directly one level remove
minor access packageprivate support method names Internal suffix _CODE_
This exposure _CODE_ determine VAR_3 role outside VAR_2 class also unnecessary rather move check back _CODE_ getter refactoring
Maybe call _CODE_ length
I thought wanted end practice Adrian
add comment use _CODE_
METHOD_2
This done creating VAR_2 also _CODE_
sure needs synchronized
annotated _CODE_
Lets make first argument
Could put line right call fieldsaddnull
I feel like output isnt helpful since reprinting userspecified options
This logic looks like itll fine risk losing update locked state second iteration VAR_3 Conveniently look _CODE_ get method called _CODE_ _CODE_ I know I said fewer places locking better _CODE_ one place could use It also eliminates needing set locked flag somewhat random relative name method _CODE_java255 right Copy upstream fields comment would good place check set logic used
typo Should two r
We fail METHOD_1 time size Concurrent Policies hit max If say 10 policies trying failover hit max criteria If sink broken METHOD_1 never fail get required metric controlled failover ever
Why would call _CODE_ VAR_4 null VAR_4 ie put block
Id pass VAR_3 parameter transparent happens
nit I somehow liked old concise UNKNOWN_STATS
warning VAR_3 nullable argument highlights _CODE_ missing could testing Optionalempty returned argument null
VAR_7 constructor called _CODE_
Since _CODE_ doesnt use values maybe avoid sending back caller simply returning null
In existing code first statement Any reason changing order If I would like keep _CODE_ first statement
hrefs case sensitive Please use _CODE_ instead _CODE_
Probably another access modification dont need probably _CODE_
Youd probably rather use logging
Either value TYPE_2 VAR_2 map _CODE_ String
remark I feedback call classes _CODE_ without Ws I dont strong opinion
I find easier read fewer nested ifs reason java TYPE_4 VAR_3 VAR_3s partitioned k_1 k_2 k_n partitioned k_1 k_2 k_n k_n1 safely ignore constant VAR_1 comparing partition properties VAR_3isConstant continue VAR_3isVariable return false else knownConstantscontainsVAR_3getColumn VAR_1containsVAR_3getColumn return false
I would change return null VAR_3 VAR_3verifiedpayload VAR_1 true
extra blank line
Shouldnt rather call _CODE_
Prefer using private field mutex prevent outside code able hold lock java private final TYPE_2 mutex new TYPE_2 public _CODE_ _CODE_ key TYPE_2 value synchronized mutex attributesputkey value return
think another constructor well VAR_1 VAR_1Type VAR_3 false VAR_3 use cases except POINT_PROPERTIES TEMPORAL_PROPERTIES
remove unused parameter
static
Should VAR_4 annotated Nullable method well
Suseika please remove assert dont use
extra parentheses
What list empty still adds Xfriendpaths option
Shouldnt handle case single enum specified java private boolean VAR_1 VAR_2 null VAR_2getValueList null VAR_2getValueListsplitlength 1 return true else return VAR_2getValueListtrimlength 0 else return false
Minor I would suggest making VAR_2 small boolean builder change method _CODE_ setting VAR_2 flag true
Please convert tests use assertions rather simply printing output In general unit tests produce output make assertions It also recommended use message form assertion eg prefer _CODE_ number matches greater zero matches 0 _CODE_ 0
return VAR_1 null VAR_1isChatColours
use early return return METHOD_2 _CODE_ Java evaluates right hand side condition first even null pointer exception occur
_CODE_
Inputs 2 unique Please add parenthesis around lambda parameter like
This right semantics start free vars _CODE_ subtract VAR_7 add free vars _CODE_ That handles following case correctly let x x xy free vars x
Its possible log levels manipulated dynamically seems like thin use case dont need worry
This needed since constructor already checks
If failed poor wifi itll fail _even poorer_ wifi My suggestion would use METHOD_8 app pause operation complete If theres progress spinner something use _CODE_
I wondering perhaps makes sense include loop instead ie VERSION_NAME_TAG_KEYequals One issue whether want version name included VAR_6 property tag
Why dont push _CODE_ since thats deserialize actually invoked
I would rather something like java VAR_2toStringstartsWithContactsCONTENT_LOOKUP_URItoString VAR_2 _CODE_ VAR_2 avoid unnecessary assignment TYPE_3 match
Useless This line executed VAR_3 null _CODE_ thrown line
Perhaps return boolean say id found similar semantics Setremove
This 2 constructors One cause one already
Cant simplify statement without else
nit merge lines METHOD_2 return given argument
This condition inverted If _CODE_ username password empty call METHOD_5 method takes bucket password Sorry I missed earlier
VAR_5 VAR_6
Pass null TYPE_3 create default _CODE_
This question philosophy _CODE_ _CODE_expected actual You opposite It mean way coded wrong normal way least I used
necessary I thought assignments atomic operations
Is reason using _CODE_ Also needed remove spaces Are trying trim removing spaces words
nonnull annotation
Nullable param
I think safe remove
I think checkstyle complain due missing braces Maybe use instead
Why remove trycatch let Exception thrown upwards methods
Am I right VAR_1 parameter always contains values enum If argument removed values method called inside method instead
Rather instantiating view I think pass TYPE_6 constructor That way keep number places views instantiated minimum always want push late possible For example support _CODE_ probably push job committed
using positive conditions fail fast approach improves code readability eg _CODE_ null return null return Patterncompile_CODE_
It better remain original code The fetchcreateput action atomic Or every thread replace others
_CODE_ see
remove final modifiers everywhere
The expected value 1 must second parameter _CODE_
If trying make sure resources closed even serverclose throws runtime exception solving half problem btclose throws exception loop may proceed connection registry
Dont like Its slaves job determine whether master master
I little wary coz existing schedulers using setting might cause removed immediately Even though ideally want position rolling dont want unexpected behaviors
This variable needed could two return statements else blocks
I dont like change I dont know preferred way _CODE_ I would wont fix issue inside precondition
Handling nulls You later methods If null acceptable return null If lets either add lombok _CODE_ _CODE_ At present nulls give nonuseful _CODE_
could fit single line
Constants included method used know send none process variables task And still want VAR_3 section empty constant empty
Do want throw _CODE_ My thinking couldnt acquire METHOD_4 return without running next interceptor make noop like method defines
Put second return else block symmetry
Should xtype _CODE_ ytype _CODE_
Opportunity use _CODE_ 7 multicatch catch TYPE_3 TYPE_4 VAR_2
Why would expect _CODE_ To smells hack fix problem
VAR_6 string input Add bash c place call
The
This several formatting issues
It matter taste I would probably used VAR_2 null _CODE_ VAR_1 else haveSameLocationVAR_2 VAR_1 throw new DuplicateStepDefinitionExceptionVAR_2 VAR_1 In method named METHOD_1 VAR_2 null haveSameLocationVAR_2 VAR_1 triggered right add VAR_1 cases actually ok since put overwrites VAR_2 step definition new one
This could value instead VAR_3
suggestion _CODE_ VAR_16 MessagesLogRotatorPeriodicTask_noGlobalMatch _CODE_
Nadahar Isnt oga already
exceptions unacceptable intended pun miserably failed listing clusters resource allocation change related exception ever occur entity found kind thing
think better put _CODE_ data source must null _CODE_ VAR_2
Can add another overloaded method take worker count similar already
change name METHOD_3
Is necessary
null check needed instanceof return false left operand null
Why need value Elasticsearch
make listener inner class
мб стоит завести какойн отдельный _CODE_ внутри _CODE_ А то он будет брать треды из системного тредпула Не думаю что это есть хорошо
connector removed TYPE_3
line redundant use VAR_1 directly
Close VAR_1
Why pass null instead p
This method happily returns null time time Kaboom And yeah I know binding probably active selection But time would hurt add explicit _CODE_ 1 return method protect
nit But I think could refactored java taskofferPOISION_POLL Just try
Testing _CODE_ objects equality bunch weird edge cases Id recommend avoiding For example object could cloned clone wont match theyll look like object debugger wont obvious _CODE_ dont match How storing VAR_4 _CODE_ using VAR_1 _CODE_ VAR_1getId plus VAR_2 name key Then lookups faster plus identity reliable youll need check existence map
return mmethodequalsmethod instead line next
like id prefer blank entry null
set VAR_1 final
You need TYPE_2YPE_1 super TYPE_2
String args
See comment
Shouldnt pass exception logger user know failure
info METHOD_4
I see came back around I think nice since know know constraints based command type
You simplify ifelse block Java path null return otherpath null else return pathequalsotherpath
Same suggestion regarding nesting
check VAR_2 VAR_5 mutually exclusive
nit simplify code minor optimization avoid creating unused TYPE_6 instance java _CODE_ VAR_2 null VAR_1 null VAR_2 new TYPE_6 TYPE_3 field VAR_1
Can use fields comnetflixeureka2Names class instead strings Also Module binding
necessary anymore _CODE_ check
Floating semicolon
Ditto _CODE_
nit could please perform METHOD_4 calls finally block _CODE_ get METHOD_4d even assert fails
Please combine remove nested
You require srcs nonempty dont require VAR_1 nonempty So line throw exception
adding array support
If VAR_21 null need call VAR_2 _CODE_
Can transformed statement
We remove throws TYPE_3 since catching anyway triggering METHOD_3
So METHOD_2 METHOD_5 cannot true time Otherwise I would move METHOD_5 condition first check
Optional need throws TYPE_1 since already catch runtime TYPE_1
Please dont propagate VAR_3 parameter inspections Add additional overloading base class
Do need METHOD_2 case
This also synchronized
VAR_4 never null
Should use return fsexistsnew _CODE_ ReplUtilsLOAD_ACKNOWLEDGEMENT
think moving param new line would increase readability
This wrong VAR_1 return uuid class Since one none return string version id
This branch needed
If null invalid If null shouldnt valid default 1 basically
nit java nullsi INT_2 0
No need check null primitives
nit merge lines METHOD_1 return given argument
nodecount
逗号后面请空格
Same maybe would better move VAR_1 param offset
As already written previous _CODE_ I would expect VAR_14 could moved VAR_2
line 240 _CODE_ check specified key null otherwise _CODE_
null null bug whole purpose _CODE_ avoid null checking
I think clear field VAR_4 comes Maybe include least constructor code sample even I would add class statement well
Please rename connections _CODE_ Servers Also would nice change back list set instead map longer using cache dont need pull specific value longer We want close termination
Logging using standard output
This static helper class shouldnt constructor
Cosmetic We leave empty lines getters setters end files
I dont see constructor called anywhere commits way
perhaps go VAR_1 called increment decrement within method
You need remove VAR_1close since test class using _CODE_ closing VAR_1
simplified _CODE_ new _CODE_ _CODE_
Should final
make static
add curly braces
else branch needed
Why METHOD_4 VAR_1
Is change intentional As means method anything matter input
symbolname called 3 times maybe worth dedicated variable
_CODE_
It could VAR_1 _CODE_ _CODE_ _CODE_ _CODE_
Given configuration wouldnt make sense show parameters output accept input fix validation like done _CODE_
This change causes regression _CODE_ _CODE_ uses _CODE_ well _CODE_ added deployment _CODE_ So _CODE_ fails
Correct I wrong If METHOD_3 throws exception would handled And exception parameter still null METHOD_6 Same question _CODE_
Move try block
This closed TYPE_3 thrown
I think could one liner java _CODE_ new _CODE_
auto generated
change wont necessary start using _CODE_
It might better put VAR_3 last parameter since default value overloaded METHOD_1
Since TYPE_2 really designed extended would replace whole VAR_1 instanceof TYPE_2 Also I would move VAR_1
You dont call save modifying attached entity Any modifications attached entity auto persisted transaction closed
could final
Could get brackets around
See
Looks like creating Instant may also omitted
Should another method instances already TYPE_1 I using Dropwizard metrics VAR_2 created framework I would like make instance default As proposed java _CODE_ bootstrapgetTYPE_1 _CODE_ With overloaded METHOD_1 method java _CODE_ bootstrapgetTYPE_1
This else clause redundant since else clause always returns return VAR_2
If try switch app back app crash void _CODE_ null object reference
nan
move Mathabs next line index
METHOD_4 thread VAR_2 provided stack
VAR_3
We shouldnt calling That responsibility container since injected
Why java VAR_1 instanceof TYPE_2 MathabsTYPE_2 VAR_1 10e131 return VAR_2 return VAR_1
think else dont VAR_7 cwd user enabled VAR_5 option
Check null required element instance TYPE_4 returns false null element
I meant _CODE_ 0 could evaluated beginning method _CODE_ 0 return true TYPE_3 field getTYPE_3 return field null
Missing return true
probably better return _CODE_ _CODE_
Same thing
I dont think need VAR_1 Same next one
If really never ever happen probably log error warning
I think would bit easier read java return nodeBucketCountsgetVAR_7 nodeBucketCountsgetVAR_8 VAR_7 VAR_8 The assignment looks strange
Same issue change visibility method _CODE_
removed
What think moving creation TYPE_5 inside METHOD_3
How set negative size
I think slightly easier cleaner use _CODE_ p VAR_5 psetTextSizeDEFAULT_TEXT_SIZE VAR_7 _CODE_ posx posy p
Im fan setup sub properties I think would better setup _CODE_ extends _CODE_ passes constructor
try catch TYPE_4 hit applied
need TYPE_4
Not much equality isnt well defined types For example Stringclass Stringclass Stringclass _isnt_ equal VAR_3 _CODE_ There similar problems primitives intclass Integerclass
Probably crash bad format string
boolean instead TYPE_1
Nullability annotations
Default partitioner default Need specify
If youre going add METHOD_6 best VAR_2 finally block
This equals implementation include attributes Answer super class
Not sure guideline I would prefer use protected visibility rather package protected one
This could String varargs invocation would allow elide new String dance although maybe explicit better
Needs test obj instanceof Userif isnt return false
Debug logging accidentally left
1
benzonico copy done outside getter end analysis
TYPE_1 VAR_2 start 50 length 14 I think exception default error VAR_2 two constructor taken _CODE_ throwable
Is superfluous casting
I think drop redundant VAR_2 suffix task types eg VAR_9VAR_2 VAR_9 _CODE_VAR_2 _CODE_ timeoutVAR_2 timeout _CODE_VAR_2 _CODE_
Why need explicit boolean primitive using _CODE_ trick
You directly use string METHOD_5 using TypeCriteriaMETHOD_5
Wrong assertion see_no_evil
set _CODE_ instead
Im reworking code context class also avoid potential _CODE_ VAR_3 field might initialized noargs constructor
reason go ahead delete 3 commentedout lines
minor I think use return name ie elsewhere jclouds
Nice catch instead hiding bottom bar remove altogether never used backpack anyway
new TYPE_3 redundant
wont doubledecrement
Good way
Its nitpicking mostly personal taste I find difficult follow boolean changes code error prone How removing multiple methodexit points return eg return _CODE_
nits static import
Seems like theres broken test related change
Can one line
possibility VAR_2 null might better write equalsVAR_2
не понял что это
The code push pop wrapped try block pop invoked finally
So context immutable return false
remove
Please remove final
wiring twice
nit remove
Why superdelta false
Do support _CODE_ If support TYPE_1 either
Not fan Nullable parameters give clue mean open us _CODE_ issues Could explicit pass default configuration instead This applies Nullable configuration parameters _CODE_
In opinion function belongs TYPE_3
Could please move METHOD_4 set credentials provider VAR_5 null While latter currently default behaviour Apache TYPE_1 might change future dont want get _CODE_ sudden wink
collapse 2 lines
synchronized void Seems didnt run mvn clean package making change else compiler would caught See travis error
simply return method null
could VAR_2 _CODE_ _CODE_
Hi change produce compiler error see travis work public void _CODE_ TYPE_1 VAR_1 TYPE_2 VAR_2 null TYPE_3 output null try VAR_2 getDataSourcegetTYPE_2 output new TYPE_1TYPE_3VAR_1 StreamUtilcopyVAR_2 output catch final TYPE_6 VAR_3 throw new MailExceptionVAR_3 finally StreamUtilcloseVAR_2 _CODE_
I thought said youll move _CODE_
Toni could please choose better variable names equals VAR_1 say much newcomer codebase Or could avoid storing partial results java _CODE_ _CODE_ return false _CODE_ _CODE_getIdentifier return false return true Please let know think
You need mark VAR_1 final code needs JDK6 compatible
Just thought wouldnt create new VAR_3 everytime Shouldnt try use object VAR_4 VAR_2 true risk VAR_4 configured otherwise
As mentioned instead method method giving line number either VAR_2 line
String TYPE_1 needed
nit Ternary operator seems easier use
You could returned result METHOD_2 make returned value bit meaningful This historic boolean _CODE_ bit weird though
This mistakenly moved
There strong benefit However case risk new _CODE_ may thrown METHOD_4
tbarsballe gone done _CODE_ run ensure closed writers return METHOD_1 false rather thrown TYPE_1 Lets stick consistency principle least surprise
I think obj null obj instanceof TYPE_2
Is really needed log information like In opinion useful information log info level
Do methods need static
Maybe okay remove case light since default case
I think Mapclassequalstype remnant previous implementation removed
static
Parameter order inconsistent METHOD_1 METHOD_2
Why check I dont see code path result VAR_1 null check implies could happen If check necessary needs locking avoid race condition
I think would make sense create second method
This equals implementation include attributes Command super class
use generics member variable method arg If return type call doesnt matter use TYPE_1 places
I think I would drop TYPE_4 parameter use VAR_4 constructor We sure always thing case
Can update generator remove modifier constructor stays packageprivate level
Nipick follow Java conventions beginning variable names lower case We also dont typically prefix variables type information though I guess thats big deal want leave
Travis doesnt like Task _CODE_ antcheckstyle _CODE_ hometravisbuildspringprojectsspringamqpspringrabbitsrcmainjavaorgspringframeworkamqprabbitcoreRabbitAdminjava34033 Reference instance variable VAR_5 needs _CODE_ Any chances fix merge Thanks
Is automatically removing best bet demobox convention jclouds blobstore kind thing
What using stream api directly return first line
In _CODE_ impls Base version deprecating _CODE_ would preferable move code logic _CODE_ _CODE_ defer _CODE_ call either _CODE_s _CODE_ based boolean
I think overhead I believe good testing around Although Ill recheck test tasks _CODE_ merge
Think result missing Nullable similar types _CODE_
You throw TYPE_5
Looks like initialized _CODE_ value never change If remove setting value init make final private final TYPE_1 _CODE_ new TYPE_1
Id go ahead return false The logic doesnt prevent trying parse input value null empty And fixed go ahead merge smiley
_CODE_
VAR_4 redundant use VAR_2
Change _CODE_ VAR_3 loadBuildNumberVAR_3 _CODE_ also reference env
Why arVAR_3 sVAR_3tting thVAR_3 causVAR_3 VAR_3xcVAR_3ption thVAR_3 causVAR_3 VAR_3 Shouldnt bVAR_3 VAR_3 samVAR_3 thVAR_3 nVAR_3xt constructor
This packagelevel protected suggestion Visible testing static void _CODE_ TYPE_1
Im afraid wont work without VAR_12 parameter
Use values instead METHOD_2 save map lookup
Restore visibility methods class package level unit tests moved jaggrcore
use int VAR_5 VAR_4 0
inline
Any reason return last staging location rather first one
introduce parameter
already Can keep nonstatic remove
VAR_2 already declared synchronized map We may want switch regular _CODE_ guard access avoid double synchronize
Please remove line
You could make static method call directly within constructor call
And one luck
return _CODE_ null _CODE_containsGroovyPageValidator _CODE_containsGroovyFieldValidator
Is worth moving reporting synchronized block though I wouldnt expect convention VAR_1
VAR_1 descending go different order elsewhere class
Can removed
Same remark Elasticsearch part really TYPE_3 would want use maybe remove type parameter altogether
This lambda also eliminated
This simplified return VAR_1 VAR_2 null
4 spaces
pynicolas declare TYPE_4
Actually mock patient return null
Please use braces
No need METHOD_2 check since effectively constant string In words nothing dynamic string concatenation converted single string compiler suggestion _CODE_ register Spring aftercompletion synchronization existing VAR_1 processing Spring aftercompletion callbacks immediately outcome status unknown
Bit nitpick since already ifelse using layoutgettextfont instanceof TYPE_2 return null else would bit clearer
return _CODE_ _CODE_
Why make synchronized _CODE_ stopped many times wish
nit chain ctors consolidate code Makes easy validation etc case need arise future
Wouldnt better call _CODE_ _CODE_ VAR_3 case
suggestion return TYPE_1YPE_2 super TYPE_1 adaptorsgetattributeTYPE_1ype
Lambda could replaced method reference _CODE_
I dont like new indentation
_CODE_ simplified valuesstream use _CODE_ METHOD_5 check filters deterministic well return VAR_1 null VAR_1valuesstreamMETHOD_5_CODE_
synchronized required
You able remove
Unneeded comment
args
а возвращать TYPE_1 зачем int же
If dropped would still work VAR_1 could set null start
use strings
Why needed This default
sorry I missed earlier check isnt necessary _CODE_ null check
Is _CODE_ actually still needed
Hmm I think remove line Seems like needed since closenull nothing Maybe leftover line previous version file result set got closed properly something
Technically wouldnt TYPE_4 extends TYPE_1
Please dont enable basic default
Hier wäre noch ein Test schön wo nicht identify verwendet wird
You dont declare _CODE_ Non functions throwing exceptions
use logger
nit It seems VAR_5 needs field class rest removed In case meant class used _CODE_ serde please add _CODE_ annotations fields create getter methods
Unnecessary final
Is copy required
Could please remove empty block
theres _CODE_ ints allowed please add _CODE_ parameter public EventId_CODE_ int type
_CODE_ test null must handle null elsewhere probably find I scroll
_CODE_ request types
_CODE_ public
METHOD_3 might better name
If implementation always _CODE_ change superclass
strong opinion If METHOD_2 overlaps likely problem anyway
I think solves problem arent removing VAR_6 field object If dangerous reuse one stored isnt necessarily one used elsewhere surely shouldnt store later access
Exception already indicates
braces body
please change _CODE_ _CODE_ lot easier read
I think use diamond operator
We cant make breaking changes like point release cherrypicks I think choice add methods _CODE_ And perhaps makes sense retain int versions anyway users dont need long precision
I think lines 7174 dont need inside try block It would nice take order keep try block small possible
App would crash entering _CODE_ article
Can simplified VAR_2 null VAR_2getCacheManagerConfigurationglobalJmxStatisticsenabled
If METHOD_2 list end METHOD_3 need METHOD_2
Add _CODE_
VAR_1 instancVAR_1of ExVAR_1cutionExcVAR_1ption VAR_1gVAR_1tCausVAR_1 null rVAR_1turn VAR_1 ThrowablVAR_1 causVAR_1 VAR_1gVAR_1tCausVAR_1 rVAR_1turn causVAR_1 instancVAR_1of ExcVAR_1ption ExcVAR_1ption causVAR_1 nVAR_1w ExcVAR_1ptioncausVAR_1 How making rVAR_1turn statVAR_1mVAR_1nt simplVAR_1r
I would put VAR_11 first line next VAR_2 group semantically
could change return VAR_3 null getActionUrlVAR_3 VAR_1 usernull
Thank really better Would even easier would one longer condition
What happens case RECURSION_IN_PROGRESS Im sure need _CODE_ _CODE_ isnt simpler bit TYPE_5 VAR_4 VAR_5 _CODE_ _CODE_ TYPE_5INCOMPATIBLE
Is necessary scheduler hardcoded scan every 15 minutes If greater instead less
Wont change prevent use TYPE_1 Management interface without inputting VAR_3 For information VAR_3 edited
Nit It doesnt need called super
1 since VAR_11 used _CODE_
I think shouldnt strict The async mode ignored anyway component doesnt return _CODE_ See _CODE_ thisasync reply instanceof _CODE_ _CODE_ future _CODE_ reply So silently close eyes user configured _CODE_
Why VAR_3 default true set user This may cause lot unintended screen events
Class constructor packageprivate used internally
Why use packageprivate access constructor
This class immutable anyway wrap collection constructor rather every time returned caller
I would put TYPE_1 first argument class second
maybe create common utility function build _CODE_ duplicate kind code
Why empty string METHOD_1
One time invoke close directly destroy What letter mean name similar tcp test class And dont invoke close similar test tcp smile
_CODE_ warning line
pynicolas _CODE_ _CODE_
The idea didnt want enforce annotation id globally unique But effect case current implementation maybe _CODE_ Ok fix
VAR_2length final VAR_2 final doesnt need VAR_1 Are adding get code analysis tool happy
Whats point VAR_1 variable Doesnt turn 1 line 2
Our _CODE_ cant initialized without internet permission either dont need check
Use instead duplicating size logic
1
This method called often I would leave code asis I think simple iteration performant conversion lambdabased filtering
thispath initialized value necessary
Remove qualifier
The Only VAR_4 update remain inside METHOD_1 The remainder code already _CODE_
TYPE_3 constructed fixed capacity
The TYPE_1 never thrown
You must reset file related fields _CODE_ otherwise contents 1 file affect next unexpected ways Make sure checks reset fields VAR_4 reset new file
Im lover passing nulls methods constructors would another constructor without _CODE_ better
yesamer I think thats removed METHOD_5 put current columns widht inside factmappings decided happen user saves scenario otherwise rely status implementation manage
You could also TYPE_1 VAR_7 _CODE_ VAR_4 sure dont miss something base class It also makes clear reason overwrite implementation base class want change input raw value want add information returned property value
null check redundant refactor code something like _CODE_ _CODE_ return true since comparing String constant variable contents null check automatically taken care equalsnull always false
This trycatch block necessary It necessary using _CODE_ loginrequired
In case TYPE_2 doesnt really give anything A simple null check exact thing doesnt allocate new object heap doesnt require lambda Also seems much better readable String node _CODE_ _CODE_ null _CODE_ else _CODE_ String VAR_1 new HashMap2 VAR_1putDEFAULT_NODE_ID id VAR_1putsvgNodeId id contextsaveGroupVAR_1 Overall also much efficient original
I removed empty constructor 00 doesnt make sense So two possibilities set valid coordinates preferred set VAR_8 null check later
instanceof
Can either use _CODE_ _CODE_ _CODE_ VAR_7 ideal fail usual error messages telling exactly wrong whereas others least tell something like actual true expected false
This incorrect _CODE_
I think extend _CODE_ interface VAR_1 hibernate implementation call VAR_6 Having ties context object close hibernate implementation I want avoid ever want drop hibernate
The newly added line makes think _CODE_ reason D How java return _CODE_
private protected
String args
shorter write java return _CODE_ INT_1
remove
This method useful made public I going need _CODE_ And happened _CODE_ method I going need also Or I add
Merge return
Parameter VAR_3 final
remove line
You missing type TYPE_3
Rather casting ensure VAR_1 TYPE_2 defined
What 4th possible scenario bypass true initiator Will identity null
VAR_5 VAR_8 Ie arg name match member name
inline declaration
I dont follow method Shouldnt create new _CODE_ I dont see case reusing existing instance spill occurred I see evidence going back _CODE_ helpful
missing semicolon
Is null instance String Consider null check first
Same
Its little confusing named VAR_1 sometimes actually _CODE_
This method doesnt throw TYPE_5
Note _CODE_ return boolean well allowed used boolean expression
Is VAR_11 attribute _CODE_ That would useful thing add
Need check VAR_3 null
Werent already
Is method necessary This code called one place
Changing boolean Boolean binary breaking change Lets change back boolean let constructor explicitly assign null rather delegating constructor
The method grow already wanted add something putting lengthy readable way Note I also changed _CODE_ condition VAR_1 instanceof TYPE_3 return true VAR_1 instanceof TYPE_2 return true could differentiate partial VAR_1 instanceof TYPE_4 return TYPE_4 VAR_1getStep TYPE_4StepFINAL return false
final
Id write rather Its bit clearer imho
Make package private removing protected modifier
TYPE_3 start 98 length 7 boolean everywhere
Make VAR_1 default value false
Probably best beginning VAR_2 null _CODE_
This line unnecessary
I dont think change quite wanted 1 ok text returned non bot users yes correctly null new test demonstrates 2 case want doesnt work code invoked response empty maybe suggestion _CODE_ non _CODE_ respond ok
Declaration initialization VAR_5 done line
undo
Since improving code anyway I think switch using _CODE_ javalangString29 instead _CODE_ since lowercasing string always nonascii characters
The value checking needed VAR_1 We already check value test
I instead planning using _CODE_ method TYPE_1 list method would try _CODE_ Object _CODE_ cachegetTYPE_1_CODE_filterconverterfilter _CODE_ Object entry _CODE_ catch _CODE_ e exception ignored
Schwasrz94 move _CODE_ _CODE_ order object
private
Here use TYPE_2 initializer set _CODE_ see
Couldnt also methods invoked eg FooBarsubString3 I guess doesnt make awfully lots sense I think legal _CODE_
named resource
remove unnecessary parenthesis
missing return
I think want use VAR_13
class getting instantiated loop benchmark meaning VAR_5 initialization called per loop iteration VAR_5 static avoid initialization cost per loop iteration
go superreset shouldnt
doesnt seem right getter triggers node visitation Arent visiting twice nodes
Youre missing INT_1 would better
Why need else trackMessagegetStatusequalsSTATUS_PENDING block processing done block
I would remove final doest add value
Can simpler return directly return abswidth 0 absheight 0
cant fix magic INT_1
If enum iVAR_3lemented TYPE_2 directly could find configured one VAR_3 VAR_1
_CODE_ Severity _CODE_ Make METHOD_1 static method rule
Not needed test framework would fail expected exception thrown
METHOD_2 copies elements list array I think Might depend implementation better ways loop It also seems lose type information
METHOD_3 also null jobs triggered yet started Even though take care potential null entries safest omit together source case caller isnt foreseeing
I think tend use brackets
Make TYPE_1 constructor dumb possible Put logic instead
vilchikelena What arguments
This unrelated task hand please refrain polishing code even class
Why complicated
Method code simplified one line
TYPE_3 cast redundant
Just reconsidering design class pass TYPE_2 VAR_3 sort method instead
Use Method name makes usage clear
Implement hash code well
This method updating objects dependencies Project _CODE_ doesnt belong There _CODE_ method sets VAR_5 VAR_2 VAR_4
Replace thisin null
Why variable incrementation using foreach
Should cases reverse ie dont instantiate logger unless audit logging
id maybe suitable
Spaces
Compare null necessary since null instanceof TYPE_2 false
I think update value _CODE_ VAR_5
Having removed _CODE_ approotftl still need
Unless Im missing something _CODE_ _CODE_ either test starts finishes never starts Can one method perhaps named _CODE_
VAR_1 probably type symbol Moreover unknown VAR_1
Maybe split two tests negative positive
private
suggestion use long timestamp This convention server side least
x Follows unnecessary _CODE_ METHOD_7 zero _CODE_ _CODE_ It removed 059df0362e3fc35b1ec81490950162cfbd065425
This private youre forced use create I also didnt add param null checks Oops
Im sure want add logging cases It seems verbose bad requests
Where property without jclouds prefix used
nan
This line seems unnecessary Why VAR_2 null
Same _CODE_ I dont want actually use yet Please leave _CODE_ unchanged
unecessray anymatch afterwards
new _CODE_GENERIC_RECOVERY_ERROR Make sure rethrow catch _CODE_ specifically special case
Is double invocation performed purpose
Is case dont config
Firstmol probably use _CODE_ instead _CODE_
This line bit long math another line like movement array
I would keep new method private internal helper since thats one using I understand Otherwise clear need introduce _CODE_ since could use one
Get rid return METHOD_5 instead
avoid redundant pattern check suggestion thisquery VAR_2 null
Why cast long It automatically coerce Similarly _CODE_ Not big issue though
required
need wait TYPE_4 already wait inside
Can void
Please put parenthesis next line clear params stop method starts
METHOD_6 already
Mind removing Systemout
Id put right starting _CODE_ worker processes need wait cleaning process broadcasting worker uuids soon possible actually important
Static import
1
This still
_CODE_
Remove final We enforcing coding style simple code
We might want consider calling new method one dont duplicate code _CODE_ new TYPE_1 wdyt
shouldnt TYPE_1 override method support configuring button The default implementation return without anything Id imagine TYPE_1 would VAR_1 object others wouldnt
Can use Classes
Line longer 120 cols Please use ifelse
This variant little bit shorter still well readable think java source null _CODE_ null final TYPE_3 VAR_2 _CODE_ VAR_2getImportforEachVAR_2Type toReturnaddImportgetImportVAR_2Type
else start 10 length 4 dont need else statement since return Closed
else needed
The next parameter TYPE_7 super TYPE_3 super TYPE_8 VAR_7
Same The new flag VAR_3 passed used _CODE_
suggestion VAR_7 null
final
shouldnt started largest scope smallest
You pass null instead new _CODE_ TYPE_5
sure always want refresh grid deselectall executed
No need save variable Directly call show
Could please remove line
You dont need VAR_5 You replace lines single Stringformat statement
The methods _CODE_ packageprivate therefore nonpublic _CODE_ cant remove parameter altogether
This constraint unfortunate VAR_3 instances made mergeable
sxci 这个分号
_CODE_ _CODE_ Stringformats2f VAR_1 sum 应该改为这个
return false
I would flip clarity return data null null _CODE_ decodedata
nit I pVAR_4rsonally prVAR_4fVAR_4r VAR_4xisting VAR_4rror conditions VAR_4arly avoid ovVAR_4rintVAR_4ntation VAR_2 null rVAR_4turn falsVAR_4 try catch TYPE_1 VAR_4 rVAR_4turn falsVAR_4
No call methods
Worth use try resources java try final TYPE_4 VAR_1 ioServicenewTYPE_4path _CODE_ final String VAR_4 DecisionTableFactoryloadFromTYPE_4VAR_1 null return _CODE_ VAR_4
Maybe Monoerror would proper Generally would like error early late
Missed changed variable name appended Interface
nested ifs could collapsed
charset
Maybe make VAR_12 primitive int directly would cause boxing although low values cached non issue The memory footprint also increase due memory alignment I think short takes space int anyway
Missing braces checkstyle failing
It seems like passing event id super class constructor also making field might little confusing Personally I prefer approach used _CODE_ id object obtained _CODE_ via long id Long super_CODE_ extra field required Thoughts
Its really big deal reason using _CODE_
An _CODE_ wont work get _CODE_ next statement You need synchronized block double null check
VAR_8 Nullable remove annotation add null check
VAR_1 null _CODE_
nit merge lines METHOD_1 return given argument
Perhaps compare previous comparator level rather previous amount fluid
reason wanted change
The VAR_7 probably set finally
It looks like message called caller convert list array call method However would work fine VAR_1
Revert back _CODE_
When updating code replace plain asserts testing framework
connection VAR_1 never serialized
This seems wrong
Can probably avoid use TYPE_1 since single string return case concatenated anything else outside method Other change looks good Thanks contribution
Should method really public
Need braces
Minor I believe remove else youre returning body
change error
Remove synchronized keyword method move method
I think button always enabled Either form defined new form A form defined open form
Please add final
minor private method
set variable null calling twice method result ugly _CODE_ try VAR_1 null VAR_1close finally VAR_1 null
double wait
various things instance TYPE_3 Can bool Also types channels TYPE_3 possible All checking looks like abstracted away
I would inline VAR_3 TYPE_3 _CODE_ getFullyTYPE_3NamespaceNameTree VAR_1
I think return right need temp var VAR_7
Should division prior casting int
This bypasses _CODE_ simply throw _CODE_ plugins missing
Hmmm Trickytrickytricky I couple thoughts 1 Theoretically default instance could reset viewport size window rather size buffer would free default instance deal _CODE_ This would work accept need query size display every frame monitor changes Perhaps subscribable object could monitoring work notifying subscribers default instance display changes 2 In practice convert VAR_2 variable static one initialize _CODE_ VAR_2 instantiated This way class always instance _CODE_ available even shorten constructors
This VAR_2 could field need instantiate new one message
Why claim return TYPE_1 Doesnt really matter though
Returning VAR_1 seems bit cheeky method _CODE_
please remove else code readable
maybe make copy constructor case
There need use since loop body executed
Please add Javadoc public methods
I suppose _CODE_ constructor taking VAR_3 page _CODE_ Then wont need setters
Unlikely could throw _CODE_ Better check null
Why pass false
What _CODE_ doesnt
nit readability prefer method called _CODE_ determine whether METHOD_2
If key null check nullness key would throw _CODE_ A better way could ConstantsMAP_MEMORY_MB_CONF_KEYequalskey Similarly reduce memory mb
Конструктор должен быть публичным
Add another constructor without instanced VAR_3 make one testing Or imagine using instanced VAR_3 server side
Think skip Stringformat
Make lists immutable
Why RESTART_JVM _CODE_ I add boot service installed immediately Youd redeploy app use module doesnt even require reload much less process restart
minor nit maybe call counter consistency methods named noun type represent named verb relating type represents
I assume either calls throw VAR_4 cant actually reach host startup fail
could _extract method_ avoid duplicated code METHOD_1 _CODE_ methods like type _CODE_ add 2 lines METHOD_4
Add test 404 fallback METHOD_5
I know copied Thrift still seems unnecessary wrap _CODE_ new _CODE_
This explicitness doesnt add lot value cast let throw _CODE_ It also log wrong class unlike current code
Um bit static classes constructor Not Static classes means doesnt implicit reference outer class The camera could passed constructor It could also set setter The class could newed time used
This method skip final
dont need trycatch valid tests The test fail anyway exception occurs
_CODE_ go top would already accessed checksumvalues
Looking _CODE_ I think line omitted
Both histogram based natural breaks quantiles percentage calculation require counting portions VAR_2 given set ranges necessarily match VAR_2 limits So two using two different methods compute results
bkmeneguello Are sure codecode correct
_CODE_ Severity _CODE_ Add Override annotation method signature rule
No need pass values back VAR_2
Why _CODE_ always true I guess forgot remove line
Needs static import
set final
Is need asserts The reason Id prefer one I dont want user get one error fix get another Since _CODE_ implied METHOD_2 give user one error message repair problems
needed Also make VAR_1 field volatile checked modified invalidated different threads
Are sure null never reaches point
Similar comments
something missing
Im seeing added benefit one since _CODE_ displays information Is necessary
This shouldnt call METHOD_9 It use VAR_1 passed otherwise lose local values passed obtain method Do agree
_CODE_ METHOD_5
Message seems unused Remove line
Better return null let callers deal null however want This default _CODE_ _all_ cases deserializing VAR_1 even unforeseen ones might ideal behavior
This cause creator change every update
Minor dont really need call METHOD_2 since class member
Double volatile read gone Can get rid VAR_4
luyangco You remove _CODE_ return _CODE_
I would turn around A simple _CODE_ check lot cheaper full parameter assignment verification
Doesnt belong automatic subscriptions Its necessary using manual partition assignment
dont want create factory injected
Findbugs says redundant nullcheck indeed VAR_1 instanceof TYPE_2 false VAR_1 null
Unless variable created make code easier read could simplified _CODE_ _CODE_ _CODE_
I think method need static
Same thing two avoid creating extra intermediate list
confusion goal client code indeed never write implementation _CODE_ would simply empty see I mean
Why inject TYPE_3
_CODE_ make packageprivate remove deprecated tag
nan
keep default constructor sets false
It support date
This seems like property If measured material otherwise Im confused could function material tag
VAR_2 never reset
private protected
Putting VAR_9 thatVAR_9 first make comparison fail faster
Dont need typecast TYPE_2
This nit least _CODE_ white space looks little looks like one indented tabs spaces similar Also Id add curlybraces nested ifs consistency express ternary conditionals
This seemed little weird It seems like methods job pick protocol also deferring _CODE_ constant pick protocol This usage field Can inline see one place protocol going get used
Maybe start accepting _CODE_ generic But I know yet case everywhere else
VAR_5 empty
This really relevant _CODE_ Its data rules internal helper In practice always going true anyway since singleton component
mime type mandatory
Do need delegate first superclasss implementation Looks like _CODE_ performs functions around created updated
Nit use 2space indent Also I think dispense else statements write return return
Ditto super
I think since change future release better let easier update
I admit I never considered negative numbers Both min max integer suffer overflow though Im sure matters
Since creator isnt modifiable doesnt need loaded database update Itll already fully loaded managed VAR_9
Please consider adding overridden version _CODE_ int Logger constructor accepts Duration encapsulate type conversion
The additional check used instructions needed
If find analysis panel starts going bit loopy _CODE_ said might want check METHOD_1 implementations try use result result type construct I dig original email like
Dont need set objects explicitly null
checking semantic done checking type VAR_1 semantic METHOD_2 used get parameter type method
cant u use count instead index
I suspect ask master
To safe check _CODE_ null first
Replace method content _CODE_ underlying code delete entity also fire event
rather arbitrary limit always going able get basenode given VAR_1 guaranteed descendant
Please call _CODE_ thing 3
No TYPE_2 thrown throws removed
schosechoose
warning misses closing parenthesis _CODE_
What status INT_2 Should check bestatus INT_2
Better reuse function one
VAR_2 may null Please add null check
final
Use Dsl
I dont think need TYPE_1 iterator supposed simple case _CODE_ eliminate allocation
Maginatics uses _CODE_ expiry _CODE_ Is something else wrong test If commit shouldnt skip _CODE_ well
nit This redundant next check also fail expected VAR_2 null
If classes part atlas repo lets change static factory methods per code style
Stray doublenewline Also newlines individual parts Im confused isnt formatted exactly _CODE_ event I think referencing anyway java return new _CODE_ null _CODE_ _CODE_ _CODE_ _CODE_ null damager null _CODE_ _CODE_ _CODE_ _CODE_ null
Remove
Whats relation change WFLY19339
I think placement might problem number call sites call _CODE_ boolean would essentially bypass resolution I think may either edit main METHOD_1 method capturing every return statement else wrap whole method method substitution though reduce maximum stack VAR_3 achieved
This moved _CODE_
Lets use method overloading
This wrong You cannot construct _CODE_ like Please _CODE_
Hmm actually need compute VAR_4 METHOD_1 call used
explain
remove one commit
please use method directly dont need store variable
This would better package protected instead public
Could declared final
match returns true METHOD_4 METHOD_2 empty need previous
make private
Make private
would protected indent adjusted
Revert private
static
While code made work introduce complex path intended The idea _CODE_ recursive structure The toplevel one holds hints row Nested instances hold data maps Because class meant temporary holds hints information used available defaults used hints available So better approach would assemble TYPE_3 output row one step Then apply entire row another step Further dont create VAR_6 objects every vector allocation reuse set output row sizes dont change Further code easier reason since wont two distinct paths
This method lead _CODE_ java _CODE_ null _CODE_destroy
better use name instead null
public
need two substring search index suffix starting index prefix
stopped superstop
TYPE_3 constructed fixed capacity
return type double 10D
See avoid TYPE_2 passed class
actually I think Id prefer keep old constructor would call new constructor _CODE_ false
_CODE_ never returns empty set
Why change I see reason please revert change provide compelling reason 100 necessary Please note code may rely VAR_9
You remove super
VAR_1 null
METHOD_2 already called different path
seems TYPE_2 unnecessary remove
see
No need call _CODE_ TYPE_4 take TYPE_1 constructor well
VAR_2 parameter lost call superVAR_2 instead
already VAR_1 available need get context
_CODE_ threadsafe multithread METHOD_2 might wrong You protect
Share code _CODE_ please
How come job request added parameters automatically list VAR_6
Was intentional add VAR_4 list _CODE_ output That seems redundant count min VAR_3 fields already
see
Static import
create new list immutable
This wont work target _CODE_ Return File object _CODE_ Change signature
Do use try catch please instead use _CODE_
As I know synchronizedthis good practice case want synchronization VAR_4
_CODE_ Severity _CODE_ Do forget remove deprecated code someday rule
also wrong arguments order
personal preference aka call return new VAR_8 Rather dumby constructors VAR_8
Code style Missing spaces curly braces
METHOD_1 info level since _CODE_ make another hop enable METHOD_3 topology
Isnt TYPE_2 deprecated And therefore _CODE_ rather Resource api used stated last email platform team
thisnew _CODE_ VAR_3
shouldnt METHOD_5 schedulers METHOD_1 directory
Use Java 7 template _CODE_ equals instead thats using elsewhere
Please remove super
Unnecessary
I would consider using _CODE_ width int height _CODE_ instead using directly METHOD_1 Think METHOD_1 delayed resizewidth height call
shouldnt return null If I dont like _CODE_ might return TYPE_1 quite different meaning
please invert condition
return _CODE_
One two METHOD_1 lines removed
Does need implemented liveserving mode
Cleanup
I dont think need VAR_6 remark
Remove Log please
mjwall I found bug Its fault I suggested clearing VAR_4 bad thing VAR_4 shared transactions It immutable set Ill open issue
Another potential redundant rewrap TYPE_3 value
change Line 96
artemsmotrakov Please use _CODE_ _CODE_ parameter Alternatively might want use noncase sensitive regex matching
TVAR_1 imprVAR_1ve readability please rename VAR_1 tVAR_1 key VAR_12 tVAR_1 value like interface
Lets remove protected packageprivate instead
Unecessary
The TYPE_3 class bit misused _CODE_ particular property accessed property String Boolean Please see
Could final
Might nicer allow null pass null instead c
Do still need prepend blank space youre using _CODE_ If able simplify little
Likewise string comparison
minor qualifiers required
Would compile
debug artefact
Tell dont ask Remove METHOD_2 add _CODE_ method instead
Please use brackets even around singleline blocks unless body line introductory keyword Eg x1 _CODE_ else continue x1 _CODE_ else continue If part style guide update Of course debatable hashed mailing list years back
I like
Lets keep default constructor default builder No reason force builder properties
There need explicitly TYPE_3 uses METHOD_11 VAR_1 assertTrueVAR_1containstripleS3 P3 O3 makes tests shorter clearer
Was going pr caught eye Money objects meant immutable like Java Strings Could change back private use _CODE_ relevant places instead
This first null check necessary _CODE_ checks null returns false false
whats reason extra variable VAR_1
nit dont need
Probably dont still need test log
Should VAR_4
Please use _CODE_ VAR_12 instead
Make public static call live test avoid code duplication
The call METHOD_2 instead TYPE_2
_CODE_ parameter needed
need declare type _CODE_
convert private constructor static create method
Please remove moddercontrol VAR_1 controlled person running server This allow server admins fix issues particular server
Why bump INT_1 across board
I guess could omit parentheses around _CODE_
interesting surprised works maybe I shouldnt
This might good fit dowhile cycle
nit sort member var names So future adding new member deterministic location
Can set _CODE_ constructor
minor put _only_ statement expect fail try
One interesting feature VAR_1 VAR_3 null reading time That _CODE_ may see field foo dont know inner type yet So safety allocate inner VAR_1 VAR_1getDataVector nonnull Also note repeated list dimension So inner VAR_1 another repeated list lesser dimension The code handles case But sizer handle nested repeated lists Do unit test 2D 3D list Never _CODE_ produce structures dont seem exercise operators complex _CODE_ structures We probably
VAR_4 method argument passed METHOD_3 argument
particular reason youre setting value node 0 couldnt value
Can VAR_11 templateVAR_11
Im sure I like interfaceit wordy little cumbersome user Also prospect TYPE_3 class used anywhere else Ill work way simplifying
need null check I dont think
Just nitpicking condition put clause avoid break middle loop
VAR_1 implicit flush
Thanks clear way describe VAR_9 condition We tend use braces even single line statements
_CODE_ If make input Collection take Set input You also consider using TYPE_1 internally instead array It might make simpler
For sake consistency use _CODE_ instead METHOD_3 since lowercase calls
suggestion assertEquals0 ec2CloudgetTemplatessize These assertions usually ordered _CODE_ actual
makes wonder _CODE_ virtual instead final dont need precompute keep around field thats completely derivable fields already
What theres stripes It feels like initialized empty
would made sense create method didnt take second parameter
This right provider prescribed order always going person discontinue dont copy field
cast necessary
The index field read local variable outside loop
No real need return type P
这里少空行
Many developers use VAR_6 class protected word But words like type could better cases How following return type _CODE_
We dont use final Please remove
Can info
Could update method signature please Asking consistency java int VAR_1 int height
Is reason short circuit I know Im probably nitpicking I feel would slower due extra complexity preventing _CODE_ optimisations
_CODE_
I think packageprivate user use _CODE_
We also assert VAR_2
This test wrong Its title states minutes range hour actually range INT_1 Minute 0 never gets checked
one intended use follow backpointers implementation set true
decrease _CODE_ throw exception possibly cause _CODE_ get sync actual allocated buffer
Redundant modifier See Travis report And seems whole class private
You forgot set VAR_2 first VAR_1
METHOD_1 vs METHOD_2
No else needed exception stops method code
1if first one request fulltrue next request fullfalse still get old one 2i think better loading per request since rather block wowza thread long
Could sVAR_3gle trywithresources block two resources sVAR_3gle statement VAR_3 body
This means need set timeout able disable cert checking purpose
Dead code
add break statement
unrelated change drop change While admirably correct closer personal preferences style follow unless necessary We value terseness higher
move Before method
use _CODE_ String TYPE_1 _CODE_ _CODE_ String TYPE_1 int one
Oops I meant accessors abstract chat message class indicate overridden Could undo except ones abstract class
No need define throws TYPE_2 function It extends _CODE_ public _CODE_ _CODE_ opac
VAR_1 could null
amihaiemil move 1 line
If doesnt throw exception please remove throws clause
need declare unchecked exception
This need null check done make sure default returned field isnt set ie null See _CODE_ example although obviously default return different
minor Just return _CODE_ keyskey1
Spacing public Foo public _CODE_ bar
code correct per VAR_5 comes VAR_4
private also
protected
Static import assertion methods
Is really worth replacing new lines sides sounds like useless I may missing something
Did intentionally ignore VAR_2 parameter
We usually final local variables
This doesnt seem used
This shouldnt happen construction Firehose factories get constructed semifrequently anytime Task objects deserialized doesnt necessarily mean really used Anything hits disk network deferred firehose connected
Could move util class thats clearly marked nonpublic api
never set anywhere code Either remove hardcode 0 return value set VAR_3 0 break loop line 348
Can call _CODE_ rather require separate method retrieve _CODE_
double checking really intent change looks odd
You could returned _CODE_ ifelse cases
boolean
This constructor invoke thisnew _CODE_ VAR_3
I think runkey faster keep _CODE_ byte
Remove Mutable
Please use unnecessary You write VAR_1
Invert get rid level indentation
_CODE_
Just curious checking _CODE_ Cant call close multiple times
I think default filter attribute filter You continue using _loadSavedFilters_ would set default filter automatically
remove line please
Is method really needed
Shouldnt method private
None methods try block throw _CODE_
This throw exception theres one arg
The argument _CODE_ apply _CODE_ dont write read hence TYPE_2 could ever happen
Just minor point VAR_2 null otherVAR_2 null return true VAR_2 null otherVAR_2 null return false return VAR_2equalsotherVAR_2
field point null theres need additional work return Optionalempty Otherwise find resolved name use Optionalof Something like java TYPE_6 field METHOD_3 GetDeclaredTYPE_6action VAR_1 VAR_2 field null return Optionalempty else String VAR_3 VAR_2NodeNameProvidergetName new _CODE_ VAR_1 VAR_2 return Optionalof new JavaBeanTYPE_6 field VAR_3
You move line _CODE_ test methods
Dont initialize empty null
_CODE_
_CODE_ checks whether _CODE_ returns null I would suggest checking VAR_3 null avoid double invocation
Move VAR_1 0 check It help avoid extra comparison requested VAR_1 0
Same suggested simply value null
Do want keep logging class Asking log type resolved operator cell
Why one _CODE_ field default tother _CODE_ field METHOD_5 default Id pick one stick
Better throw _CODE_
Ideally test wouldnt require change pass The _CODE_ wasnt used past unless polymorphism used type shouldnt really matter
nit could also move METHOD_2 calls
The logic make sense The VAR_5 null logic happen creating object otherwise redundant object
Same
either _CODE_ 0 _CODE_ 0 _CODE_ _CODE_
Why extra semicolon placed Also try refactor code unless absolutely required
You remove braces
maybe add required true VAR_3 params
_CODE_
English Returns whether block
Is type variable really required
Unnecessary final
Is TYPE_1 thrown anything method Or return void throw TYPE_1 instead
nit iVAR_1 VAR_1
seems unnecessary
also tiny thing sometimes miss whitespace
Should condition METHOD_1
Nitpick In methods declared class put method modifiers order public static That standard way recommended _CODE_ I also believe makes code bit easier read
wrapping inside try clause suspect authenticatorclose throw exceptions VAR_2
Im bit confused exception catching The METHOD_2 cant fail So either error null isnt TYPE_3 cases handled check
parameter sequence swapped VAR_1 min correct
As suggested _CODE_ suggestion public static TYPE_1 protofinal TYPE_2 context return VAR_1 VAR_2 new _CODE_ VAR_1 VAR_2
instead x return true else return false I usually go return x
Useless semicolon
Remove throws TYPE_3
Youre probably making public test purposes Instead making methods public tests appropriate package dont need use access modifiers inappropriately I say inappropriately method shouldnt really exposed applications public
anymore reverted change 1 comma
Why files using paths instead local file resource folder
Edit process project Here click METHOD_1 Link wait redirect _CODE_ page
_CODE_ Move _CODE_ string literal left side string comparison rule _CODE_ Move T string literal left side string comparison rule
concerns file I see defensive code possibly ways less code example blocks defense delegation methods would need
adding three anyway _CODE_ VAR_1 String VAR_2 _CODE_ VAR_3 _CODE_ String VAR_4 method
This simplified _CODE_ worth
I think remove METHOD_2 doesnt show crowdin
Seems output name cache reset
Make methods final cant accidentally overridden
This method throw VAR_8
Sorry one This initial delay doesnt try clean immediately Its less important creation errors keep emitting right failure This means failure keep triggering fast instead every VAR_2 VAR_4 ObservableintervalVAR_2 VAR_2 _CODE_
If _CODE_ nothing try remove _CODE_ Can return true well
The orchestrator pass connected client ie VAR_4 ready creates workflow needed
typo _CODE_
Use _CODE_ see element page
even necessary given use new VAR_8
VAR_1 _CODE_ needed anymore
nit merge lines
Null check redundant never happen
packageprivate intended visibility missed access modifier
As
Can add _CODE_ Always useful debugging
Same
Another static
The else seems unnecessary
Better error message say VAR_4 supported parameters
Why list type
Removing synchronized means risk dirty write
Null check You Javadoc far likely copypasted
Make _CODE_ VAR_1 easier use
You use static public field TYPE_1 instead hardcoded INT_1
Having Java Config style itd better make class public
instead changing visibility constructor maybe make static factory method _CODE_ public client code Jet side work _CODE_ interface
This would unexpected consequence someone dfweasdfa pattern right inside password property
Change signature package private Guice injector test classes directly instantiate class Then remove redundant null checks
Wouldnt starts make sense
navigate page get add parameter end line
three statements folded one return id stateid count statecount
Why reset Is standard _CODE_ compression supported How hard simply support
Once constructor visible injector null check redundant injector already checks nulls Remove
lowercase B TYPE_2 Otherwise code could passed null
condition always true
In implementations VAR_2init Maybe follow approach everywhere Also understanding VAR_2 optional places init probably check null
This constructor really calling featureful constructor consistency avoid duplication Something like thissuccessful VAR_3 VAR_4 _CODE_ _CODE_ VAR_5
This duplicated check invoked _CODE_ true required invoke If absolutely want check Id opt java VAR_2 null much easier read
Must return true Also must return false code VAR_6 null
let _CODE_ handle set default setting
Same length 0 _CODE_ Ill stop mentioning rest
This doesnt anything
2 columns
Allocate write _CODE_ _CODE_ related event ignored lookup _CODE_
Arent name VAR_1 properties already added super class
TYPE_7 handled left _CODE_ needs check custom marshaller defined TYPE_7
For large libraries METHOD_2ing call METHOD_1 may introduce lot latency At minimum I think want move METHOD_2 outside synchronized block might better short long term would METHOD_2 _CODE_ relatively infrequent action
unify conditions make method clearer Return true false according
The jobid already values
minor _CODE_ VAR_1 response
using
Better use _CODE_ Rule use Testexpected _CODE_
Nit could simply VAR_8 attemptidendsWith0
You dont need loop The call remove line 716 either remove entry exists nothing doesnt exist Because changes map result _CODE_ written since youre modifying loop iterating
Didnt agree null check VAR_3 isnt needed sambe
Probably crash bad format string
Dont catch generic exceptions Narrow something specific
Can add explicit else block condition else
consolidatVAR_5 catch TYPE_4 TYPE_6 VAR_5
This really nit I would _personally_ prefer inverting statement _CODE_ VAR_2 return VAR_1 That way 1 simplest part code taken care front 2 indented line short line long line
We slightly simplify java return result null _CODE_ _CODE_
consistency use final int
Please write _CODE_ instead checking size
This method static methods calls
nan
think add method somewhere
Actually feature _CODE_ arleady adding VAR_1 instead
Consider moving _CODE_ What new default methods introduced java 10 require special handling
I know havent written code first place touch fix please clean well Those short notations awful read please write I get I read couple times obvious understandable first place Also VAR_3 created first You dont even know needed yet ifelse return statement evaluated So bother computing time Originally value branch needed
This needed already handles exception method
need VAR_3
return VAR_7 null PlatformYOUVIEW_IPLAYERequalsVAR_7getPlatform
What code changes class throwing exceptions VAR_11 cause change throws definition
I notice models method dont use static Would mind making instance method consistency Also see change private visibility I dont think theres reason leak interface package
I would imagine new contains method takes patient object internally delegates old one wouldnt need changes
Shouldnt TYPE_2
These Ts dont occur anywhere method signature
Can remove hashcode check since conflicts possible
The _CODE_ getter missing isnt
When _CODE_ autogenerates fill correct parameter names attach source library
I believe VAR_1 get future dessubmitVAR_1get
Why rather VAR_15 empty VAR_12 returning _CODE_
ivandalbosco need parameter
No system outs tests please yes might around leftovers
Is check required At point length greater 0 return null length 0 line 62 _CODE_
Can assert context null
Lets move line first METHOD_3 line
You dont need explicitly declare TYPE_5 _CODE_
Could use int VAR_4 index VAR_3 _CODE_ VAR_3setIdi
nit enclosing file needed
Your tests dont rely _CODE_ remove line rename method get rid _CODE_ entirely
Why manually dealing _CODE_ string manipulation nonperformance critical path We _CODE_ serializer use layouts use
Meh could use rsclose instead lambda Theyre semantically _CODE_ like way method handles look Not critical merge obviously
I dont think makes sense try recover exception log fail sensor ie skip analysis
cuenyad add final
move null check back first action change behaviour
Missing negation
Does Listener mean process one event time qpid Ie cant get another event _CODE_ stores Hrm maybe registers slow
final parameters
Move please
VAR_3 null next method right
Having public feels problematic What classes need call dont live iorealm
Not sure I follow Arent fatal errors always thrown topic errors
I think static method construction might still fit better
whats difference blobs records use 2 terms
I think field declared final
write return VAR_1 null VAR_1getStageId null spare lines
If VAR_1 null _CODE_ point VAR_3 happen type allows null keys dont
Do need else block
Couldnt always use _CODE_ _CODE_ That would spare us one instanceof
Use parameter names make sense part decompiled sources msgmessage something
I tend avoid trigraphs unless theyre absolutely necessary thats However please around condition code correct know nonobvious parts precedence chart 13 vs 14 _CODE_
On phone cant expand file see duping next line commet instead fine
I would recommend else avoid comparing string unnecessarily
The null source looks odd
needs negated
Build fails ScheduledReporterjava7221 call must first statement constructor fix java thisregistry name VAR_5 VAR_7 VAR_8 _CODE_ _CODE_ FACTORY_IDincrementAndGet
exact conversion Exact one _CODE_ VAR_1 _CODE_ But need null guard What cand caller tries add null VAR_1editorauthor
Could update method signature please Asking consistency java final double VAR_1
Our standard convention prefix instance members return thiscontext
remove
The constructor accept VAR_4 begin
This protected public okulikov go changes change access modifiers modified methods limited possible
There need resolve paths every iteration need resolved Moreover resolve one level passing resolved parse transforms method
I dont think need since could get direct access _CODE_ delegate producers
pls simplify return GeneratedMessageV3classisAssignableFromclazz
I dont like need better way handle optional imports general one could always others libs
minor would prefer Cloud_Replica_Keyword comes mount path since would order path least granular
This moved outside try block
start 15 length 4 remove Closed
What _CODE_ used
filedelete called outside try block otherwise TYPE_3 associated wont release lock
suggestion else Since _CODE_ statement moved remove VAR_7 null condition update else else statement When VAR_7 used METHOD_7 method VAR_7 null check made
Why need use METHOD_3 one parameter exists
Any particular reason check String I guess work seems optimization Maybe Im missing something Im concerned use cases type converted something else What truefalse stored boolean Will work
Can VAR_1 new TYPE_1 go VAR_2 checks
I dont think want propagate exception thread We want return throwable It wasnt thread error
synchronized safely removed method since stateless suggestion public static TYPE_1 _CODE_ VAR_1 String VAR_2 String VAR_3
Id like consider _CODE_ case It doesnt need return anything
Should ignore instead throwing exception
Rather roundtripping parsed VAR_2 could introduce transient final instance variable VAR_3 would set constructor used _CODE_
nit remove final usually params
This breaks compatibility
Same _CODE_ zero probably shouldnt disable indictment For clarity If _CODE_ zero entire VAR_1 execution rest _CODE_
In branch I VAR_1 final class I planning merge I dont understand setting location manager null reason cascheberg I apologize slow reviews crankycoder I havent available much week Stumbler need update fix also need figure certain users reporting stumbler pausing starting
Line long
Add instanceof check
package private
nit merge two lines
You use _CODE_ want though less explicit I dont mind
dmzaytsev All variables still singleuse variables inline everything ie make whole test single statement
Im probably missing something using constructor taking Throwable
Have checked _CODE_ could sufficient base class It would avoid conversion
suggestion return _CODE_ METHOD_1
Please use clear parameter names like VAR_6 instead VAR_5
Typo spaces missing
suggestion _CODE_ new _CODE_ String
mswiderski logic correct Should disable _CODE_ used project
No need fully qualified class
TYPE_3 TYPE_4 removed
This looks like could produce _CODE_ METHOD_3 VAR_2 null We probably want add check suggestion VAR_2 null return null return TRACE_ID_PATTERNMETHOD_3VAR_2matches VAR_2 null
doesnt look correct Youre _CODE_ exception _CODE_ Youre ignoring subclasses whats frequently used
Should TYPE_3 super TYPE_2 VAR_3 allow call constructor diamond operator _CODE_
private static
add _CODE_ remove protected modifier
Maybe move null check VAR_1 level protect also access METHOD_2 wdyt
private
Maybe add underlying exception new _CODE_
public
METHOD_1
This doesnt seem right _CODE_ may exist
omitted
The username password VAR_2 initialized empty string Will ever null A better check might _CODE_
Why need line I think removed
I overlooked case lets maintain static constructor without renaming since public
Its good practice override parameter create local variable default VAR_5 null
METHOD_2 needed given METHOD_1 checks nullability
If VAR_3 null output null _CODE_ automatically unless use _CODE_ annotation
sure makes sense instead putting _CODE_ values I probably would use Enums name method _CODE_ usually overridden
Can make 00 instead 0
Instead inspecting repeatedly whether lookup source empty could leverage fact information doesnt change ever So instead change instead introducing METHOD_2 method inspect _CODE_ _CODE_ set finishing flag _CODE_ empty
Why inject
_CODE_
Inline VAR_2 return _CODE_
No need add stuff already covered _CODE_
Maybe remove package name already import statements
What happens VAR_1 brooklyn Is sensible behaviour Canshould add else block assertion
eviltak mentioned removing need class parameter checking type default value Can please
static
Do really want _CODE_ generate id null passed That hide programming errors If really want better overload constructor version without id parameter
please keep code else block since VAR_2 format _CODE_ right
add VAR_7 thVAR_7 causVAR_7 hVAR_7rVAR_7 tricklVAR_7s propVAR_7rly
Sure shouldnt thread visible This way notification disappear thread visible reason
Remove _CODE_ annotations leave _CODE_s Also remove METHOD_4
A tryfinally would better
missing newline
logging may spammy log
avoid conversion sending uppercase constants response directly
If trim mark doesnt change still iterate VAR_5
This debug output deleted
Im really fan METHOD_5 general android advice use last resort see handling _CODE_
Would also remove VAR_4 parameter Same also _CODE_
thisid id
Could given constructor
Im fairly certain could replace method references eg mapthisconvert
Again inline VAR_2
Can private
Are necessarily new names
I would prefer assume fix necessary VAR_2 cannot null empty anyway way code would look easier final _CODE_ TYPE_2 new TYPE_3 TYPE_2adddefaultExtension TYPE_2addAllArraysasListVAR_2 return CollectionsunmodifiableListTYPE_2 Also _CODE_ using _CODE_ nullchecking instance becomes unnecessary produce bit overhead I prefer using conditional sentence instead null whatever
manstis Any obscure reason make change Seems like slower iterator List
Avoid logic class This inconsistent collection fields You cant update field set null Also tree set
I think still could overflow since coerced long end You cast one arguments long ensure long multiplication performed
Do need check VAR_6 null
_CODE_ already called line 117 really belong method called METHOD_1 really static
_CODE_ empty default mention
Lets use constructor without _CODE_ align modules
nit maybe use finally restore value
_CODE_
Caution array parameter could null
one could empty I guess
Change commit title say Fix potential overflow Bing tile functions Also better readability add parenthesis around long VAR_3
Maybe inline variable
Please use variable arguments version _CODE_ instead Stringformat
I think simple setter need Weld provides set already immutable
Set VAR_5 _CODE_ dont everywhere
The usage friendly passing value strategy client Consider simplification use
dont need assert VAR_1 part Alluxio logic
Same issue variable names
try rewrite VAR_3 new TYPE_2 without space constructor
_CODE_ VAR_3 VAR_4 VAR_5 false
Should METHOD_1 method TYPE_5 like _CODE_
VAR_1 used method
Could change METHOD_2 try keep symmetry enterexit logging
final
final
concurrency needed
could ifthenelse without increment case
Similarly static enum thing I subjectively like make enum constructors explicitly private even though theres practical difference Any particular rationale change
Replace _CODE_ You statically imported
Is still necessary And saving VAR_2 general
Seems like dont need VAR_3
Btw removing init means _CODE_ map wont initialized empty map calling _CODE_ right constructor seems like generate _CODE_ unless Im missing something another quick look
Should throw exception instead TYPE_3 null
undo
Since added checked exception TYPE_2 method signature dont need catch rethrow
remove
This call METHOD_1 method takes string pass _CODE_ string See _CODE_
This method seems unused
nitpick _CODE_ VAR_2 null
suggestion _CODE_
explicitly check METHOD_9 add last else block error handling
ie java _CODE_
Make final since know many VAR_1 dealing make sure creating list right capacity
Formatting
METHOD_2 shouldnt ever return null Based Python _CODE_ functions return VAR_2 object every time In case fact empty factors minimum_requirements return VAR_2 minimum_factors set false 0
Wouldnt clearer condition n INT_1 INT_2
Whaat
Refactor 1 line
Such check must top method
I know generated code however please include curly braces ifs Without code could misinterpreted easily
I would suggest _CODE_ make secret answer validation case insensitive
Yes _CODE_ express behavior ina better way _CODE_
Please move check assigning variables
Simpler TYPE_1 params VAR_1 VAR_2
need public functions
_CODE_ I like output
private
I think would make sense call constructor eliminate duplicate assignments maintained thishost VAR_3 OptionalofDEFAULT_SCHEME Optionalabsent
Hardcoded What add another format future
No need force byte order wrapping byte
Typo METHOD_2
suggestion public void _CODE_ VAR_2 int VAR_3
Da keine Exeption weiter nach aussen geworfen wird von METHOD_1 kannst du das throws TYPE_1 hier einsparen
creating set might always necessary collection enough cases use METHOD_1
May need space
Definitely nit introduce local variable
While working file could put braces around return Its necessary good idea
I think indentation wrong Seems like youre using 2 spaces
_CODE_ protects _CODE_ making methods synchronized This class expose _CODE_ concurrency prepared handle
Can simplified java return VAR_1 null IterablescontainsVAR_1s VAR_1
need propertystore config I would think code would use _CODE_
METHOD_4 present
I think need synchronized double check
original signature still kept deprecated dont want break scripts unknown integrations avoid
It would clearer subtype method signature
You need TYPE_2YPE_3 super TYPE_2
This VAR_1 check could removed already move 26x
I think changes behavior Before empty filter would always return true returns false
set final
UTF8
We need keep original METHOD_1 method add new one
static imort
Will good exclude format change _CODE_
Yeah I thought Im satisfied better error message
return _CODE_ AuthenticationConstantsBrokerBROKER_PROTOCOL_VERSIONequalsIgnoreCasebrokerVersion Closed
Why called METHOD_1 add
_CODE_
The method could reused passing default VAR_2 avoiding code dup
Can use equals instead _CODE_
Could inline first call _CODE_
I think would better exercise testers consumer point Something like suggestion _CODE_ _CODE_ Jwtbuilderheaderalg _CODE_ user _CODE_Consumeraccept_CODE_ return new JwtMutator_CODE_ This clearly separates concerns creating Jwt creating _CODE_
This removed add handler via _CODE_
Again return value null
Close needed use trywithresource Whats wring _CODE_ method I feel name clearer
private
VAR_1 internal component jmxtrans ensure never called VAR_3 null So I would prefer boolean primitive TYPE_1 object
yuck
Interesting approach I guess Id tried use qualifiers _CODE_ alternative mechanism seems simplest
_CODE_
Codacy reported warning explicitly provide visibility I disabled codacy hopefully reporting anymore
Não deveria ser null aqui
save overhead declaring VAR_4 field reusing VAR_4 tracingpropagationVAR_4VAR_4
Correct wrong I think first block _CODE_ needed anymore
Use simple setter notice _CODE_ doesnt side effect either _CODE_ set default value similar sets 400 Late Acceptance
I would still throw VAR_3
_setup_
Should final
I would first start method _CODE_ VAR_2 return false operation requires knowing one method variable
This completely different change please dont mix changes pull request
Yes youre right
Move default
Thanks _CODE_ I noticed two VAR_3 messages completely redundant remove one combine single VAR_3
You probably shouldnt return anymore
This much synchronization makes parallel VAR_1 loading impossible
Can null You assume places
static
Should safe make VAR_2 unVAR_2 private allow rest scheduler interact via _CODE_
simply return VAR_1 null VAR_2 null If use _CODE_ automatically suggests refactors
return new Jobname
Q Why consider stateful tasks METHOD_3
minor need else returns
short
Why TYPE_1 used Its absolutely redundant
Is necessary When would multiple threads _CODE_ object instance
change required _CODE_
Since size 0 really precondition METHOD_4 run successfully seems like check instead policies require vs implicit undocumented precondition checked existing calls incase new entry point ever created
Since set probably dont need test
You make single check VAR_1 METHOD_2 since interested single outcome
Change seems unneeded And actually unchecked removed well
Also _CODE_
benzonico falsenegative
true simpler
Add final keyword Also places necessary
need new VAR_3
right way builder separated class new _CODE_
No need define throws VAR_4 function It extends _CODE_ public _CODE_ _CODE_ VAR_3
I dont think need _CODE_ since property default value localhost9091
vilchikelena It looks like VAR_4 actually _CODE_ Suggestion invert meaning Boolean true problem false problem
I think return VAR_1 property wihtout extra logic
Use VAR_2 avoid unchecked warning
wondering also warm VAR_2 cache miss l1 cache hit l2 cache
shouldnt return boolean return error stop VAR_1 failed
Cast string removed
double r Priorrity
incorrect VAR_1 command
I would use double check algorithm x null sync x null I would also use _CODE_
really care
This obviously syntax error
could VAR_3 null check avoid substring operation
There semantics change Previously _CODE_ wrapping _CODE_ would see stats return stats _CODE_ VAR_1 String VAR_2 _CODE_ VAR_3 _CODE_ VAR_4 Now see cant calc proceed VAR_3ToQuerybuildforEachpartionName _CODE_ _CODE_ code path Is change deliberate Does matter I think doesnt doublechecking
suggestion return _CODE_ null
still didnt apply hint methods use try catch
String object String comparison please use languageequalsja
Nit I dont think null
This would clearer switch statement default clause
Same issue variable names
comment
This method seems checking baseline differential doesnt match method name
All methods class synchronized Otherwise change looks good
For _CODE_ modules throw exception _CODE_SuiteChecksTestbeforeSuite instead calling Systemexit
I think dialog would look nicer title Our logo would nice much work
Add curly braces
feels bit confusing I want get task count single VAR_1 I would use int I via TYPE_1 I would use String Since data returns VAR_1 value String fetching based well
nan
Can precompute value instead The tokens immutable set constructor
listener may null issue tested music playback
_CODE_ weird name maybe inline two variables Or use _CODE_
What happened Why revert individual checks instead checking map In case reverse handling _CODE_ block The current true case least likely happen
Hier bedoel je dan denk ik thischarset null
A leftover
Why leave changes method This method looks like changed methods
Please dont store look every time needed We dont want store servicederived information longrunning components
rm final public
I dont understand change Would explain
call supertext applies constructor matchers also empty one
Arrayssort допускает null в качестве компаратора
VAR_1 enough
Could method call check done inside _CODE_
Please recheck condition successtrue logfailed block seems wrong
A copying method shouldnt called METHOD_1 perhaps _CODE_
called resource
At point code I would expect VAR_1 value I think may worth adding sanity check Could something like following java private void _CODE_ VAR_1 ObjectsrequireNonNullVAR_1 rowLockscomputeVAR_1rowSeq key value _CODE_ VAR_1 _CODE_countintValue 0 final int VAR_5 _CODE_ return VAR_5 0 value null
Init called one single time constructing VAR_2 That done _CODE_ Please add space
A _CODE_ added check changelog correctly loaded
suggestion Please dont add tables used Wastes _CODE_ cycles
yeah lets remove
I would put line previous instruction make sure xtree found _CODE_
The trycatch block redundant since appropriate exceptions caught logged METHOD_2 method
use VAR_9 object construct VAR_10 file new VAR_9 VAR_2 VAR_8 etx
Not critical I find counter intuitive lookup method also clear move end start method
Still calling METHOD_2 port
Just browsing web interface moment I dont see VAR_3 used test
Seria bom reutilizar método paginate _CODE_
Just consistency could please use final _CODE_ VAR_1
lets use _CODE_ managed executerservice lookup via _CODE_ create one managed one available
You dont need _CODE_ _CODE_ anymore call loginuser VAR_3
check actually end path Cant cause issues Cant middle path
If override equals override _CODE_ well
Dont need _CODE_ call
This doesnt belong _CODE_ fixed elsewhere
Since checking interrupts already could remove _CODE_ flushboolean VAR_2 method
suggestion private static String _CODE_ VAR_1
From point async store necessary function serializable resulting entry So check belong The holds compute commands
clean message
case given I mean entry given VAR_1 registrations
How VAR_4 null VAR_4validate VAR_2 VAR_3
Since Dates mutable copy VAR_2 passed _responseBuilderstartOfNextDay avoid downstream side effects
private
Would actually kick interfaces I dont think need keep two cases apart interfaces form abstract type In error message could say result type may abstract class interface
throws TYPE_2 needed
We move naming threads common configuration well It easier debugging point view production support easily make sense well
I think better avoid extra lookup map _CODE_ VAR_6 new _CODE_
nit make _CODE_ Supplier called trace logging enabled suggestion loggertrace _CODE_ _CODE_ _CODE_ bulk request actions VAR_5 _CODE_
Can call _CODE_ null returns true
remove public
redundant parentheses
These VAR_3 VAR_3Size needed info already set query context
maybe add method METHOD_2 VAR_4 seconds wrap _CODE_
_CODE_ order public final boolean consistency methods
This constructor nothing
The token persisted new code doesnt use epoch I suggest drop TYPE_5 usage instead transforming
Why pass
Same Dont take TYPE_2 parameter listener
Braces
Is metric name going match timeseries name
I think may forgotten delete line
This interesting way handling Im quite sure feel yet lets leave see establishes pattern general output processing Java rules output If keep otherwise I would argue probably expensive way null check
Since VAR_2 _CODE_ redundant Set doesnt allow duplicates
Seems assertions never reached due expected exception
maybe get class listener
Missing _CODE_
Do really care null simply METHOD_3 skip METHOD_4 null
nit remove
Again METHOD_2
Why need count Cant use _CODE_
This variable never used Maybe line removed
_CODE_ new _CODE_ insure immutability
Doesnt need final
Regarding question put METHOD_1 field map call method
No space _CODE_ _CODE_
return VAR_1 name null 0 _CODE_
This And VAR_2s need type well The reason could _CODE_ VAR_2 like _CODE_ VAR_2 VAR_2 want METHOD_6 something different For regex VAR_2s omit pattern equals METHOD_6 compiled versions VAR_2 field Its ok use parsed version even someone puts space front back
Does line Seems like may well right Or could check returned list empty Or
Could optimize perform _CODE_ twice
Use VAR_2 object instead retrieving
So first set thisVAR_1 non null value set null I guess wanted something like VAR_1 null VAR_1 new TYPE_3 thisVAR_1 VAR_1
Avoid logic class
Hm formatting seems line Do want keep debug output
common place broker level add unioning query VAR_1
This synchronized
Nit need parens around lambda parameter Also I think replaced _CODE_
Superfluous empty line
Minor also method _CODE_ exposes inner set I think purpose mimic use _CODE_ static method allow ranges objects arent Comparable back _CODE_ method Guava range requires Comparable type Im fine changing use method everywhere since straightforward But Id like either use _CODE_ _CODE_
This empty implementation override _CODE_ According doc seems deprecated Activity replaced _CODE_ make different
Make VAR_2 method private shouldnt visible users Make another copy class call _CODE_ make sure use _CODE_ builders make sure user instantiate properly pass object VAR_1 _CODE_ _CODE_ member
This line following ones replaced single line java return VAR_5 null new SearchResultVAR_5 null
The operator
Oops
Nitpick Its generally safer include curly brackets _all_ statements It help protect future developer accidentally introducing bug another line added statement Alternatively succinct way writing method would return VAR_1 null _CODE_ _CODE_ VAR_1
logic behind sure non instance VAR_3 replace VAR_3
Id prefer condition check _CODE_ thats big deal
Add clarifying parenthesis Its easy forget precedence rules make code easier reason
Lets drop final changing
Rubbish
I cant see wouldnt break Please add retest
ternary operator
replace _CODE_ _CODE_ static import readability
kind concurrent access trying sync In case trying prevent multiple invocations VAR_2 concurrentif yes seems _CODE_ scenario If trying sync addremove writing scenarios iterator protected concurrent modifcation shouldnt use synchronize scenarios well Is becuase subsequent invocation _CODE_ yes _CODE_ seems already synced concurrent Map
Since open VAR_2 I guess responsibility METHOD_1
nit java _CODE_ _CODE_
looks variable VAR_4 used
You drop _CODE_ check And also methods file please
suggestion boolean VAR_5 _CODE_
You return directly
It looks like VAR_9 broadcast action receive several lines broadcast different action Can collapse process broadcast different action
Close VAR_4
Cant VAR_1 initialized VAR_2 default I see logic thisVAR_1 null though dont return null appropriate Nullable method instead I think way would consistency current logic possible METHOD_1 inheritors
а есть пример как это используется
According I think need call _CODE_ returning prevent memory leak dispose deprecated using METHOD_6
Run command line goal mvn install Psourcecheck camelflink directory fix checkstyle issues reports
Im curious call needed added since TYPE_1 private volatile boolean VAR_3 true
Rename param VAR_2 unless theres good reason
add fail following line
suggestion return METHOD_1
As mentioned listener required
No check needed since throw _CODE_
Why cant return value
Should forloop canceltrue lines inside try block _CODE_ move try line 234 forloop That change would really change individual VAR_3s cancelled would guarantee thiscompositefreeze always called As discussed yesterday really attempting prevent nonreturning wait pathological case _CODE_ something relatively catastrophic After current VAR_3cancel VAR_3freeze calls pretty lowrisk VAR_3 references never null But even though theres little chance something could go wrong within method doesnt hurt make sure
Why pubic method Why make whole class private static
timler When I looking use method code I noticed VAR_1 param isnt used
This doesnt appear callers Remove
instead super
I think remove check
The beauty builder pattern avoid massive change adding new field I suggest make VAR_4 optional We give VAR_4 default value set VAR_4 default value public _CODE_ id String name TYPE_1 status String VAR_2 short VAR_3 thisid id thisname name thisstatus status thisVAR_2 VAR_2 thisVAR_3 VAR_3 public VAR_1 VAR_4long val thisVAR_4 val return
Its cleaner let caller separate VAR_1 path checks since logically distinct
unused variable
Always use equals comparing Strings Java
The TYPE_1 fullfills purposes Driver listing _CODE_ Wouldnt make sense hide file based drivers _CODE_
Is possible bearer token empty
The superclass repeats METHOD_2 call I dont think _CODE_ adds value
_CODE_ scopename name
Move VAR_6
Initial size _CODE_ rather _CODE_ And could create copy return _CODE_
always use parentheses also oneline statements
Unnecessary use _CODE_
Will always start file directly return true
repeated
No need intermediate variable assign thisdata calling data try catch branches needed
Unlike peruncore possibility provide null _CODE_ since always retrieve group provided _CODE_ Please make _CODE_ param optional check presence allow moving groups toplevel
dont use final inline VAR_5 VAR_4 _CODE_ sum
But attribute actually required So wed reporting incorrect metadata work around test fixture problem
public constructor nonpublic class
What
Instead passing count could pass max time I think passing time assumes less implementation Could something like following java public static _CODE_ _CODE_ context long _CODE_ _CODE_ retry_CODE_
Is typical case I would thought chunks arent null Id suggest flipping ifelse block
could package private
We update index point current iteration loop This way always convert first incident suggestion _CODE_ _CODE_
VAR_2 initialized constructor could also initialize VAR_1 way
I think alternatively move construction service test cases factory method sets METHOD_2 function object field call METHOD_1 This may prevent unwanted potential sideeffects With approach construct two services METHOD_2 one For example service submits scheduled task I think fine would safer function proposed
Would add Nullable constructor parameter VAR_8 _CODE_
Just noticed minor referencing another test _CODE_
Only one getter Would prefer see members private packageprotected getters members
What think adding METHOD_1 TYPE_1 iterate list call method object instead checking type first
Hi jsoltes use _CODE_ method
Why METHOD_2 call required orgjbossideeclipseasmanagementas71 declared dependency test plugin
Its sort weird getter int setter boolean Can make everything int including underlying variable Also consider making error count instead 10 since would provide additional information
The _CODE_ files import _CODE_ customers specify address payee Those _CODE_ imports use address record payee within _CODE_ _CODE_ I feel need continue follow model _CODE_ send addresses _CODE_ import files We need determine get data correctly populated normalexisting _CODE_ processing based payee specified
Same one
_CODE_
这个里面的host把
Add null check getbody
Except Safari users others get _CODE_ issue
amihaiemil length
You use constructor TYPE_5 takes token argument The one youre using tapped set true
A test case null users would useful
Leave TYPE_3 pass add method signature Convert TYPE_4 TYPE_5 TYPE_3
Correct keyword order
The _CODE_ actually recursive recursive part
Do need local variable VAR_4 anywhere Otherwise call METHOD_6 without assigning anything
Unused
Do really need test 1 entry
Question wouldnt simple assignment sufficient _CODE_ VAR_2 Do really need clone TYPE_1 If constructor TYPE_1 accepts another TYPE_1 may redundant The question goes thisVAR_3 thisVAR_4 method actually aggregating VAR_3 VAR_4 METHOD_1 one time assignment
else start 10 length 4 else needed
I dont see class needs publically accessable setters instead final fields set constructor
Can remove VAR_1 parameter method config read twice
METHOD_6 statically imported
use TYPE_1 VAR_1 TYPE_1 METHOD_1 sense VAR_1 instanceof TYPE_1
Can constructor call 5 parameter one instead assigning values
Maybe could let false parameter avoid initial call new method METHOD_1
Is idiomatic In fact expect wont true interrupted _CODE_ returns Would clearer omit _CODE_
This check dropped
Change TYPE_2 TYPE_1 class usage go TYPE_2 pull request
We dont want VAR_2 inside try see _CODE_ The reason VAR_2VAR_2 fact throw _CODE_ unVAR_2 could cause unexpected results since reentrant could unVAR_2 one level intended example
minor reason use METHOD_3 int comparison
Im unconditional logs tests Would mind removing next polishing Thanks
Shouldnt TYPE_1 class contain suitable constructor initialize _CODE_ attribute public TYPE_1boolean b this_CODE_ b
I dont think check needed METHOD_3 implemented value null without check next line throw _CODE_ anyway Assert check needed without assertion check exception doesnt happen Same longdouble
_CODE_ I think prefer use reference variables
I know want METHOD_9 null passed METHOD_11 method I believe make check strict We could also check exception passed method thrown deployment MockitoMETHOD_9METHOD_11er Mockitotimes1METHOD_11TestExceptionDeployThrowershouldThrow least type exception TYPE_2 MockitoMETHOD_9METHOD_11er Mockitotimes1METHOD_11MockitoisATYPE_2class
A primitive int never null could remove check
rather use datalength
I see method body already synchronised Can instead remove outer VAR_1 null Because see duplicated inner block
Must Also _CODE_ advices
_CODE_ _CODE_
Why return TYPE_1
optional use bufferappendmsgappendkeyappend
use VAR_2 parameter instead true think
redundant invoke _CODE_ statement
If test passes assertion isnt quite right _CODE_ doesnt define _CODE_ The assertions needs written remove withUserConfiguration_CODE_class test fail
Dont need format message unless VAR_1 null
nan
Same remove public modifier null checks
VAR_2 cant null simpler
I think would cleaner easier follow start method executor started cause obvious Discovery Service starts constructor
nit _CODE_ _CODE_
This else needed previous branches return
Sorry I missed case If METHOD_1 null increment VAR_2
I think return TYPE_1 extends TYPE_2
Is really needed
It might borderline overkill Im considering could avoid copy logic like following _CODE_ return VAR_2 else return VAR_3 Basically relying group VAR_3 superset local VAR_3 defined
decide throwing vs silently ignoring _CODE_
worth moving stuff _CODE_
redundant parentheses
Id change initialize date directly unless another reason perhaps suggestion TYPE_1 date TYPE_1parsestring VAR_1
Is possible fix ident Json string
It seems passing null object make sense Change primitive boolean enforce simplify body method I see followed approach method currently accepts boolean Mind fixing one
Shouldnt pass something like size list METHOD_2 assumes going add 1 item I mean something like METHOD_2taskssize
Id reduce simple _CODE_ null That way hard dependency pulse
This also
dear lkukielka changing method signature part ticket would break compatibility users method please revert change
Intellij tells public necessary
Useless statement
Needs go first _CODE_ _CODE_ true
pass cause exception
Why synchronized empty method
gettersetters plain tricks Instead creating endpoint component set security provider endpoint correctly
return METHOD_2 null dtscontainsMETHOD_2 dcacontainsMETHOD_2
VAR_3 method argument passed METHOD_3 argument
Can add failure assertions items go range positive negative directions
We set servlet path test pass
This correct place enable plugin config You enable plugin creation directly config
rm METHOD_4
add final
dVAR_2ing cast directly wVAR_2uld result wVAR_2uld bit faster VAR_3 VAR_5 VAR_3 VAR_2
This public Id suggest protected Plus remove nothelpful _CODE_
We probably VAR_5 fVAR_5ally block
When throws exception file writer may get closed consider try resources
Getter wrong
Now standalone function You return _CODE_ remove temporary variable
_CODE_ Make METHOD_1 static method rule
This return _CODE_ ImageStrip0
This isnt directly related issue fix Could address one separate _CODE_ Its better versioning changelog etc Thanks
Can put _CODE_ beginning method This makes easier read
I think _CODE_ could please
I dont see called anywhere patch Is reason make public
I dont think escape level explicitly escape title video passing method Lets move _CODE_ _CODE_ _CODE_
This bug _CODE_ already returns serialized form size
I dont understand check METHOD_6 already taking check checking rights
And METHOD_4 METHOD_3 static thMETHOD_3 one static well
The value VAR_3 may set single line Moreover real need VAR_3variable ìsCheckedmay used directly parameter pass _CODE_
yVAR_1u pVAR_1ssibly add VAR_1 return true
Here two possibilities 1 The icons arent loaded memory 2 The icons loaded memory None involve checking app comes background It seems _CODE_ VAR_5 _CODE_ already checks icons loaded Maybe change function name _CODE_ check boolean remove background checks
sounds fine
Its probably cleaner default noop configurers assert null setters
Could interesting follow kind signature METHOD_1 signature
このメソッドをsynchronizedにするかsynchronizedブロックでThread safeにした方がよさそうです
droneboost wasnt I meant A _CODE_ recycles views visible avoids creating new views user scrolling updown list It recycling TYPE_1 view parameter getTYPE_1int index TYPE_1 view TYPE_1Group args method If theres view recycle parameter null otherwise parameter non null reuse A typical example follow public TYPE_1 getTYPE_1int index TYPE_1 view TYPE_1Group args view null view TYPE_1inflate else view parameter non null reuse directly without inflation initTYPE_1Itemview return view With class field youre overwriting view successive data entries listview look identical
No need
Shouldnt close TYPE_3 METHOD_3 We could also pass File directly TYPE_5
A variable created class _CODE_ good choice theres almost similar global variable
cast necessary I thought metrics always longs
k k suggestion return _CODE_ k new TYPE_1
You return inverse conditional return VAR_1 _CODE_
suggestion This looks like code leftover removed
VAR_9 null I think return ie keep property lost
Does duplicate existing check
return true instead
Either log rethrow exception See
suggestion protected _CODE_ TYPE_1 VAR_1
seems odd return null even explicitly set _CODE_
So mean pumpkins easily duplicated
A little curious compile errors sneaking commits
It seems check necessary covered _CODE_ logic
VAR_4 INT_1 INT_2 This seem intuitive Why divide INT_2
catch TYPE_2 rethrow avoid wrapping TYPE_2 TYPE_2
matthewadunlap please update docs _CODE_ Thanks
Again Id default false I think nothing makes sense false
A question Omitting _CODE_ check intended Overrided default method check null check done
Formatting
assertEquals0 permissionslength
instead adding class cant add prepare method _CODE_ return resource
This probably go _CODE_ Also receive DISCONNECT_ACTION probably always METHOD_5 The user doesnt want continue interacting app theyre closing everything right
Add name
replace return TYPE_3 _CODE_ null
Should condition VAR_12
I updated
_CODE_ doesnt matter
Why check null
Since package private class know constructor ever invoked _CODE_ _CODE_ assertion add much value Furthermore _CODE_ never invoke constructor null empty set VAR_2 If something invoke constructor null would violation packagelevel _CODE_ declaration supplying empty set would result registration _CODE_ effectively noop In light please revert changes _CODE_
This shouldnt necessary error caught exception catch block
I doubletake extra line could help readers java VAR_1 null return VAR_1 VAR_2 null return null return VAR_2maybeError
Dont need 1 end
That going problem There clients change behavior VAR_3 null
Please add final
Remove public modifier It bestpractice Guice make injection constructors visible default scope
This bitwise _CODE_ shouldnt boolean _CODE_
Cast redundant TYPE_1 expecting TYPE_3 object
How data null data instanceof TYPE_3 return false
No need covert list list
_CODE_ meant immutable Please call instead _CODE_ _CODE_ _CODE_ new _CODE_BuilderrpslObjectremoveAttributeTypeAttributeTypeCHANGEDget
Missing raw type
Все ifforwhile должны быть с
_CODE_ would great brackets new code
To clarify doVAR_4s catch thVAR_4 TYPE_5 thrown _CODE_ Do wan includVAR_4 thVAR_4 thrown VAR_4 thVAR_4 nVAR_4w TYPE_5 crVAR_4atVAR_4d hVAR_4rVAR_4
I guessing code actually set memory limit physical operator instance minor fragment done subsequent _CODE_ Right set using old logic _CODE_
could make 1st argument final since readonly
I think could check VAR_3 METHOD_2 instance TYPE_4
Quick note dont want modify existing constructor signatures classes Base module project generally classes intended use outside project itd break projects Adding proxy constructors one way around
u add var onlu use inside u _CODE_ line 515 instead line instead 515516
suggestion _CODE_ VAR_2
Whats check needed
could merged expression previous one
use VAR_3 instead eureka
I think need use streams
see parameter needed
Does mean METHOD_5 impacts result matter METHOD_3
Should private
Again Id avoid assertions middle tests
Isnt simply java _CODE_
Here I would say return true Then fall return false instead creating variable
final
course Thats I said revert changes VAR_8 _CODE_ becoming clear
You also remove trycatch TYPE_1
As Tabassum mentioned _CODE_ removed schema removed
If change METHOD_4 return TYPE_5 remove cast make mapthisMETHOD_4
enclose
delete second line add assert _CODE_ thing one _CODE_ _CODE_ So interpreting correct value first check cloned one
This switch avoided passing description directly constructor ie _CODE__CODE__TIME_SERIES_STRATEGY_NAME _CODE_ _CODE_Tool _CODE_
Should sufficient synchronize VAR_4 right Same applies _CODE_ method
Can shuffle logic method around bit I think clear code How java public String _CODE_ VAR_1 String VAR_2 METHOD_2 Always return launch activity specified METHOD_3 null return VAR_2 App version specified Get latest version apps store VAR_2contains return getDefaultVersionVAR_1 VAR_2 return VAR_1containsVAR_2 VAR_2 null
Probably best set base test class make sure gets cleaned end test
Duplicate VAR_3
Please see
remove VAR_2 need capture screenshot sending keys
needed
required
I agree codacy odd method others name field Is reason name _CODE_ etc
There need using synchronized stop method
obvious thx
Take care inheritance order important noted google auto warnings Make sure test cover proper object construction dont break accidentally changing implemented interface
Could use _CODE_
If want try use boolean VAR_6 It work
Personally I read better _CODE_ VAR_4
Im less clear one since closure server side handled framework error may may indicate response failed Ideally interceptor location possibility exception grpcjava bug
bulb Slight simplificatiVAR_2n java VAR_6 f new VAR_6lVAR_2cale try _CODE_ VAR_2 return ftVAR_2String finally fclVAR_2se
What purpose no_op listener called detached
It seems made static
Такая конструкция избыточна там помоему можно просто писать msgid tagid работает varargs auto boxing
Ditch debugging
Nitpick Id prefer _CODE_ since array bounds array modified
condition needed
Shouldnt constants constructor configurable
change VAR_3
TYPE_4 generic
I added method without _CODE_ necessary But merged Is better pass null create empty String
I love readability improvement We might actually able improve even _CODE_ VAR_13 method _CODE_ method delegates state type holds In fact make change _CODE_Type enum need public VAR_13 _CODE_ method since places use methods follows pattern _CODE_ invoking type method order invoke VAR_13 _CODE_ method result In fact _CODE_Type wouldnt need methods since _CODE_ access fields inner class directly
How METHOD_2 replicas local mean dummy list Only 2nd half predicate dummy list related
I see _CODE_ _CODE_ allocated using fragment context VAR_5 operator context order closeNotConsumed_CODE_s called matters
nit merge lines
null check enough removed items returned _CODE_
unused
If youre pulling VAR_3 variable use consistently throughout code Theres also need null check code would already thrown _CODE_ line 4483 VAR_2 null
Please first log error inform user
No need create empty array null may passed
Please add final
Move constructor We already defensive copy might well frontload work instead
Why using Constructor pass TYPE_3
nit never null Remove check
METHOD_1 declare exact class need wildcards everywhere
Im quite sure false positive _CODE_ methods invoked per class guaranteed _CODE_ I would moved variable assignments method directly declaration
VAR_2 cannot null
Since name method includes open I would remove first parameter instead always pass true repository method At moment one level
minor suggestions please check formatting need whitespaces I would also personally use _CODE_ instead explicit check false VAR_1 null _CODE_
No need case default UTF_8 already
Same else
public private
timeout close limit
else start 10 length 4 else required Resolved
This line moved Before method
spacVAR_2s catchfinal TYPE_2 VAR_2
Please change call private method METHOD_2 single entry point
could even check n start right Or use nequals start equalsimplementation TYPE_2 checks reference equality first
correct
This could return name null
This lambda also eliminated
suggestion return _CODE_
print VAR_2 time command server alone isnt valid
Make Guice constructors package private removing method modifier Just java Inject _CODE_ _CODE_ VAR_2
这个没有必要变更private属性
METHOD_1
_CODE_
Trivial could chained METHOD_4 calls
set latchawait returned true current impl I dont think would make difference since VAR_5 checked prior VAR_7 ifelse order could fragile assumption
Mapget return null key isnt found
This never seen
looks like memory leak remove
parameters shouldnt prefix way field access doesnt require thisscoping
We probably add try finally block return resource always even case _CODE_
Seems callers conditioned METHOD_3 already
nit static
Simplify java VAR_7 draftParameterequalsARGS_DRAFT_YES
Can contribute fix makes fail early null passed via constructor This would cleaner earlier feedback
Is threadsafe
missing
Oh dont need threadsafety VAR_1 hashcode methods guess This seems kind funny way prime cached values I think maybe suppliermemoize pattern would little cleaner make necessary
Since support typed property simply java _CODE_ VAR_4
You drop public since tests package
use throw Throwablespropagatee remove last throw statement
No need check value _CODE_ assigning _CODE_
Пробел после
This fine else clause redundant
The case VAR_1 null isnt used simplified
Can _CODE_ ever equal something another array thus instance TYPE_2 I would assume row always returns false
Remove line Doesnt make sense primitive value Whats happening primitive boolean autoboxed Boolean
may inline pagesLeft0
_CODE_ inside _CODE_ Can send json object VAR_8 directly
arent validations already handled parser
Static import Reflection2getInvokableParameters
It could due one recently fixed _CODE_ bugs test fails It gets 1 not_found result instead 0 Passing filter_notfound arg object map phase doesnt work _CODE_ phases either If I change size expectation results 1 _CODE_ run test passes _CODE_ test still fails error code Tests run 8 Failures 0 Errors 1 Skipped 0 Time elapsed 14653 sec _CODE_ zeroResultsEmptyCollectioncombashoriakclientitestITest_CODE__CODE_ Time elapsed 0007 sec _CODE_ _CODE_ _CODE_ combashoriakclientquery_CODE_execute_CODE_java82 combashoriakclientitestITest_CODE_zeroResultsEmptyCollectionITest_CODE_java205 sunreflectNativeMethodAccessorImplinvoke0Native Method sunreflectNativeMethodAccessorImplinvokeNativeMethodAccessorImpljava39 sunreflectDelegatingMethodAccessorImplinvokeDelegatingMethodAccessorImpljava25 javalangreflectMethodinvokeMethodjava597 orgjunitinternalrunnersTestMethodinvokeTestMethodjava59 orgjunitinternalrunnersMethodRoadierunTestMethodMethodRoadiejava98 orgjunitinternalrunnersMethodRoadie2runMethodRoadiejava79 orgjunitinternalrunnersMethodRoadierunBeforesThenTestThenAftersMethodRoadiejava87 orgjunitinternalrunnersMethodRoadierunTestMethodRoadiejava77 orgjunitinternalrunnersMethodRoadierunMethodRoadiejava42 orgjunitinternalrunnersJUnit4ClassRunnerinvokeTestMethodJUnit4ClassRunnerjava88 code
nit use _CODE_ similar using METHOD_2 instead MockitoMETHOD_2
Is possible reconfigure operation fast enough dont actually see state Does really make sense wait intermediate states
suggestion public void _CODE_ status
static
Not sure semantics exactly correct The _CODE_ version seeks forward n bytes This implementation seems seek forward within data buffer It seem Skips discards n bytes data input stream _CODE_
The src isnt needed anymore decide change selector
VAR_3 VAR_4 used could removed
nan
_CODE_ return null
else really needed _CODE_ return cleaner
No I mean take Loge near return null
This class member variable called VAR_2 incur data race METHOD_1 This easily fixable though making VAR_2 parameter METHOD_1 I realize debugonly code
I think METHOD_2 already insert entry map computing call might needed
change _CODE_ level
use return instead
skip criteria enforced VAR_3 eg _CODE_ The VAR_3 may respect maybe data may criteria determine doesnt want continue reading The VAR_3 also checks auto read seems like natural fit read pending check eg auto read enabled someone asked read
qualified
I suggest keep order consistent easier readingcomparison field declarations _CODE_ maybe settersgetters _CODE_ maybe default values lines 751758 _CODE_configure _CODE_ calls lines 2733 ConfigAsCodeTestshould_support_jcasc_from_yaml setter calls lines 4047 ConfigAsCodeTestshould_support_jcasc_to_yaml
Delete debugging
I would switch two conditions
No need return anything different _CODE_
We dont need change even decide want needs separate commit
Have _CODE_ return empty list null
The thing regarding passing exception new one thrown
The new flag VAR_3 passed used _CODE_
Since VAR_4 enum compare using directly
Why retrieve text currently focused VAR_1 What modal VAR_1 popup etc Then would broken Does New docker connection wizard change title opened If remove line 58 using text use constant
Looks like common Lecaught extracted bottom
VAR_2 Map within _CODE_ adding sessions equivalent persisting I think could also remove _CODE_ method completely doesnt anything special forwarding call _CODE_
ignore
comments
nan
Minor provide suffix prefix args Collectorsjoining avoid adding brackets
You may want since also trims string case input value leading trailing whitespace
Better use key constant
_CODE_ catches exceptions dont nee trycatch
Minor looks like VAR_3 parameter needed anymore VAR_2
Shouldnt loop release memory discarded arrays Eg _CODE_ null
use else ternary
This check pointless _CODE_ would thrown L120
This done TYPE_3 annotation If name specifies used user make sure collisions
METHOD_3 cannot null method VAR_1
mybe boolean _CODE_ instead The VAR_2 awfully specific
unneeded
Remove TYPE_4
This doesnt return null either
nit move null check previous line readability
These also public connectors extend base one wont package
VAR_1 used
Do need expose right Id prefer make private dont need expose
See
Please use braces oneline statements
I think method called _CODE_ even ill never use always create valued parameters _CODE_ sets TYPE_1 create use _CODE_ etc kind expensive Maybe simple lazy strategy Java _CODE_ null _CODE_
wondering w slf4j still need custom format I hopethink thats done slf4j logging library
Please use trywithresources statement instead handling manually
Nitpick _CODE_ complaining unnecessary VAR_4 variable
It obvious whether correct long x I would rewrite either long x x long
nit could simplified java TYPE_3 VAR_6 VAR_6 VAR_6spoll VAR_7 VAR_6 null VAR_6run
I dont think change file necessary Hence additional throws declaration TYPE_4 also unnecessary Would mind reverting file previous state wont noise Pull Request related file
I think method work like set You complement VAR_2
Missing generics TYPE_2
Remove voided creatable
Maybe take opportunity set index null
Please remove debug helper
This break tests code This guess I really try eclipse Tests probably compiled build executed
Would recommend method return output TYPE_1 makes easier use
Dont use final
Use _CODE_ class loader
What check _CODE_ And two METHOD_3 methods
Is specific reason get VAR_1 context classloader instead _CODE_
Should else _CODE_
I confused supposed
Seems odd mix calls METHOD_2 direct access VAR_2 method
Minor use _CODE_ _CODE_ static import readability
You could return _CODE_
This could extracted constant
guard null VAR_4
Redundant parentheses around VAR_3 null Also method also identical _CODE_ method I suggest reusing code
No feature requested far The current state division type root element It discussed might later add possibility types restricted In context one could also implement selection standard type
METHOD_2 return false input looks like _CODE_ address fails subsequent check eg 999999 In case subject two checks must fail code correct
The method _CODE_ could part class used
suggestion _CODE_ instanceof TYPE_3 instanceof already checks null
VAR_4 set twice constructor
I thought comparing strings right So would expect use equals
You forgot potential issue
suggestion return Collections2transformrecoveryLogs _CODE_
nit spaces commas
Consider removing magic numbers using source get right div want
这里有问题如果设置需要加锁那么获取就应该也有锁然后如果是单个 boolean完全可以考虑设计成原子变量加锁毕竟太重了
I probably mentioned _CODE_ VAR_4 I guess min durations 0 min durations set valid min values words set artificial limits user underlying _CODE_ allow smaller values Please double check update min durations necessary
This method seems pretty hot I wonder could optimistically combine VAR_1 VAR_2 METHOD_3 single method call go straight intread loop And rely METHOD_5 indicate throw away result try crosspage instead instead turn would figure actually really _CODE_
Any reason asserted twice
_CODE_ Severity _CODE_ Remove declaration thrown exception _CODE_ cannot thrown constructors body rule
It would better swap else negate condition better readability
The returned value used
If VAR_3 null annotate Nullable otherwise add null check
Maybe remove extra parenthesis condition
It looks since nothing fancy going log format _CODE_ necessary considering debug calls _CODE_ well actually logging
I think runkey faster keep _CODE_ byte
Since VAR_4 VAR_3 necessarily required better make _CODE_ properties _CODE_
I dont think need new String
happen null returned current scene null VAR_2 null problem
METHOD_1 seems relaxing kind exception maybe error
Oops right
Note simpler idiom also converts cleanly Java 7 syntax _CODE_ VAR_1 new File_CODE_file try return IOUtilstoByteArrayVAR_1 finally VAR_1close
Please consider adding overridden version _CODE_ int Logger constructor accepts Duration encapsulate type conversion
How VAR_6 VAR_2 implies return type would Optional Also need check VAR_5 _CODE_ considers whether createmaintain _CODE_ Having internal nullable _CODE_ fine Using Optional Stream hot code paths severely impact performance see
Unwanted final
exception possible How get VAR_2 theres associated field
use constructordelegate form instead More concise ever need put checks need put one place eg thisTypeINT_TYPE _CODE_
Why returning result _CODE_ _CODE_
Remove public modifier
Please add VAR_9 exception
compile
TYPE_1 never used
We remove method altogether
Should probably remove synchronization class
duplicate call _CODE_ caller METHOD_1 already called method key passed normalized one
This simplified making type boolean instead Boolean Jackson defaults filling false
testing point view using explicit false whatever would better ie tpch connector decides change default presto tests change behavior coverage
METHOD_2 could line affectation
I suggest _CODE_ 0 _CODE_ 0
Nit final params
shouldnt wVAR_1 wrap thVAR_1 original VAR_1
Why dont use _CODE_ annotation arguments
This change casts wide net method called methods implementing Extended _CODE_ methods implementing Shell mode eg _CODE_ correct shell something like _id ObjectId5aaff8caa33024673db4cddf Its also called read values places keys To address I think need leave current method alone add new method used read extended _CODE_ keys eg _CODE_
You dont need METHOD_3 already called _CODE_ _CODE_ TYPE_2 VAR_3
Can simplified return m_essubmitnew _CODE_
small typo I think name supposed VAR_3 right
provider
ifstories null _CODE_ return null else return storiesid
We get rid first condition nullinitialization VAR_3 using dowhile loop
instead path separator create new path make generic
Not threadsafe despite use wrapped _CODE_ registeredcontains registeredadd collectively atomic
nitpicking I think first METHOD_5 longer running second better rearrange performance currently first METHOD_5 would work less number pods
This could null I think
wrap Systemout inside another TYPE_4
static
longer need methods synch right
Using false enough without constant
Since Dates mutable VAR_1 copied passed _responseBuilderstartOfNextDay avoid downstream sideeffects
Why local Can see issue
Itd better ordering matched ordering samples list request authorization section first
Should block METHOD_2 call
I dont think need stub
Nit Move METHOD_1 statement
Here could pass VAR_3 field remove parameter
Extra space
Ok I see want pass null But instead would better super constructor takes class someone calls constructor null entity instance fail fast
Nit need call TYPE_1 explicitly
_CODE_ calling method _CODE_ Usually operation class calls methods chunks puts gets Can METHOD_7 method within _CODE_
Why binary compat break
We using save game state I think remove well If want store something use Firebase
_CODE_
Just 0
suggestion _CODE_ VAR_3 new _CODE_ _CODE_
Shouldnt use _CODE_ operator instead _CODE_
We testing largest value unsigned short
If setter called moved constructor
This makes truncation point hard reason Im sure best approach solve case I imagine debugging issue leaders truncation point advanced many times without telling replicas thus deadlocking system road I think
You drop throws clause Not thrown _CODE_
maybe simpler approach better code reuse java _CODE_ key _CODE_defaultKeys _CODE_ getkey return VAR_1
Wonder use float double properties Id lean towards double meant generic class double store float viceversa
This default constructor already
The issue found original VAR_2 could logged due error _CODE_ Do concern logging _new_ error might issue Would better two stages 1 Catch logging error try log error 2 Catch _that_ error happens log generic static message
public
flip equals SERVICE_IDequalsservicegetId _CODE_
Use Java 8 Stringjoin instead third party library
Can protected
Possible _CODE_ unless I mistaken may VAR_3
private public
Can remove throws clause
This parameter seems ignored overridden line 1284 Is perhaps bug Or I wrong
Drop next line
METHOD_2 would never null right Did mean poll
Actually name definition bound VAR_2 level Core _CODE_ recursive calls must form thismymethod mymethod sugar makes work source level goes away translation core
blows _CODE_ returns _CODE_
There need create new objects neither Stream objects TYPE_1 wrappers Please update TYPE_5 inner class allow specifying ranges VAR_1 aka offset METHOD_5
read instead
break statement missing
Can id smaller 0
Why change order You normally METHOD_2 opposite order creation So create embedded cache manager first server normally METHOD_2 server first cache manager
Sonar reports error line Remove useless assignment local variable VAR_2
Sorry pain would mind removing additional final keywords added method signatures parameters This isnt style used rest codebase takes cognitive load try work methods final dont It also slows reviewing code
protected
Please dont introduce extra indentation early exit VAR_1 return true original code This also makes diff easier read
nit get So invocation looks like _CODE_
This still seems lot overhead _CODE_ Why need _CODE_ event
please dont remove explicit initialization
You could simply create calculator
I dont think ordering important
Enforce immutable list cases
I test fails VAR_1 remain started port busy So good practice enclose tested code try block METHOD_7 VAR_1 finally
We could always use body instead flipping based payload size
need null check although matter personal preference
nit rename VAR_1 keys better convey meaning
For _CODE_ return VAR_2 immediately
The management server already shuts It shuts services using first VAR_7 orchestrator management service finally runtime Shutting create new instance management service hasnt shut yet
So upgrade drop existing markers
This line actually return substring length VAR_1 1 If substring indeed needs longer VAR_1 replace VAR_1 1 VAR_1
Out interest _CODE_
guard clause _CODE_ VAR_5 VAR_3 null return TYPE_2 VAR_6 _CODE_
This require us specialcase empty collection everywhere I think make code confusing probably error prone maintenance I think itd nice modify _CODE_ interface somehow Maybe could return _CODE_ _CODE_
equals
I think even null case return type see select pg_typeofnullbigint pg_typeof bigint
Just question sure easy could create one share
The last VAR_7 unnecessary
Does still need synchronized
redundant
Make getters private use instance members
Please make sure overloaded constructors available old constructor signature Then also wont change existing test
nit extra parenthesis around function
Same thing
use line make evident
Assert exactly 1 test also pagination
return
The default value empty string If yes change return empty string instead explicitly set value Nexus 5 tests need
Could replaced nice lambdacollector expression
This code wont work timestamps near epoch I think bit clever stick working milliseconds timestamps ISO8601 strings
I think require valid value already really dont let provide pointless null Therefore primitive long But eh minor course smile
Dont create new query object VAR_2 already nonnull return
missing _CODE_ ThVAR_3 VAR_3xcVAR_3ption adds rVAR_3al valuVAR_3 hVAR_3rVAR_3 Or nVAR_3w TYPE_6 VAR_3
Is two step handler change needed avoid memory leak Isnt enough assign new value
_CODE_
Dont leave empty add call implicit _super_ enables setting breakpoint constructor
To conform Spring Security code please remove final keyword front local variables
Could resolve _CODE_ In opinion ignore exception silently
Put two conditions together
Java 7 rocks D
return VAR_2 otherwise youll check null value call previous VAR_2 business code expect call new method
use braces generally considered best practice situation even though required language
Shouldnt performed View presumably showing popup
Im thinking return null dont need send back data client given nature resource framework sends back http _CODE_ status user case success 500 case exception sufficient
To prevent code duplication would possible change body constructor following thisVAR_2 VAR_2
_CODE_ represent came exchange premature adaptation
Should skip VAR_1 already true theres way requests stack
Remove statement That said things future reference 1 You use _CODE_ check specific level eg youre going log trace youd check _CODE_ METHOD_4 2 There _CODE_ unless disable logging altogether always enabled I suppose could use _CODE_ youd checking logging 3 As rule thumb unless logging operation extremely heavy eg transforming large object trace logs dont want check Info level lower enabled higher debug trace
please also add method _CODE_ _CODE_ _CODE_ may enough cases
METHOD_1 returns object lines rewritten form _CODE_ PreconditionsMETHOD_1fetchStrategy
Trocar VAR_2 para VAR_1 verificar necessidade
Are missing Nullable annotations mappers
Can inject whoisnonauthsource _CODE_ put logic
If never need stack trace consider calling supermessage null false false avoid overhead
Defensive synchronized methods everywhere
looking VAR_1 need see value loaded also There also _CODE_ _CODE_ subset ache need look
Use braces see
If observer null bother anything There doesnt appear way change null constructor modifier short circuit logic return
art Personally I would lean toward using guard statement java VAR_1 null return null
I think relaxing type parameter TYPE_2 _CODE_ constructor TYPE_5 extends TYPE_1 helps lot eliminate casts _CODE_
This occurs _CODE_ resource contain expected attributes probably something went wrong okay case
Is safe set distance _CODE_ node VAR_6 works _CODE_ doesnt require dc
double
I think null default
value already String need _CODE_
Wat
Is save assign new subscription without unsubscribing potentially existing previous subscription Or ask different Can guarantee called two times row activity lifecycle _CODE_
Same every try block
Leftover debug statement probably causes test failures large _CODE_ builder time
consider use METHOD_4 METHOD_6 It doesnt make sense log twice different message
String key
As paranoia sufferer I would invert equals avoid remote possibility _CODE_ java MantaHttpHeadersREQUEST_IDequalsheadergetName
We raise issues case certain As yet crossprocedural analysis assumption may end null value necessarily raise à lot _CODE_
would required
Mind simplifying expression VAR_2 _CODE_ VAR_2 _CODE_
This starting get control I really like idea add every plugin I understand follow pr I created JENKINS49367
_CODE_ returns list Why need create empty list elements
This method private
Now removed use _CODE_ made method last problematic test Therefore use Testexpected instead unusual construction
thisnew _CODE_
final String name final TYPE_1 VAR_1
maybe method named info previous one detailed report detail
size accept null values
Is casting guaranteed succeed
I would factorize condition previous
Meh This vararg method I think say containsExactly1 INT_1 INT_2 INT_3 INT_4
Nit I think new _CODE_ work
These features specific particular parser The parser reasonably expect users usVAR_10g xercesj 271 VAR_10tegrated VAR_10to rtjar sVAR_10ce JDK6 So I would followVAR_10g VAR_10stead anythVAR_10g complicated speculative respect particular parser _CODE_ true If user really convolutVAR_10g environment use different parser I thVAR_10k theyre sort anyway But tool typically run VAR_10 security context user remote service really isnt vulnerability outofthebox anyway
I would negate condition
If going probably mentioned docs Do need check grounded As far I tell would revert gliding immediately
nit remove protected make method package private test class package
VAR_1 thread safe
In general call superstop last cleanups
Why VAR_5 _CODE_
Please move _CODE_ Also use VAR_4 1090001 Users might skip _CODE_ versions When checking equality skips migration coming say 1080100 instead exactly INT_1
would make sense push logic utility method I would expect pattern true every caller point makes sense encapsulate
Maybe VAR_1 1 Same METHOD_1 methods constructor parameter end METHOD_1 range
I dont think need check null We _CODE_ since none instances called would null query
lambda
It doesnt affect result would clearer use simple bitwise _CODE_ operator instead bitwise inclusive _CODE_ assignment operator
Should cache size inside loop int 0 size _CODE_ size
Just curiosity need field VAR_3 instead first never use
Not increase scope creep well probably want get rid service soon inclined flip use _CODE_ I wouldnt object
protected
Remove one wrap _CODE_ VAR_2 METHOD_2
check seems replicate bit whats happening _CODE_ Should pass value given validations already
I believed Codacy flagged I think could replaced _CODE_ _CODE_
This return previous line well
Seems constructor never used Could remove dead code
ditto 4
Add null checks nonnullable properties
VAR_5 cant null VAR_5 thatVAR_5
Actually TYPE_2 TYPE_4 dont ifelse statement
This _CODE_
Remove cast
В этом случае надо закрывать сокет
The templates used already _CODE_ necessary replace _
change well variable name VAR_3 _CODE_ also
stashnotifier fails _CODE_ trying access VAR_6 line 134 The explanation I come _CODE_ returns null called construction time plugin I idea case though Heres exception I see TYPE_1 console output _CODE_ Publisher orgVAR_6cipluginsstashNotifierStashNotifier aborted due exception javalang_CODE_ orgVAR_6cipluginsstashNotifierStashNotifierperformStashNotifierjava134 hudsontasksBuildStepMonitor3performBuildStepMonitorjava36 hudsonmodelAbstractBuildAbstractBuildExecutionperformAbstractBuildjava810 hudsonmodelAbstractBuildAbstractBuildExecutionperformAllBuildStepsAbstractBuildjava785 hudsonmavenMavenModuleSetBuildMavenModuleSetBuildExecutionpost2MavenModuleSetBuildjava946 hudsonmodelAbstractBuildAbstractBuildExecutionpostAbstractBuildjava732 hudsonmodelRunexecuteRunjava1582 hudsonmavenMavenModuleSetBuildrunMavenModuleSetBuildjava477 hudsonmodelResourceControllerexecuteResourceControllerjava88 hudsonmodelExecutorrunExecutorjava236 Finished _CODE_
My bad My suggestion inserted typo At least I saw I start build suggestion return new _CODE_ _CODE_
Id keep nonstatic unless need call static context
I would inline error Up
I think treated like value outside range qdigest null really special case check Actually could remove first check empty digests max value LongMIN_VALUE min value LongMAX_VALUE
I kinda like leaving set variable declared either way fine
inline
static import
add another bean like components specifically look v2 variants VAR_1 adapter actually instance v1 api java Bean VAR_5 v2StorageVAR_1 component return VAR_5 componentdelegate
Please move line METHOD_2 block java METHOD_2 _CODE_ This way dont change behavior kind We discuss put later
may confusing people params name considered equal value part code wants treat Params equal long equal names better keep comparison logic close VAR_2 area maybe local Comparator class something inside data object would allow reusability class future
The param name probably format well
Sorry bother mind giving generic name variable
This change corrupts backward compatibility Eg I use constructure several Groovy scripts It makes sense add support default behavior codedepotnullcode
nit ordering different
Documentation _CODE_ says null returned wanted system property set I think make defensive java VAR_1 null VAR_1isEmpty
Could static Im blind
return
ow could dangerous We need bluejeans discuss
Lets remember remove check check instead result METHOD_3
I think may valid case supporting METHOD_3 method HTTP2 since mostly present _CODE_ could use blocking _CODE_ instead _CODE_ wont need HTTP2 Instead METHOD_3 could throw _CODE_
Weird formatting Put variable type line
Can remove throws TYPE_3
_CODE_ declarations VAR_2 semadeclarationBindingVAR_2 already
These could also changed appends
Cant enums compared well Might clearer read Also split line
dont need _CODE_
Is needed Its public _CODE_
This nit I find inverted logic like hard following reading code I think would better VAR_3 null return false return VAR_3druidServergetSegmentsegmentgetIdentifier null
Consider adding _CODE_ one shot without VAR_4
use instead string version order avoid creating costly stack trace creation exception
And
I think shouldnt change VAR_8 fields configured It _CODE_ nullalthough default practice See Could please revert changes made already existing VAR_8fields
TYPE_2 method takes two arguments please use method
Best avoid negative conditions reasonable Positive assertions bit easier reason easily missed Here flip
nan
Why bother locking size returned immediately going invalid aka thread may already changed size
nit static import METHOD_2
We move tasks _CODE_ constructors
nit merge lines METHOD_2 return given argument
This breaks _CODE_ theory _CODE_ line 224
Infinite loop You probably wanted pass cast version _CODE_ instead
The field VAR_2 nulled free memory
Is throws TYPE_1 needed
return true
The TYPE_1 never thrown
thisnew _CODE_
The smeltery runs every INT_2 VAR_1s VAR_1 0
Please consider adding overridden version _CODE_ int Logger constructor accepts Duration encapsulate type conversion
Dont need extra Valuesof wrap
Hmm want capture Exceptions VAR_13 I actually think okay capture anything since _CODE_ VAR_13 would thrown
maybe better log VAR_1 0 otherwise spam logs _CODE_ level
Can please put savemode cron order METHOD_3 properties aligned assertion
suggestion METHOD_5 _CODE_
Is reason cant one line Genuinely asking
You modifying wrong instance one METHOD_2 Map VAR_1
_CODE_ initializes classes reflection constructor The default definition set field declaration
Now _CODE_ used _CODE_ simply return VAR_1 value like getters
Nit although constant ever make max column count configurable maybe want comparison safe case max changes smaller current number columns
I would put true default
Remove unnecessary final modifier local variables modified classes
Im big fan construct may hide original _CODE_ new one happens within Logger listeners But good error types
final
_CODE_
shouldnt key
Please apply changes requested first review
I think catch nVAR_4cVAR_4ssary bVAR_4causVAR_4 thVAR_4 nVAR_4xt linVAR_4s wVAR_4 havVAR_4 catch final TYPE_5 VAR_4 throw nVAR_4w comlifVAR_4rayportalSystVAR_4mTYPE_5VAR_4
There isnt really need _CODE_ check _CODE_ observed reset clock bit
Again prefer _CODE_ size comparison
Its usually bad idea catch _CODE_ exception generated common class bugs Youre _CODE_ might return null In case use statement
Please fix typo parameter name
Whats reason behind change VAR_5 VAR_3 also _CODE_ change removes synchronization
true part needed
remove METHOD_1
Systemout
Why would make sense Just order
Same
init parameters _CODE_
I suggest use positive case often scenarios _CODE_ INT_1
If keep previous semantic METHOD_4 count METHOD_3 returns true
ditto sort name please
But returning true result _CODE_ yield always true meaning instances type METHOD_5 type type filter always included matter result unconditional filters would
I guess want effectively sealed class Java doesnt native support But mimic reducing visibility constructor making child constructors private exposing factory creation
This null check required anymore
newline
nan
Can return directly
use _CODE_ like everywhere else
This change doest appear also doesnt seem useful
Please simplify
maybe TYPE_3 closed call fail
_CODE_ missing
Nit This doesnt seem like null
suggestion _CODE_ Cheaper going Stringformat
ThVAR_12 VAR_12 really hard read conditional expression could make simple statement I believe would also helpful fix branch coverage one branch mVAR_12sing
return new _CODE_
add false parameter first entering app dont end blocked app
Can throw METHOD_1 instead callable way theres failure immediately
Why return empty string instead null
This definition never happen I think check empty collection
Instead copying list requiring potentially unsafe cast I think could make use generics _CODE_
create new TYPE_3 inside syncexec
please dont remove explicit initialization
Dont catch bare TYPE_3
parent METHOD_1 throw TYPE_3 parameter invalid method longer throws TYPE_2
Having equals throw enforce singleton module policy seems unintuitive Does really add much normal duplicate binding Config error
thisnew TYPE_1 However minor live one well
Id like keep formattingmark controllers Maybe could put VAR_5 VAR_2 attribute use _CODE_
Minor still use _CODE_
call directly METHOD_4
Make private
Is extends VAR_1 necessary use VAR_9 parameter constraint never anything ClassVAR_1
Nit explicit braces
I think variables mixed switched
I would recommend use codethiscode constructor
Why two separate trycatch blocks
I dont think done level I tend think constructing VAR_1 using _CODE_ return unknown type altogether rather unknown VAR_1 _CODE_ lead confusion
_CODE_ Severity _CODE_ Make METHOD_1 static method rule
data cannot null
This method doesnt depend internal state static java public static VAR_1 _CODE_ VAR_4 That way dont need create new instance VAR_1Helper order use method Where call itll look like java VAR_1HelpergetHttpHeader rather java new VAR_1HelpergetHttpHeader
property definition
It looks like would nice add assert
nahuelsoldevilla hibernate set id object transaction committed
Whats point StringvalueOf0 Why 0
METHOD_1 expects localization key
What think simplifying method java true final _CODE_ VAR_1 _CODE_ VAR_1 null return new _CODE_ final TYPE_1 VAR_3 VAR_1get VAR_3 null VAR_3cursor 0 VAR_3startIndex 0 VAR_3VAR_3Size VAR_3keyslength return VAR_3
Does need optional
X true Y simplifies X Y
Btw Im sure restriction necessary Eg look implementation METHOD_1 get METHOD_1 _CODE_ extra slowdown caused using TYPE_3
yingsu00 This shorted _CODE_ _CODE_ VAR_1 null
Inline
I would log warning throw away VAR_9 display new VAR_9 Also I would check _CODE_
Why need set text bounds setting fill gradient And good reason potential use either public methods sets text bounds
Remove
null Although I guess doesnt matter
I thought VAR_1 extensions json I thought process definition key extensions json And thats yesterday class tried look keyand id like past What missing
I personally dont think worth VAR_4 likely Just single threaded per node one sufficient _CODE_
This log statement isnt really adding value plus system call remove
nit Id inline variables
Maybe return 1 directly Had wait moment looking return VAR_1 isolated I didnt get okay return METHOD_1 value
Does Java operator
This actually setting value Javadoc states empty We avoid setting value null avoid setting empty collection input empty
nit merge lines METHOD_2 return given argument
convert private constructor static create method
This code simplified Would nice comment describing deeper meaning behind logic
I would shuffle order
You eliminate repetition please check logic see thing public String _CODE_ TYPE_1 VAR_1 _CODE_ null final TYPE_2 VAR_3 VAR_1getTYPE_2ById_CODE_getId VAR_3 null StringUtilisEmptyVAR_3getName return VAR_3getName return thisname
Why need variant _CODE_ going proxy _CODE_ anyway
used Just return null
_CODE_ METHOD_1 method
new TYPE_2
Why pass enum work
This null right
Why need
Should fine call new TYPE_4 need list types right side I think already somewhere
m_ redundant
Could variablesmembersmethods use phrase _CODE_ changed code easier follow
please use Diamond Operator initialization
still need _CODE_ VAR_4
Change _CODE_ TYPE_2 super TYPE_3
Is related feature description
Put METHOD_4 finally block attempt always made METHOD_4 VAR_2 even commit failure If closing VAR_2 fails theres really anything VAR_1 move
Suggested VAR_2
private probably called static factories class
sort
Same
Can explaVAR_3 necessary It seems like issue tryVAR_3g resolve related whatever comes function rather issue function There guarantees reader VAR_3dex Drillbuf VAR_3 fact remove beVAR_3g exposed VAR_3 functions See function positions reader doVAR_3g anythVAR_3g else Is operation doesnt position reader We apply fix
Is needed remove
synchronized
seems little worse I see constructor _CODE_ also tries following _CODE_ pool _CODE_
Ditto
nice could made static I guess
Where VAR_2 needed
That doesnt look right
Maybe name VAR_5
Is cleaner way without relying type _CODE_
puneethps try move Filesexistspath check
Just call method within statement need save local variable
METHOD_4
nit places _CODE_
part checking throw statements
assert value never positive
need wait VAR_4
VAR_1 must integer
I think saw initially method named build I think I liked better Did move away approach could vague another method providing builder I kind like build returning VAR_1 builder For returning VAR_1Builder concise
4 spaces
VAR_9 used exception
nit needs new line
Meh means new allocation operation I wonder much mess would storing VAR_1 directly _CODE_
move VAR_1 declared since never changes
line removed
Is TYPE_3 needed
Nit would make sense constructor calls constructor line 63
Ditto
Why changed 2 1 There two tests
String VAR_5 ServiceManagergetFilterServiceparsePrimeFacesFilterVAR_5s
This close VAR_17 data source right VAR_17 setup
Can use equals instead _CODE_
makes sense filter references name resolving
Just return VAR_5
Inline
Set subtype Collection second part necessary suggestion _CODE_
Verificar se é necessário usar _CODE_ momento
equals
This private
These seem covered VAR_5 already
naming constraintstatus
Code Smell Code Smell Code Smell Remove unused VAR_2 local variable squidS1481 See _CODE_ ISSUE_KEY _CODE_
convert private constructor static create method
I personally would prefer final
Please make methods public
Lets use generics since using Java 15
Same
We never get TYPE_6 thats bug forgot call _CODE_ something wrong _CODE_ Lets catch METHOD_2 rethrow _CODE_ PrestoExceptionGENERIC_INTERNAL_ERROR
Its issue I think better put checks single line direxists dirmkdirs
Not backwards compatible
private
It seems always set true
Right 1
copy
For METHOD_3 mVAR_5ssagVAR_5s bVAR_5ttVAR_5r usVAR_5 _CODE_ Or simply LOGGERMETHOD_3LVAR_5vVAR_5lSEVERE FailVAR_5d build dVAR_5pVAR_5ndVAR_5ncy VAR_2 VAR_1 VAR_5 contain thVAR_5 samVAR_5 information morVAR_5 anyway
You longer need define pass backend name You call start METHOD_2 directorytype VAR_3
nit avoid composing error message happy cases consider changing logic VAR_1 return false
Should VAR_1 name
put way around java _CODE_ VAR_3 _CODE_ avoid double negation I find lot easier read
Code I think local variable VAR_1 unnecessary value returned directly At least variable shouldnt predeclared null value
Should line 89 java _CODE_ Argument VAR_1 cannot blank
VAR_5 VAR_5Canceled
We could use newly extracted VAR_3 flag instead invoking VAR_3dataConversion
Its used
java GuiTabtabRegistrygetclazzcontainsVANILLA_INVENTORY_TAB
Should 1 additional case something like VAR_5 BUCKET_NAME path
Should size type
Can simplified java return VAR_1 null 0 VAR_1getMaxStackSize
Assertions _CODE_ variant could use _CODE_
If overridden dont declare abstract Is optional
When rolling back location transformation function youll probably change values They also appear _CODE_ example bear mind change
remove TYPE_4
You need keep mind sentence construction languages could different query string doesnt always show end You use 1s string valuesstringsxml pass query term extra argument _CODE_
analysis nullable
Why used _CODE_ VAR_7 Use VAR_3
Missing semicolon end No compilation error
reason displayed everytime since shown second project selected always
I find method used outside class Is intentional
I would change ifurl null return null less indentation code looks lot cleaner
Shouldnt first VAR_1 reference line also changed key otherwise adding potentially null key cache
superSC_FORBIDDEN similarly constructors
test succeed undefined METHOD_3 well
rm final
Do local variable values debugging purposes If could shorten statement java return _CODE_ _CODE_ Let know _CODE_
Maybe final
nit initialization required
VAR_3 used remove specialization
nit align variable names
Same
Theres need threadsleep If fail count 0 resubmit executable scheduled executor 10s later
Do need VAR_3 temp variable Can call fluently
I guess long instead string
dont usually declare local variables final
final
This intermediate variable necessary
combine one return line
调用 keytrim 干什么 另外keylength 0 并不代表是非法的 key
nitpick VAR_2 VAR_2gVAR_2tKVAR_2y could bVAR_2 rVAR_2placVAR_2d CachVAR_2EntrygVAR_2tKVAR_2y thVAR_2 samVAR_2 thVAR_2 changVAR_2 bVAR_2low ps surVAR_2 onVAR_2 morVAR_2 VAR_2fficiVAR_2nt
thisconf seems different behaviour _CODE_ _CODE_ whereas constructor doesnt
I see pass parameters lot VuapVideosPORVATA_VAST VuapVideosVAST_VIDEO Maybe could extract method hardcode two parameters
With exception constructors nonstatic inner classes setters key word isnt usually needed
pynicolas We still pieces logic getting object property value spread several classes expression stack _CODE_ even 2 methods METHOD_1 METHOD_2 I think make effort concentrate one place
static import functions
Same
Mind whitespace please
suggestion _CODE_ leica scn400equalsIgnoreCaseidevModel
protected method
There seems missing
Is method going overridden subclass provide different behavior This method protected supposed overridden outside package
геттер для очков добавь только
Does work Really super _CODE_ shows recursion
suggestion public void _CODE_ VAR_3
We try limit scope goes inside METHOD_2 block better auditability Here I think last line needs inside privileged block
need new constructor adding new parameters break backward compatibility preserve old constructors pass null value VAR_5 new ones
Put two assignments order clearer
Same issue variable names
respect offset data length
The final user cant override method
VAR_4 included
Probably add _CODE_ item needs changed compare TYPE_1 objects instead ids finally remove deprecated methods take ids
1 use comparing 2 _CODE_
I dont think TYPE_2 wrapping right thing creating parser actually parsing anything
If throwing runtime exception anyway VAR_2 null isnt better let throw _CODE_
still may want grab eventlogmanager retrieving actual eventlogger still happen start method since server event logger different
Is reason go synchronized file instead adding synchronized keyword method signature
Instead using METHOD_6 line 42 could combine next line another METHOD_4 call METHOD_6null return statement
The convention use instead
check VAR_1 null
Please move line changelog VAR_1 VAR_1setDescriptionSearch collection _CODE_ Change71 new field scope added response _CODE_ Change71 field scope added f parameter
pls also remove number regexp matching since never match input string anyway
I would suggest _CODE_ _CODE_ instead _CODE_ _CODE_
Sorry picky return _CODE_ _CODE_
If VAR_2 null returns VAR_5 VAR_2 null returns _CODE_ Neither case actually returns VAR_2 P
Catching Exception rethrowing asis equivalent catching So implementation method targetstop exception management much simpler
Nit No reason declare assign line
I understand need method could please clarify
endup locking whole method theres reason use block use synchronized method Applies similar method
I made change _CODE_ method annotated _CODE_ I got issue thats I added check So ignore issue
primitive
Also missed similar fix _CODE_ _CODE_
If VAR_2 false VAR_4 need resorted
For sake consistency _CODE_ use codethisspeed speedcode rather setter
Can remove call METHOD_4 count
If isnt defined return null _CODE_ _CODE_ get thrown
Is reason static If I would remove
As dont visit tokens _CODE_ I wouldnt one either stay consistent doesnt impact
_CODE_ java new _CODE_ new _CODE_
We global event listener METHOD_4 METHOD_5 dont need
It might tiny bit readable call _CODE_ well Ditto line 359
Why still public final
Are returns used anywhere If might well make method void Applies throughout
Is right constant represent dont know lag Or I mistake going used
Just _CODE_ It might worth extract method somewhere else
You create executor auto connect
Should return long
use _CODE_ rather plain null Also I think constructor use constructor thisconf _CODE_ VAR_3 new TYPE_4
It visible testing actually visible value set instantiators Check class ie platform public without annotation
Should done first method
Could log thVAR_3 VAR_3xcVAR_3ption _CODE_ _CODE_ VAR_2 caught whilVAR_3 calling VAR_1 VAR_3
Why update profile timestamp This isnt one required fields And regardless redundant recalculated set syspurpose attributes change anyway
m_esisShutdown could save lines codes
nit used
I think set finally block
I would remove variables return new _CODE_ VAR_3 thing applied methods
This doesnt seem quite right If _CODE_ set elsewhere could override
thisexception null response null _CODE_ return try catch
nit consider merging lines The formatting looks strange
component null
following thVAR_4 commVAR_4nt abovVAR_4 could bVAR_4 simplVAR_4r privatVAR_4 TYPE_1 _CODE_ VAR_2 try rVAR_4turn TYPE_1valuVAR_4OfVAR_2 catch TYPE_2 VAR_4 loggVAR_4rwarningNot valid modulVAR_4 typVAR_4 Valid modulVAR_4 typVAR_4s arVAR_4 ArraystoStringTYPE_1valuVAR_4s throw nVAR_4w ShVAR_4llExcVAR_4ption
This kinda duplicate already VAR_1 METHOD_5 method particular reason VAR_1 another element
Should last parameter VAR_6 VAR_5 And yes I would rather separate different lines comprehensible For example takes much brain power know 5 3 2 3 We tests call _CODE_ error copy show array initialized 16 elements tests VAR_6 45
suggestion return null Nitpick returning null also works slightly simpler
inside TYPE_2 maybe _CODE_ others
This would better duplicate keep private
please squash first commit
Pass VAR_2 rather pulling static TYPE_3 method
No need return Its single expression
check needed _CODE_ returns null mapping given key present
Minor collapse blocks _CODE_
I think could removed _CODE_ completely passed key directly
m_
Can called type instead id Also Im seeing client test enricher I miss
Remove binding one causing circular dependency The _CODE_ supplier provides endpoint region uses Region _CODE_ _CODE_ binding configured get regions _CODE_ _CODE_ generated _CODE_ thus circular dependency The default implementation _CODE_ populates list regions based value jcloudsregions property want removing binding leave good regions properly configured
These else redundant
This even shorter filteritem _CODE_
Do need call METHOD_6 call worked If move inside
The last argument node inherited parent builder instead null
Lowercase boolean use primitive type
protected
Probably crash bad format string
technically test tests passing false _CODE_
Maybe pass VAR_4 instead INT_1
Unnecessary parens around return value
In common success case Id expect use constructor doesnt require null VAR_2
I really dont like returned value I would prefer dedicated object containing errors related semantic model even first time contains classes found
Could please explain reason change
remove VAR_2 parameter METHOD_7 method
The VAR_2 VAR_3 doesnt allow easily see many entries actually less informative VAR_4 VAR_3 Long lines VAR_3 also _CODE_ deal I would suggest VAR_3ging number entries VAR_4 level separate line processedskipped entry
need public
trywithresources would probably cleaner
Maybe VAR_3 return since volatile VAR_3 already avoid grabbing lock
Here newline missing
I think method could private
Why use thirdperson singular instead calling flag _CODE_ I feel _CODE_ explicit
suggestion _CODE_ make bulk copy
_CODE_ METHOD_3 generally needed unless need access application nonapplication context Here returns instance application hood
For line 56 lien 58 difference two Its testing trim need two Closed
Maybe turn assertion since function private contract already verified public method well
seems like statements could merged
I believe change name null _CODE_ _CODE_ Will much easier read
condition moved part loop ifhcatclientnull _CODE_ retries
Are lines required Id expected wed need _CODE_
_CODE_ missing
private
Ignore comment think trivial try TYPE_2 VAR_3 _CODE_ _CODE_ _CODE_ TEST_ENTITY VAR_3execute
Todo
опять копипаст у тебя ж сверху в _CODE_ точно такой код И вообще если мы удаляем в _CODE_ то зачем еще здесь _CODE_ в любом случае срабатывает когда с юзером связь остаточно закрылась
check VAR_1 null
Private
fallthrough _CODE_ line 47 Intended
public still call _CODE_ even private
This set races dereference L101 may cause _CODE_ Besides since would set value VAR_1 essentially plus transparent _CODE_ layer dont really need field Just call thisunsubscribe L101
This thing I object Im fan Springstyle magicby I mean stuff happens _CODE_ classpath sometime next year Java 9 module graph _CODE_ thus far done great job keeping magic visible I would rather force users make single call _CODE_ _CODE_ stuff truly optin
Why return directly _CODE_
Shouldnt finally block
Make consistent _CODE_
Please extract local variable java TYPE_4 VAR_4 new TYPE_4 TYPE_5 status new TYPE_5 VAR_1 VAR_4 VAR_2 VAR_3 _CODE_
Add
VAR_1 VAR_1Str
Splitting injector mentioned simplify else loops
This function used unit test expose
final required
Same
Make consistent two
return
nit need empty line
VAR_3 _CODE_ needs removed otherwise math fVAR_3nctions treated nondeterministic
Please remove field
METHOD_1 是否可以改成 static method
return defensive copy new _CODE_ make immutable
METHOD_1 already called METHOD_7
Is clearer way
VAR_2 used
Method signature changed KFSConstantsEMPTY_STRING used METHOD_2 call
must protected concurrent accesses
Instead repeating source code make call _CODE_
I would prefer code done _CODE_ constructor keep _CODE_ TYPE_1 detected moment also like _CODE_ key manager mapping
This follow _CODE_ codestyle missing
Java8 trywithresource _CODE_ VAR_3 new _CODE_ _CODE_ _CODE_ append VAR_3printname
remove truefalse It unnecessary
Doesnt also trigger Byte Short Long rather Integer
need catch VAR_8 rethrow avoid wrapping another VAR_8
remove finals
This throw _CODE_ empty string passed pattern
Not using curly else branch
Why VAR_7 still list
_CODE_ returns METHOD_3 name field StringMETHOD_3 collisionresistant Meaning small chance astronomically small SHA1 VAR_4 key could collide another parent VAR_2 TYPE_3 already provides way make collisionresistant key two strings I recommend java String VAR_4Key _CODE_ TYPE_3createKeyHashVAR_2 _CODE_
check removed
really required using topic selector state factory far see dont even need constant _CODE_ anymore
Dont need assertion
Should consistent assert assert VoltDBLRelVOLTDB_LOGICALequalsgetConvention vs assert traitSetcontainsVoltDBLRelVOLTDB_LOGICAL
Im unsure defensive copy helpful In regular Java code I would say yes array kept private values come runtime bootstrap The case null good worth allocating array
This seems needlessly complex Youre using boolean supplier _CODE_ Why call METHOD_2 directly
Could omit first case VAR_5 let default
Dont need call either
Perhaps set key _CODE_ null
Why separate statement return _CODE_ _CODE_ Arraysstream
really way around eg include engineplanner features
Remove public modifier null checks since injector already enforces
nit _CODE_
This line causes endless load linux node zero children
This wrong You never read VAR_1s directly Always use TYPE_1 access VAR_1 types data representation within VAR_1
No need null checks injection constructors
_CODE_ Severity _CODE_ Immediately return expression instead assigning temporary variable key rule
What Optional What R Can make METHOD_1 return actual type function
one option maintain backwards compatibility release suggesting forever would accept optional query param optional _CODE_ blob throw _CODE_ 400 neither supplied
The spec defines attribute Name
I think message comes _CODE_ As general method logging I think cant
initequals null safe consistent last check method
Should return _CODE_
I prefer registering aliases theres legacy name thats deprecated Since _CODE_ new component use one name
Can move second part conditional METHOD_2
Is reason arent calling _CODE_ VAR_3 VAR_4 VAR_5 If would mind changing I realize minor point one less thing keep track
The constructor already logic Could thisVAR_1 VAR_1
The general convention use braces ifelse statements
This static
Shouldnt finally
bhhari VAR_1 _CODE_ VAR_2 redundant _CODE_ checked already ditto _CODE_
nan
We compatible java 7 probably use try resource
VAR_3 cant null otherwise constructor would throw _CODE_
nan
false default
could use trywithressources statement
No need assign temporary variable
Could simplify java _CODE_
Why need log message Does seem add much
_CODE_ stream fscreatenew Paths3ntestbuckettest initiate upload creating stream closing immediately assertEqualss3getAcl _CODE_
This changing behaviour Previously would add result VAR_7
already passed
No super
Nothing appended TYPE_4 constructing initial text could replaced plain String instead
Should way around
VAR_3 histogram records many Ids VAR_2 time every time someones calls lock Its counter This statement effectively means someone tried lock 1 ids
use final
I know already public make package private
Im sure I like checks staying They moved Codec28 checks done using _CODE_ protocol 28 whichever last _CODE_ protocol version sent If leave youre going carry checking even protocol 29 wasteful since server send
add final ensure set final TYPE_3 VAR_1
I would change like return _CODE_
I think check VAR_3 null
Please replace VAR_1 VAR_1 INT_1
nit seems like prefer put else return elsewhere codebase
It better avoid nested statements
This method may written single line check reference _CODE_ returns null key doesnt exist
_CODE_ missed end line 269
Nit Consider adding default defaultsyaml instead That way obvious users default
This wrong substitution VAR_4 null
We use _CODE_ want declare exception
The VAR_14 class attribute instead getting instance static
Why need use superadmin credentials youre already logged superadmin
nit Can static import _CODE_
_CODE_ however _CODE_ return null defaultCIENT_KEY_ALIAS
Do actually need fetch VAR_9
This fail container exist see Should better catch exception leave tryfinally let method fail container cant deleted
Any reason doesnt use Objectshash Because INT_1 instead 37 I ok changing hashcode formula long doesnt violate equals contract
Use instead duplicating size logic
Are sure _CODE_ always null I suggest rewrite condition TestToolsPresenterIDENTIFIERequalsuberfireDocksInteractionEvent_CODE_
Can use trywithresource pattern
unless want allow null values use primitive boolean instead _CODE_ object
ivandalbosco Why return constructorequalsname
else redundant
It already set method three lines
Parameter VAR_3 used method
Please try consistent use final parameters
unnecessary assignment actually moved
nit move variable closer first usage
Could return _CODE_ one line since VAR_2 used anywhere else
doesnt need public I think
I think next two methods private
What using something less specific like TYPE_2
To line useless _CODE_ checks wont work without semantic wont change coverage
Pointless assignment
UsVAR_9 VAR_9 gVAR_9nVAR_9ral rVAR_9mark bVAR_9ttVAR_9r namVAR_9 would bVAR_9 VAR_9rror VAR_9 gVAR_9nVAR_9ric hVAR_9rVAR_9 instVAR_9ad METHOD_3 abovVAR_9
Declared unused
keep suggestion final VAR_5 VAR_6 dcreateProjectVAR_5class VAR_6 final VAR_5 VAR_9 dcreateProjectVAR_5class VAR_9 final VAR_5 VAR_10 dcreateProjectVAR_5class VAR_10
This cast unnecessary VAR_5 byte array irrelevant negated mask promoted int I think case overly aggressive inspection
Can add version parent takes normal Module The current way taking _CODE_ confusing leads mistakes
The class abstract Constructor protected
static
Nitpick I think ternary would nice This reads lot like guard block really binary decision
unnecessary final
Same
This cause VAR_7 leak We need sure _CODE_ _CODE_ set true ones create VAR_7
method static
This defaults aon windows I think drop _CODE_ instances
Indentation 2 spaces
would reverse check access control existing catalogs I think access control impl may problems nonexisting catalogs
I dont think printing VAR_6 VAR_5 really useful
How come loggererror
Callback never null
public
See
charsyam You make loop oneliner _CODE_
need declare public
Field VAR_2 exist VAR_1
Add test mixed aggregation different symbol sets _CODE_ _CODE_ x _CODE_ countz _CODE_
duplicated _CODE_ _CODE_
Maybe add counter inside handler INT_1 sure compiler doesnt throw away
assert removed since tested METHOD_2
please nullcheck
0 sufficient initialize long VAR_8
intend leave METHOD_6
braces needed
Just consistency please use final boolean VAR_5
Why added container part METHOD_3 METHOD_2
perhaps short version could _return _CODE_ _CODE_ false_
This another behavioral change I dont want see unrelated _CODE_
Same comment previous test case
Since testing facility Id make methods around least package private Another possible approach would manually register _CODE_ work using _CODE_
event
I believe parenthesis around VAR_5 necessary
The ifelse results need reversed original subobject code used nonpersonalexpense situations
Why cases line 34 37 necessary
int count offsetsget
Ill METHOD_5 repeating
nan
I think could reduce constructor call another constructor java thisconfiguration null
I believe stored field called every input file _CODE_ null VAR_8 _CODE_ And unless something mind I believe constant could inlined used rather intermediary variable VAR_6
registering type constructor
I would add final suggestion final TYPE_2 VAR_3 TYPE_2fromStringVAR_3Type
missing _CODE_ statement
On rethinking validation moved _CODE_ validate dont impose ordering builder
Just throw _CODE_ instead somebody else could check cause
Should _CODE_ tested emptiness well due subsequent get0
Why substring0
I dont think fallback
final
suggestion _CODE_ INT_1
May TYPE_6 part also part VAR_6 execution
droneboost view parameter non null reuse instead inflating new one This helps performance since view inflation expansive You see example
info redundant
I like builder approach build throw VAR_3 inappropriate VAR_3 like private
please annotate VAR_2 parameter Nullable
This simplified Same line java _CODE_ _CODE_ VAR_2 cannot null
static import _CODE_
Theres currently helper method class getting public address I think line become return _CODE_ _CODE_
nit remove
We might want consider logging info severity wdyt
nit VAR_1 doesnt make use feature selection constructor accepting feature selection would needed Therefore superclass _CODE_ still provide constructor doesnt require passing feature selection
simplify implementation way done _CODE_
Change getter dont need cast
Please rename set
necessary equal approach set id builders
second parameter removed
lead 1 VAR_4 METHOD_1d METHOD_1 probably called concurrently Keep things simple make method synchronized
minor dont need lines
METHOD_2 check done _CODE_ jars intentionally get updated everytime _CODE_ jars used testing designed get updated run Or else would reason method METHOD_1 exist guess failure result running concurrent jobs _CODE_ jars
Shouldnt deleted _after_ VAR_4 directory deleted VAR_3 call
_CODE_ check seems clearer
You could invoke private constructor
Lets move initialisation declaration
Dont need Stringformat
Space
final
Remove
These three _CODE_ guaranteed fire millisecond Youll need orchestrate METHOD_1 fires value reused
I would prefer removing 2 arg constructor _CODE_ pass null The intellij refactorchange signature tool helps
needed unboxing
test required
Can mark Nullable please
isnt iterator excluding expired Tombstones
Looking closer I think VAR_3 value instanceof TYPE_3 This lead METHOD_1 called got via last constructor This slight change behavior I wouldnt expect following throw _CODE_ cause _CODE_ _CODE_ _Edit_ A much simpler solution would call METHOD_1 _CODE_ VAR_2 TYPE_3 e Sorry I didnt see class complicated
What method actually Why need create _CODE_ object add something retrieve immediately afterwards What purpose intermediate step
Please use trywithresources statement instead handling manually
move VAR_7 place file output stream created java final TYPE_3 VAR_5 VAR_7registernew TYPE_3outFile work
name poorly chose object created Phone clipping name _CODE_ content clipping relevant test
METHOD_1 package private Should public
Merge return VAR_2 null
The second arg call also set empty string
We dont like Systemout
explain needs final method
Nitpick wouldnt step step clearer check even necessary
If youre using _CODE_ dont need second parameter anymore You also remove data provider
Whats reason copy _CODE_ value new list
In general injection constructors package private
What another METHOD_2 Otherwise rely implicit return
Just quick reminder suggestion _CODE_ _CODE_ response
Never compare true useless
VAR_3 never updated Am I missing something Also I wonder update _CODE_ new VAR_3 argument well
No need add details base exception message already contains name problematic class Just throw new _CODE_
No need define VAR_6 use inline
Why need _CODE_
Why want return clone VAR_1 If declare fields final whenever update always create new TYPE_1 object I think safely return cached object directly
Protected usually means used subclass usage I think packageprivate modifier correct
For newer fields added arent fields cant otherwise default using _CODE_ field rather updating constructors Note means youll need _CODE_ method defined _CODE_ annotation See _CODE_ guide
Now youve implemented reporting functionality log statement removed
As attach class I highly suggest implement Startable move handler application scope
We inject TYPE_2 method parameter Alternatively Autowired TYPE_2 field
public
I dont think args necessary TYPE_3 argument
I think forgot remove line
Please consider adding overridden version _CODE_ int constructor accepts Duration encapsulate type conversion
We return even false Should something else case
Consider overriding equals _CODE_ well
You might want add debug ever want debug whey backup name validated could special characters etc
Id write VAR_1 though doesnt seem drawn warning compiler
Should condition VAR_12
nit please remove semicolon close bracket
Minor point shouldnt really testing accession number 12345
Could please always use curly braces around bodies statements even theyre oneliners
You use string overload TYPE_4 METHOD_5 exact match
Same question change scope
breaking backward compat
Can remove _CODE_ condition well
You use _CODE_ VAR_2 new _CODE_ TYPE_6 VAR_1 Also make TYPE_1 TYPE_6 suggested previous comment
Could return false avoid variable
Here I think 0length arrays quite rare except maybe tests little data segment
There corresponding _CODE_ getter
Code Style Space
Can please remove TYPE_1 since necessary TYPE_3 instead Also consistency please place TYPE_3 first argument
switch primitive booleans instead removes potential _CODE_
Why packageprivate Nothing else package uses far I see I generally prefer protected subclasses really need access private In case accessed via named _CODE_ private best
please use operator condition combine statements better readability
VAR_5 shows unused variable please remove assignment
1
Overload constructor takes token usernamepassword
目前只支持imageMogrify的saveas这个方法不应该是public的
This technically _CODE_ breaking change Im sure matters much yet could also add overloaded constructor default value
I think remove check That checks alluxio scheme authority
TYPE_1he method name METYPE_1HOD_1 suggests returns cache But one parameters _named_ cache returns TYPE_1 instance Does name METYPE_1HOD_1 match method
It seems constructor parameters referred Is intended
SECONDStoMillisINT_2 INT_2 Timeout parameter METHOD_6 seconds milliseconds
Why private _CODE_ thing public
_CODE_ class cast TYPE_3 required
Same
This line also removed
ndbroadbent use equals
privilege
My point consistency different codecs Protobuf codec assumes VAR_3 handles METHOD_4 code call explicitly We make consistent set expectation METHOD_3 VAR_3 handle METHOD_4ingclosing VAR_2 Then codecs would close METHOD_3 VAR_3
Seems bug logic clear using METHOD_3 18th buffer METHOD_2 instead buffer METHOD_2 without 7 bytes The classic pattern implementing things java int 0 VAR_1 _CODE_ _CODE_ usedFlagBufferMETHOD_3i 0L VAR_1 _CODE_ byte 0
still need synchronized
Lets reindent things please And lets add VAR_7 VAR_4 It makes sense Maybe lets name path I think also valid path class level constraints
Same comments
METHOD_1 是否可以改成 static method
Rather change could flip flag _CODE_ true VAR_1 line 59 VAR_4 thisVAR_4FactorygetIngressSessiontrue If theres reason Im seeing need control Id rather see interface wrapping change flags set independently
change order VAR_2 return return
could simplify immediately returning false _CODE_
redundant
nan
I think new instance
Will better use _CODE_ instead boolean flag
We use small doubles simple calculations
Personal flavour whatever like If object initialized class constructor I It keeps normal constructor cleaner shorter Especially initialization logic normal constructor good way get rid things dont
I think could reformulated efficient ie java VAR_2 _CODE_ _CODE_
static
A miss
minor Write id null throw new _CODE_ receive _CODE_ Thanks
minor braces
This case looks redundant default
cant VAR_4 null point
error
Field constructor parameters may renamed well
removed
Did write scratch
_CODE_ thinking
wrong formatting hard read
The TYPE_2 must name used lookup function
METHOD_2 expensive right new array copying entries
Can removed
This doesnt look right VAR_5 already session property You get VAR_4 rather creating new field
Not sure matters according docs method return true event consumed _CODE_
multiple semi colons
etc rest
This _CODE_ someone passes list null Do ignore throw exception
In asserts statement expected values first argument Please switch order arguments
Perhaps use static imports everything form TYPE_2
Shouldnt 2nd parameter false dont force static initialization
No need empty message _CODE_
nit check empty pass null Otherwise cant add VAR_9 copied instance Im looking constructor trying figure opposite assignment
useless string builder use default constructor
The thing looks like reorganize logic depends derived traits logic fact used things like accept draft batch actions etc We refactor improvement later
Dont need wait tx completion responses removing local info either although since removing local info expensive could still send command first
Seems else block replaced _CODE_
helenren Use lowercase boolean
How call get twice It might expensive sparse entries Like java double value geti j value VAR_1 VAR_1 value
What reason validation
Would possible add warning switch Something warns unexpected value Or remove default
Im sure methods carry weights add complexity
Leftover _CODE_
From quick look METHOD_1 looks like VAR_5 isnt reset null focus lost VAR_1 null VAR_5 VAR_1getId _CODE_ Focused changed VAR_1getName else _CODE_ Removed focus I believe _CODE_ block VAR_5 null although youd need sure arent unintended consequences _CODE_ place value used _CODE_ looks like currently retain previously selected VAR_1Id even VAR_1 isnt currently focus Not sure top head intended behavior
normalizenew _CODE_
You dont need change type
Just call status METHOD_1 consistency types
This block useless
I dont get If extend _CODE_ mimemessage shouldt passed
Unnecessary braces single statement block bunch file
Better use ifelse statement instead 0 initial capacity
Looks like could remove exception annotation parent class
Original query cacheable This one I think third param false
suggestion private void _CODE_ String VAR_1 String VAR_2
remove blank line
Nit tend always use braces selenium codebase It makes harder cause chaos accidentally
Since constructor package private Guice injector able call remove null checks The injector already fail parameter missing
I dont agree change I think want list existing members everyone _CODE_ You dont want send messages
Avoid TYPE_5 You could return _CODE_
Also missing reference attribute holder
Remove third argument UTF8 default
Are needed Seems like two extractors would enough cause situation
Why changing everything TYPE_1 class
Why cannot continue reuse single TYPE_2
This method used index view
Missing bracket
VAR_1 VAR_1 certainly doesnt look right
_CODE_ equals instead VAR_1
This method doesnt need return anything When completed connection considered closed
I think better create clientexecutor default _CODE_ instead UnblockablePoolExecutor_CODE_ usercodedeployment enabled This way executor threads wont _CODE_ threads assertion ignored This disable_CODE_Check param disabling assertion looks ugly
public
Whats last one Should finally block
_CODE_ Make VAR_1 static method rule
typo
Typically objects go first following primitives last When dealing methods directly modify objects object manipulated always first I seen This seems apply many modified methods
String needs boolean
With TYPE_2 exceptions first argument Format string arguments go end
Why either fix string use instead nothing let implicit _CODE_ job rather calling _CODE_ explicitly
carryxyh lets move check assignment VAR_4 check like
needs buffer outbuffer _CODE_ basically also need make sure original field point right buffer next function execution
new TYPE_3 redundant
Format
The VAR_2 parameter needed
Weird indent
I would prefer move call private TYPE_1 constructor
always equals 0
two generic parameters return new _CODE_ TYPE_5
_CODE_
Why You iterate set fine need copy arraylist
boolean
This static
aalmiray probably forgot groovy file wink
I hate use ends docs
Could please consistent using final final _CODE_ VAR_2
Could call method _CODE_ domain instead
Can METHOD_5 finally block
Fatfinger switcheroo
nit chained onto previous lines assertion
If VAR_5 might want return rather getting stuck another METHOD_5
Since tracking event user taps METHOD_1 button VAR_1 valid maybe shouldnt call VAR_1 filled may misinterpreted user filling VAR_1 input Does make sense To honest Im even sure need event Whats idea
Is necessary The semantics METHOD_3 supposed called component removed screen companion app
For sanity check make sure _CODE_ equal _CODE_
would consistent use _CODE_
Should probably removekey value null
Why _CODE_ _CODE_
public constructor take care preserving backward comp
nit inline
I dont see METHOD_1 methods need synchronised
need use outside constructor Here
wrap single VAR_9 VAR_8
restart requirement always _CODE_ applied instantly dont need world reload startstop rendering
This class isnt public methods
I prefer VAR_2 null null buildProviderVAR_2 avoid negations Also please make sure space left right
I realized VAR_4 isnt used anything You remove Id suggest instead moving declaration VAR_6 try section gets autoclosed
We ususally dont put logic entity class Will confusing setter side effects _CODE_
Type argument VAR_2 need
Really mezz braces Youre better P
throws
If theres one thing dont need another variation method Just specify thread id instead
I dont think NONNLS1 required String literals
Can check VAR_3 fetch volatile field something like TYPE_2 localTYPE_2 VAR_3 localTYPE_2 _CODE_ null else
TYPE_2YPE_3 generic TYPE_2YPE_3 super TYPE_2 VAR_1
condition
benefit waking consumers _CODE_ consumer closes The way I understand _CODE_ consumer null entries sleeping consumer shouldnt benefit waking
Same please move _CODE_
Remove space please
Is reason throws VAR_6 signature
This one checked _CODE_
needed
nicely done one consideration VAR_2 contains information went wrong ie actual index size list catching throwing new one lose information please change stacktrace message original exception passed catch TYPE_2 VAR_2 _CODE_ throw VAR_2
rVAR_1turn VAR_1 instancVAR_1of OutOfMVAR_1moryError DIRECT_MEMORY_OOM_MESSAGEVAR_1qualsVAR_1gVAR_1tMVAR_1ssagVAR_1
could useful note also fixed using name attribute _CODE_ annotation ie _CODE_name VAR_10 id This add extra security refactoring cost verbose syntax
Typically would put Array designators type variable
Do need METHOD_4 Im big fan essentially express expect precondition fail dont want test fail METHOD_3 really right
one seems counterintuitive The annotation outermost type printed saying incorrect wow feature weird
I would rather choose loop implement rather recursive call call stack grow quite big unecessarily call depending level nesting file moreover I believe loop would readable
Is cast needed There one timex method
remove final
Not good idea add generic exception Should least limited throwing exceptions occur method also consider whether handled within method changing signature
return METHOD_2 null ac3equalsMETHOD_2 a52containsMETHOD_2
METHOD_4 makes sense called _CODE_ beginning METHOD_3 method null wouldnt arrived code The prMETHOD_3ile parameter meant nonnull
Minor nitpicking weird order parameters reversed 2 lines
Perhaps case returned true empty list returned _CODE_ without creating new one
could simplified
Was intended commented
I familiar serialization process hotrod couldnt pass string either way The error case null right
Just add envelope section METHOD_5 method file
Why use _CODE_
I sure necessarily error Should log info level
Just use normal facilities public Invalid String message super message _CODE_
Seems like judge null VAR_5 since normal response called _CODE_
The first iterator method _CODE_ signature public synchronized TYPE_1 _CODE_ query Then people added iterator methods synchronized I think methods use connection synchronized means one would need synchronized iterator methods call one dont need
Im sure could cast I think usually write suggestion TYPE_4 VAR_7 new TYPE_4destination
shouldnt Users automatically friend peergos signup
Hrmmm VAR_1 null usually mean binary protocol
_CODE_ _CODE_ enum use event _CODE_STATE instead using equals method
Should _CODE_ value converted String instead float help avoid risk losing data If need convert primitive I would suggest converting double instead The goes equivalent _CODE_ method
_CODE_ Please look
useless semicolon formatting
It new constructor
Addition member variable looks unnecessary undone I think
Is test passing wrong type creating typed query
Unecessary parentheses
My bad needed
Remove diamond operator
enabled restore
The VAR_2 check come call METHOD_2
I dont think thats really required extending _CODE_
This wrong
You go one step simplifying rule Change method return boolean _CODE_ return _CODE_
nit Nullable _CODE_ TYPE_3 VAR_3
needs overridden subclass
So looks correct I still dont see reason k variable For And I would prefer loop like equivalent loop much clear java int _CODE_ _CODE_ 1 _CODE_ j valuesi
This sleep necessary
No need explicit null checks The parameters marked _CODE_ engine apply default semantics null found
This list alphabetized look order events _CODE_ class listing
It would good add http link language reference
Oops
I would expect annotation would overrule default even smaller
method reference used instead METHOD_2 _CODE_
_CODE_ Tu pourras donc aussi enlever le import de TYPE_3
Why behavior changed It used _CODE_ _CODE_ waits instead Is true
Add final keyword keep consistency
afaik _CODE_ never returns null
I able find use case File Save menu enabled So Im wondering theres Also line 37 calling shell menu File Properties clicking _CODE_ This seems needless operation
minor flip VAR_2 new _CODE_ publicAccessLoggerappendVAR_2toString Also VAR_2 String It never appended
Rather VAR_2 might better straightforward controls Something like _CODE_
Minor Can use ternary operator
Nullable useless variable nullable
If directory doesnt exist bak file wont exist statement removed replaced check make sure directory exist
This method returns primitive long need boxing Same method like
Why add Systemoutprintln call Maybe logger better solution
Shouldnt _CODE_ state
pass directly VAR_2 TYPE_3 constructor make copy internally
result also _CODE_
Maybe also test repeated key Should Just Work
The output contain something like dependenciesaddAttributesManagerNS_FACILITY_ATTR_DEF _CODE_ dependenciesaddAttributesManagerNS_FACILITY_ATTR_DEF _CODE_ Disallowed crosschecks modules peformance reason dependenciesaddA_G_unixGID_namespace dependenciesaddA_R_unixGID_namespace dependenciesaddA_G_unixGroupName_namespace
Hi treblereel build failing due line You comparing VAR_1 Looks like bug You check locally executing mvn clean package Dfull see details bug use mvn spotbugsgui
Remove replace nCopies253 1
_CODE_ p unnecessary
The Override line
useless cast
minor rename keys without _CODE_
You remove parentheses around _CODE_ 0 longer needed java _CODE_ _CODE_ 0 VAR_2
params final private much issue
public
wanted different previous _CODE_ called testVertexCentricQuery10000
nit VAR_6 variable may avoided
Cosmetic Please always use braces around conditions loops Thanks
change really needed
Shall throw _CODE_ least put assert
_CODE_ Severity _CODE_ Missing curly brace rule _CODE_ Severity _CODE_ At one statement allowed per line 2 statements found line rule
combine assignment _CODE_ _CODE_ type required
nit make methods packageprivate class packageprivate well This also ensures expose mistake point
private boolean
To remove replace logger
Might well declare final Same BORING_PREFIX_THROWABLES
For variables using one place remove use actual value one place
You remove jnlp used anymore
Here delete instead setting end_commit_id The following 2 cases may issues 1 _CODE_ line 105 _CODE_ called _CODE_ place presto get chunks If called twice transaction good But called maybe fine 2 _CODE_ line 205 _CODE_ VAR_2 filters end_commit_id So rollback delete rollback chunks index index less chunks
Same
We dont need impala hdi35 Cloudera
Same remark _CODE_
nit keep _CODE_ U capital
Can remove line No printing sysout please
If anything file directory check necessary
iirc TYPE_1 doesnt declared exceptions wrap runtime exceptions another runtime exception
We move line 290 inside well
Couldnt actually depend class generate name
VAR_4
We extra logging In original code log message process Killed
Please synchronize
Does synchronized What isnt threadsafe
Will mock work Same tests
Dont create temporary VAR_5 array Use _CODE_ instead
Should _CODE_
nit braces around single line conditional seems convention file
Im afraid equivalent VAR_1 null doesnt return false VAR_1 _CODE_ I suggest VAR_1 _CODE_ return false else return VAR_1 null
nit put around statement
You dont need keep keeping copy cluster VAR_1 somewhere inside good
remove
Baseclass Kommentar
I dont think right way fix issue described Were returning correct TYPE_1 caller method leaving cached instance old result metadata Rather java _CODE_ _CODE_ return VAR_2
I doesnt really matter nitpicking local vars noninitialized Good practice initialize defined value But sure doesnt matter since code right
Since take care null entry Id use Nullable well text
Use descriptive variables intent
idea used return new Object vs avoid strong references
Is parameter concept id uuid
nielsbasjes Is makVAR_1g method public really necessary Do need expose method VAR_1 public _CODE_ Cant package private
You return directly would make else redundant return directly next block
_CODE_
static import METHOD_2
_CODE_ _CODE_
Minor maybe VAR_2 VAR_1 common order Here places VAR_2
I guess _will_ allow variable null planning use placeholder kind
needed
since Javadoc
Could use
Nit return VAR_1 null VAR_2 VAR_1
The reason _CODE_ _CODE_ comes final String _CODE_ _CODE_ The _CODE_ _CODE_ null
Code smell clarify contract repository regarding emptyness
Better _CODE_ use try return _CODE_ finally _CODE_ This better longlived _CODE_ dont exit properly
What Im missing check element null I know probability low still
nit _CODE_ complaining raw types return new _CODE_
use new _CODE_
final
_CODE_
Please use _CODE_ TYPE_1 instead wrapping first using METHOD_2 The end result avoids one extra traversal type structure somewhat faster Details case care When calling GenericTYPE_1ReflectorresolveTYPE_1AnnotatedTYPE_1 AnnotatedTYPE_1 contextTYPE_1 first gets generics expanded Class type parameters gets wrapped ParameterizedTYPE_1 calling _CODE_ TYPE_1 done time TYPE_1 wrapped AnnotatedTYPE_1 one traversal skipped
Had offline discussion Aman remove check serialize everything using METHOD_3
As method return null value I suggest either annotate _CODE_ make return Optional
dont pass intial hashcode _CODE_ instead mix various hash codes Guava _CODE_ help
Logging using standard output
I propose following code _CODE_ VAR_2 new Array_CODE_ VAR_1 null String VAR_3 VAR_1 VAR_2addnew _CODE_ VAR_3
You compare x null since could already different attachment VAR_2
Why empty string null
Now query using parameters dates still need format strings I believe parameter replacement handle dates asis long theyre using _CODE_ _CODE_ type
There reason formatting changes
nan
Remove
formatting
_CODE_ please add strength creatable properties
I dont really like mixing TYPE_2 oldstyle nullable parameters Id rather use null Or TYPE_2 course
Remove
Use _CODE_ variable declaration always use interface declaration implementation instantiation
cuenyad add final
Nullcheck missing
Missed space
Ты теряешь исключение VAR_3
This private
inline
We moving exception catching try area Is intentional
effective way sorting _CODE_
_CODE_ would use thisusername VAR_3 null instead
Do need guard null well
In case comparing int easier java _CODE_ _CODE_ throw Failuresinstancefailureinfo _CODE_ VAR_3
use list anymore
Could use MediaTypeAPPLICATION_JSON_VALUE instead String constant Thanks
No need change
Should METHOD_6 part finally statement
Local variable final needed Is _CODE_ configured differently checkstyle
sure context TYPE_3
need METHOD_11 finally block
Do need guard
As I looking code necessary wrong maybe would better throw new VAR_6 end method Its prefer
VAR_2 TreeKindCONDITIONAL_OR
packaging default need
Shouldnt negation
Exactly Thanks Oh please move line top method Logging error first statement imo
More intuitively named METHOD_2 static
Instead checking null pass _CODE_ instead null constructors
Redundant
Should really
cant lines 149150 combined
I think public _CODE_ called Builder
Isnt correct thing java _CODE_ VAR_1 _CODE_ null properly handle replacement
null instance String check redundant
need null case
May factor calculation Please see comment
argument order seems bit weird Id VAR_3 VAR_2 value VAR_2 value VAR_3
_CODE_ METHOD_1 User name field populated VAR_1 true VAR_4 Remember spaces String put trailing seperate line Remove VAR_4 TYPE_1 need take screenshot
Just consistency could please use final String VAR_2
All methods could private Or class call shouldnt also Transactional
Outside synchronized No reason take lock return
Better doesnt contain VAR_1 add return anyway
Split multiple lines
What line mean
Those tests would hurt
I think check done joins _CODE_ _CODE_ maybe Logical planning stage add outer join support Calcite planner
VAR_13 VAR_13 node
Another one
Can remove empty lines
Why think behaviour right
unrelated issue METHOD_1 method probably synchronized
Can one line doesnt need throw TYPE_2
change arg name VAR_2 attributes also
What idea behind checking whether keys map null This applies tests
This removed
Use final wherever applicable Perhaps style code work properly
sure looks like _CODE_ checked twice also checked even _CODE_ disabled
two public constructors
Why need change I dont see constructor used outside class
Thanks Andrea javadocs change wise I tried use path consistently string used File file expected Your original stack trace check path validity intended catch code passing windows file system paths old macos paths file system paths
nit add final well
directly put commit end Editor calls always return Editor
Please use getter
As negating result using function itd better avoid doublenegation returning result directly
public
From _CODE_ Delete identified _CODE_ Scheduler associated _CODE_ METHOD_4 looks unnecessary
seems odd _CODE_ property item queue I feel makes sense property executorservice What instead passing VAR_2 flag give VAR_1 sequence number The executorservice decide whether pass 0 time pass actual sequence numbers also simplifies _CODE_ always use comparator regardless VAR_2
make call inline new _CODE_ VAR_2
Stringformat longer necessary
static import VAR_2 error
This raw type please use parameterized type _CODE_
Can set false declaration
The message consistent condition since _CODE_ planned precondition met It looks like place _CODE_ called without preceding call _CODE_ _CODE_ However method possible directly call _CODE_ return value earlier call _CODE_ If done changes needed
This max rows disagrees assertion test failing
I think array vararg
If add log message logged user get information Please move log call front _CODE_ call
Minor Maybe better call thisnodes VAR_2 VAR_3 null remove duplicate codes
The canonical way write avoids repetition METHOD_3 It little bit less error prone String line line linesMETHOD_3 null outprintlnSTEP_SCENARIO_INDENT line Aside looks good Dont forget indent code properly
There whitespace around Also good enclose blocks ifelse
You always generate message process done You prevent unexpected issues
already done 3 lines
This rVAR_3try loop could bVAR_3 pushVAR_3d thVAR_3 METHOD_2 implVAR_3mVAR_3ntation gVAR_3t closVAR_3r thVAR_3 _CODE_ That way add nVAR_3w VAR_3num typVAR_3 _CODE_ chVAR_3ck bVAR_3forVAR_3 wrappVAR_3d This also prVAR_3vVAR_3nts thVAR_3 thrift typVAR_3s sprVAR_3ading far away thVAR_3 _CODE_ codVAR_3 SomVAR_3thing likVAR_3 thVAR_3 following METHOD_2 would work java boolVAR_3an rVAR_3try falsVAR_3 try fatVAR_3 _CODE_ calls hVAR_3rVAR_3 catch _CODE_ VAR_3 switch VAR_3gVAR_3tTypVAR_3 VAR_3xisting codVAR_3 casVAR_3 BULK_WHILE_CONCURRENTLY_MERGING_SO_RETRY pick bVAR_3ttVAR_3r namVAR_3 thVAR_3 VAR_3num log msg rVAR_3try truVAR_3 brVAR_3ak VAR_3xisting codVAR_3 whilVAR_3rVAR_3try
This VAR_2
Im sure indirection business buys us
cant pass VAR_4 directly
Instead assigning variable update variable _CODE_ method
Close needed use trywithresource Whats wring _CODE_ method I feel name clearer
looks like syntax typo Add position checks _CODE_ commit
One things like others This strategy factory doesnt fit others Its one uses VAR_3 Its one calls _CODE_ Its one _isnt_ created helpers _CODE_ Its one isnt wrapped _CODE_ Also even used fully implement type strategy value matchers Long handling still goes different code path Is possible clean usage strategy factory bit It would great allowed us remove VAR_3 VAR_2 also make _CODE_ private function
Is really necessary I thought _CODE_ doesnt allow user override data conversion Also fieldparameter names include Conversion key value bit confusing
Wrong place This done _CODE_ method originally
Add new method like _CODE_ filter Thats good idea list applicable classes codes
These two lines probably _CODE_ thislistenersaddVAR_7 case cant METHOD_4 VAR_7 whatever reason
Rather creating compressed key decompressing shall use _CODE_ compressed constructor first place
I would execute try VAR_5 already set Given way code currently written Im concerned repeated throws tight loop
We test different node update
still needs synchronized doesnt
nit No need declare exception types calling _CODE_ directly
Please use _CODE_ instead INT_1
condition dropped
I dont think want What probably meant rename _CODE_ rename delete VAR_1 External classes call method bypasses important things done delete Same applies _CODE_ public
Lets remove behavior _CODE_ affect indicators
Comparable allow null values
METHOD_5
We could get rid checks VAR_1 use _CODE_
In order completely cover cases add method 3rd class extends Action unused parameter one struts types This raise issue
Left debugging
It necessary crate TYPE_7 _CODE_ Only _CODE_ mech requires TYPE_1 METHOD_1 _CODE_ client passed configuration
dont need Just refer _CODE_ places
named resource
1 confusion suggestion _CODE_ start last one
You set plain field need atomics java thisVAR_1 VAR_1 _CODE_ VAR_1requestLongMAX_VALUE
Hii ribhavsharma extra brace causing build fail kindly correct
I almost feel factory approach coming _CODE_ etc So abstract Renaming nice btw explicit VAR_1
braces please
use VAR_5
This bug The requested VAR_1 might list decrement true remove
It matter use equals
I havent digested important part yet _CODE_ visibility change needed
minor _CODE_
suggVAR_5stion catch TYPE_3 TYPE_4 VAR_5
For lot uses method _CODE_ It doesnt need _CODE_ null checks ones handler changing state true _CODE_ It important code modify parameter accurately reflect whether caller intends make modifications object reachable directly indirectly returned link _CODE_ This includes modifying link _CODE_ link _CODE_ link _CODE_ object reachable value param modify code true operation may modifying object reachable directly indirectly returned link _CODE_ code false otherwise
VAR_2 getting voided redundant
We encounter type one VAR_2 return found Same thing
It wont get throw statement
Does need synchronized set
VAR_4 specified param
Default access probably good enough consistent _CODE_
I _CODE_ using _CODE_ METHOD_3 I agree try stick one method code loggers
Add cause log
Can _CODE_ null
This method recursively calls result stackoverflow Is ok
useless parenthesis
need public nonpublic class
create new empty exception reuse old one
Is reason separate statement instead VAR_1
Is reason explicitly set default
size looks like longer needed
TYPE_3 TYPE_4 removed
return _CODE_ 1 dataget0
Do want expose caller Ie allowing skip Instrumentation Im thinking may want So make protected test classes still call
Public methods package access classes seem little strange
Remove property
Might well use null almost commands use supernull _CODE_ constructor
suggestion _CODE_ TYPE_6
remove The factory default supplier default behavior
synchronize VAR_2 zero VAR_7 may run VAR_5 futureis set
suggestion return new _CODE_ _CODE_
I prefer else instead return
It would make sense check minimum values well
You use _CODE_ boolean VAR_9 false VAR_9 specified spec
Instead passing parameters please use arguments see This prevents issues system recreates fragment app background example We use _CODE_ pattern parts app would also consistent
Why METHOD_3 done METHOD_1 Shouldnt done start publish operation like _CODE_ something My concern done publish may buggy For example User changes Samplewar _CODE_ called _CODE_ called You copy new changes Samplewar METHOD_3 end overwriting changes Not sure correct current concern
Im test I dont think test sanitycomposition _CODE_ anywhere else My personal vote would omit test previous test simply verify something like assertNotNulltoTest_CODE_ But curious hear others say nacx abayer andrewgaul
Here well We need replace equivalent _CODE_ mock
first line function instead
A check needed beginning method make sure VAR_3 null
Think needs go right line 91 VAR_4 return null line 133 cause future never complete
protected enough
return _CODE_
Perhaps switch store check
shouldnt need TYPE_3 extends TYPE_2
boolean
VAR_6 probably set make VAR_1
What finished mean VAR_4 It seems mean scheduling finished ungrouped execution execution finished grouped execution
Constructor needs private
So aligns rest codebase lets remove final keyword
meaningful parameter name
If _CODE_ METHOD_4 activated thMETHOD_4 throws _CODE_ I recommend add _CODE_ statement
hardcoded value instead argument
null checks
also final
minor also converted new TYPE_5 sleepSeconds5 _CODE_ start
I wonder instead summing across collectors collector reported separately This would enable visibility example young versus old generation collections
You able use diamond operator ie new TYPE_3
Shouldnt already normalized _CODE_ constructor
missing braces
flagging fix next major version move back parameter id
If VAR_1 diff null VAR_1 must equals VAR_2 If VAR_1 null return VAR_2 _diff than_ null I think second part wrong
Could save variable declaration set directly passing string method call
sadly class doesnt serialization version id im willing break pending jobs change please make change doesnt break current serialization signature
What different slash directions mean
Could VAR_6 ever return null
_CODE_ Make METHOD_1 static method rule
Systemerr _CODE_
use else ternary
As whether draining good idea
You compare users equals method
nit 1 maybe check merge constructor one making caller pass empty TYPE_3 list 2 VAR_2 VAR_6
Why private
trim use p Hellonthere p wouldnt I want everything inside p html node
No need thisurl enough
If TYPE_2 null really want drop VAR_2
I find VAR_3 VAR_4 confusing Is possible cut VAR_4 would always false Kafka indexing
vmaletta add final
suggestion
I think trim METHOD_5 method
suggestion _CODE_ instanceof TYPE_3 instanceof already checks null
Something else I missed I know important dont set type creating new objects We use diamond operator new TYPE_3
Can super TYPE_3
Could simplified suggestion _CODE_
Here ordering data types _CODE_ however take look using _CODE_ function default data types So I think correctly ordered
consider making static
METHOD_3 reason anymore METHOD_5
If purpose moving around please leave
please add braces around statements suggestion VAR_3 null return false
nit merge lines _CODE_ return given argument
This bloc code repeated many times centralized single method
Theoretically accessed multiple threads Is okay If truly want singleton maybe revise
Need careful We cant always assume classification problems Maybe use 1 last dimension instead
Can initialise instance declared
Very minor bit redundant
So services except specific _CODE_ interfaces like _CODE_ return _CODE_ expose underlying storage model outside service tier The reason Jpa specific interfaces existed allow interplay _CODE_ services inside transaction Entities still attached state within _CODE_ could add collections This means like tags create tag entity return use say job link attached tag entities job one shot rather going _CODE_ quering back _CODE_ attach entity within _CODE_ service I explain person doesnt make sense The main point shouldnt bleed underlying data model details case Entity consumers service
Why need _CODE_ _CODE_ _CODE_ Is optimization If I think isnt needed
better use name instead null
cant make method handle static field
VAR_3 unnecessary
Instead using exception could return default value
There usage path right change isnt necessary
mpaladin I would rename VAR_1 _CODE_ explicit comes
make TYPE_1 comparable I mean TYPE_1 implements Comparable interface
Same remark VAR_1
Looks works _CODE_ hard read I would rather see better readable return
This seems esoteric Whats wrong 00
Reduce logging level debug trace
chaviw check VAR_1 null
private static
Is change still needed
Could simplified returning immediately null would save indent whole block
Lets call _CODE_
another class named _CODE_ wondering delete class use _CODE_ indexing service also
change loop The caller already knows scan state equal state since private method safe assume caller already checked lock wait state change
open
set twice
Same remark
You remove empty line
duplicate assert
Can switch VAR_5 boolean You RequestParamvalueVAR_5 _CODE_ false boolean VAR_5 spring translate appropriately The service take boolean instead string well In case youll want admin unit case pass false
would better define lamba functions variables help understanding going
Use _CODE_ instead Array_CODE_ declaration
Second VAR_3 check necessary first one
matter taste rely autoboxing
Shouldnt stream openVAR_4g statements VAR_4side try resources suggestion try VAR_3 VAR_4 new VAR_3 VAR_5 new VAR_5VAR_4
format code pls
Use trywithresources please
The variable name probably something like _CODE_
new _CODE_
This condition combined
Unneeded local variable put constant value method couple lines
Looks like temporary testing code
We able test even update test fails
would _really_ prefer single return path I find multiple return paths inside nests quite confusing Unless alternate single return path really complicated would prefer
return index 0
nit maybe make constructor protected although I dont see real issue public
This kinda duplicate already VAR_1 METHOD_3 method particular reason VAR_1 another element
private static
I think sync order threadsafe
This really versionCounterset0 This race condition _CODE_ method invoked time could possible _CODE_ operation doesnt work properly get returned value incremented _CODE_ occur causing missed reset
Why use equals Please use equals
Ah thanks I would return directly java return searchcontext VAR_6 VAR_9 VAR_10 VAR_11 query null null start size So leave absolutely zero logic deprecated function
Declare final static
Please swap order private static like google code style guide
Can use junits Ignore annotation link github issue bumping compiler Something like Ingore
This created Guice injector Make constructor protected
return method null
VAR_3 seems convention constant variable I suggest move method add private along static match java convention
We omit null since overload
_CODE_ I wonder still need check VAR_1 null empty
Move line trycatch avoid error due METHOD_1ing METHOD_5 closed METHOD_1
No need use local variable
suggestion VAR_1 _CODE_ I dont think cast necessary
Move please
Revert class
Is useful _CODE_ level This could lot text log
No need create VAR_1 assignassert The code never reach point
put TYPE_2
Why necessary
Would nice test _CODE_ format _CODE_ value well
nan
im sure deciding update entrylogmetadata Isnt supposed updated change entrylogmetadata right In current code current argument VAR_3 value true isnt going update even change entrylogmetadata
You able write Testexpected _CODE_ body test line causes exception
could case insensitive check well minimize risk catching
зачем нам эти параметры
Just realizing TYPE_1 dont need check contained inside first
VAR_1 protected I dont think need access via accessor
Isnt Object
Actually part throw TYPE_2 Just remove throws TYPE_2 good Beware spaces vs tabs Prefer using spaces indentation please
VAR_6 true shouldnt set null Whether send session could determined whether VAR_10 null rather adding new property It would also reduce odds unexpected behavior _CODE_ called configuration
Does need final
I think could avoid use reference fields unit test name conflicts
Small change With code null byte TYPE_2 input cause thiscontentMD5 null invoked In previous version null input would cause nothing set I guess default value field null effect
Looking _CODE_ class maybe use return _CODE_
I think use diamond operator
Ok Im going get picky Since youre returning block need else block So context null contextMETHOD_1 null want contextsensitive behavior METHOD_1 Otherwise weve already precomputed _CODE_ index return superiteratorname context return iteratorname
wouldnt enough one null
useless empty lines
Why make method chain throw exceptions stack bury end If never intend handling exceptions handle inside VAR_1 method calls cleaner
thread safe
If VAR_12 cannot null VAR_12equals
public static otherwise sonar complain
No need use _CODE_
You filter filter enabled Please careful test code submitting anything
janosss We could probably change _CODE_ defined class return TYPE_6
Justin spaces
string renamed key
Calling null fine
qeesung nit merge 2 lines METHOD_2 returns VAR_1
take look _CODE_ think theres rx observable subscribe refresh sure right place subscribe worst case object subscribes whenever least one active widget
fmt wording eg Cassandra connector currently support create table run simplified test
VAR_2 longer needed method removed
nit drop
VAR_2 email seem redundant kind user _CODE_ Author seems sufficient purpose If someone needs information maintain separate table enforce foreign key relation database level
Maybe add default case And looks like could collapse return trues one
Question scenario lead null _CODE_
Do inline code
need add message METHOD_10 location
This check rely semantic
comments presenters
Using static map would easier
Why array necessary It looks like ever one item
unnecessary null check
This wont required following constructor kept
Note METHOD_4 method throws _CODE_ instead returning null VAR_3 isnt found Please create test case verify behavior
Better use Assertfail
redundantarraycreation
Can VAR_2 put case insensitive _CODE_ Then nested loop could converted contains
Do callers need updated
Why change METHOD_2
Does checking METHOD_2 Object really necessary If I remove tests ok
It better remain original code The fetchcreateput action atomic Or every thread replace others
пусть будет первым аргументом конфиг тогда чтобы было очевидно что регается
The _CODE_ takes care assert We dont need extra
Im surprised jomarko didnt report Itd consistent use Objectsequals three checks
This initialized line 97
I guess task never null _CODE_
Use _CODE_
This easier read int 0 idssize i0 _CODE_ _CODE_idsgetLongi
Can please check verify _CODE_ computed means processing every production definition Otherwise might work expected
_CODE_ looks better
_CODE_ ThMETHOD_4 branchs code block METHOD_4 block branch line 293 rule
put force option error message otherwise everyone use
Strictly speaking _CODE_ change _CODE_ thats ok
explicitly mark METHOD_4 _CODE_ thread looks like method always called main thread
Why dont move _CODE_
VAR_4 never null
Missing space 1
suggestion private String METHOD_1
closerregisterexecutorshutdown
nan
Why check 0 I mean specific value 0 Since constructor could set VAR_7 INT_1 Even better dont hardcode magic numbers use DEFAULT_SHAPE_OUTLINE_WIDTH constant define value INT_1
oclose start 16 length 10 needed
VAR_2 instanceof TYPE_2 Why Redis Sorry Im sure whats going Just explain please Thanks
yesamer This removed I think
1 Instead assigning different value VAR_2 constructor please return formatted string _CODE_ method This might want use original VAR_2 purposes internal log output 2 Since youre using Stringformat VAR_2 made part format string consistency ie java Stringformats 1dx2dx3d VAR_2
suggestion T VAR_2
I find METHOD_7 bit confusing get
Should allowed
new line
Maybe use simpler
Can get information magic numbers
comment
I dont think We need set flag cache reaper Otherwise get removes expired entry wont remove entry shared store possibly
inlined think
Remove
TYPE_1YPE_1he attribute type needs exact suggestion public TYPE_1YPE_1 TYPE_1YPE_2 super TYPE_1YPE_1 getTYPE_1YPE_2ClassTYPE_1YPE_1 attributeTYPE_1YPE_1ype
You start counting bytes 0 check correct If VAR_1 8000 8001 bytes written
protected
TYPE_3 constructor called _CODE_
Override public void _CODE_ VAR_1 throws TYPE_1 putSharedDataCURRENTLY_RESTARTING true superrestartVAR_1
method needs return true journal VAR_1 handled
Rikkola throws TYPE_1 really necessary
This correct The VAR_1 like foobarvaluebaz With meaning evaluate template part concatenate rest strings See _CODE_ _CODE_ Also doesnt make sense deprecate private method The point log warn templating deprecated Nothing context variable
redundant parentheses
This private unless plans use outside class
niggle think switchcase _CODE_ default would readable
missing else
Can ctor reference like others It looks like
please use different name method compile
If add version check inside defaultrecordstore client initiated operations also caught
This check bit confusing To reads If VAR_1 metadata table root tablet use root tablets configuration Otherwise use metadata configuration Is setting user tables thats appropriate _CODE_ already returns whether metadata table root tablet VAR_1isRootTablet redundant However I think refactoring _CODE_ appropriate make clear checking
TYPE_1 thrown method
moved code METHOD_1 If dont plan use close _CODE_ needs implement closeable
condition incorporated loop
If VAR_3 instance _CODE_ obtain _CODE_ Moreover _CODE_ seems valid even VAR_4
question
This gonna delete old label scan store used nice thing In time gonna create new index part migration guys people forced wait startup expecting everything ready fly I know proposed behaviour differs time something complaints recent past well sounds like correct thing _CODE_
return new _CODE_
There still lot calls method resulting errors reference _CODE_ element From quick look many element id could reference
static 3 methods
_CODE_ VAR_2
Can pass null instead empty listener
See comment
This case default
0 args 1 arg
This method isnt accessor lets call count instead
What contract return method If already state trying move could said VAR_1 successful ie true
Please add final
I would replace statements _CODE_
likewise
unnecessary throws constructor
Можно упростить return VAR_2 VAR_3 1
final _CODE_ _CODE_
This eventually emit _CODE_ Is consciously wanting handle error individually instead via composite
Note old method constructor signatures need left intact ensure backward compatibility Obviously using old signatures would mean new functionality cannot used
You dont need check null Task triggers callback canceled anyway If problem still exists Crashlytics tell us
could made final
Braces correct set double encode expression It moved code fixed java _CODE_ null _CODE_equals
We could initialize VAR_4 RollupTypeBF_BASIC beginning method right Its little cleaner stands reason
VAR_1 vs VAR_2 mutually exclusive I wonder could give input constant like USE_LEGACY USE_FOREIGN Then value would opposite Would make bit clear tests setting
define _CODE_ INT_1
add curly brackets statement good practice dont end weird bugs future
This static technically
This doesnt wrap nest arrays It returns array recursion base case
This class supposed threadsafe ideally immutable Id prefer thistags Guava _CODE_ initialized constructor
reason static
I dont think matters strictly speaking youre passing name explicitly I think _CODE_ parameter false
This isnt going return null would better wrap METHOD_2
Optional compact way possible VAR_3 new TYPE_2 _CODE_ creating directly attribute instead constructor
Looks like could removed
I dont see references setter restore class This class meant constructed appropriate values creation Maybe properties file could support different serial settings used _CODE_
For consistency rest code please prefix member variable references
This make sense since METHOD_1 final would think suggestion thisname _CODE_ So readers code fewer methods jump understand code
Im sure sorting _CODE_ The reason METHOD_1 returns TYPE_1 rather Set likely original call site notready command fed utility method stringifies TYPE_1 So probably past laziness anything P I think makes sense sorting caller site rather If nothing else reduces blast radius pull request keeps changes collected signsrendering code
It appears though add nullcheck safety Ideally would actually prevent METHOD_1 progressing actively running state I dont think case currently
Can VAR_3 null
можно просто не указывать настройку sentrydsn либо явно указать протокол noop он используется по умолчанию думаю не стоит поверх этого наворачивать ещё какуюто нашу собственную логику даже без явного вызова Sentryinit сентри все равно будет автоматически инициализировать клиент и искать dsn в параметрах jvm или энвпеременных поэтому доп логика с none может привести к странному поведению
return new _CODE_
This small nitpick maybe equals 1 based VAR_4al Or thinking would give better spread since VAR_2 always multiplied INT_1 VAR_4 never multiplied
Why
Does make sense try delete server even shared storage delete operation failed We try avoid leaking resources
The VAR_6 use heuristic avoid active1 standbyINT_1 activeINT_1 standby1 since two instances failed time lose tasks large numpairs possible means case would likely happen So active task corresponding standby would still appear pairs sure means new math correct Eg lets say three tasks A B C A standby others two numreplicas INT_1 An assignment _CODE_ _CODE_ _CODE_ _CODE_ _CODE_ _CODE_ _CODE_ would still generates three pairs _CODE_ _CODE_ _CODE_ right In ways VAR_5 used initializing hashset decide whether exit early I think setting larger values would matter much
Please check fragment exists It could lead nullpointer exception
There assignment VAR_1
VAR_2 return null
This removed
This never null given code _CODE_
needed method
Id prefer keep TYPE_2 pojo class move method utility class prod test code call
add _CODE_
We use diamond operator
inline METHOD_1
ifelse transformed simple assignment
_CODE_ caller check fact callers already
Map List
Use _CODE_ instead
nit merge lines METHOD_1 return given argument
VAR_11 always null
Rather preserving constructor unit tests create replication factor explicitly call _CODE_ Then maybe parameterize assert nonzero _CODE_ produces results
dont need else Too bad java doesnt _CODE_
nit dont need return false line
Instead Suppler use String parameter It doesnt make sense use function _CODE_
I would suggest improve readability changing ctxinventoryselectsize ConstantsINVENTORY_SIZE
_CODE_ _CODE_ implement _CODE_ odds replace _CODE_ _CODE_
add existing constructor breaking change keep _CODE_ required parameter
The return value ignored
This method seems thing previous line
boolean instead TYPE_1
need wait
This always pick VAR_1 seems intended
What think reducing size method using ternary operator several returns Something like java _CODE_ return VAR_3 null VAR_3 _CODE_ else return new TYPE_3
return
This change required since duplicate parameters passed _CODE_ application _CODE_ We passing information using _info TYPE_2 type object DrillConnectionImpl_
I think check otherwise based type operation quorum quorum needed The current implementations almost free future implementations METHOD_2 methods logic may waste cycles unnecessarily regardless operation quorum type eg _CODE_ VAR_3 quorum
Missing brace
Can get around instanceof somehow Should generally possible METHOD_2 TYPE_1
One suggestion might useful put TYPE_2 code since special case attribute I dont know whether would cause issues elsewhere though
Unrelated change
Is reason changing order chained constructor If could add new parameter end list
use Guava Optional
Keep order definition _CODE_
You wrap weird checked exceptions like VAR_7 unchecked _CODE_ This means dont need modify bunch unrelated classes throw
I think protected package access
What point logs Flag service processing debug _CODE_ would outputted
Delete used
This contextgetCapabilityServiceNameSECURITY_DOMAIN_CAPABILITY VAR_18 _CODE_ What works critical need fix changing class anyway things robust let VAR_2 things things
If queries covered _CODE_ maybe could remove
name stringify enum
From end method _CODE_ could rewritten java return VAR_1exists _CODE_ VAR_2 VAR_1
Yeah Im also sure needs extra sync
spacing
nit bad alignment
minor rely interface rather full type
These methods associated commands datadogagent stuff like datadogagent jmxfetch listmatching expected print stdout always debugging command These _CODE_ changes unless Im missing something would make subject log level thus potentially breaking agent commands If going keep probably info warning least still maybe preferable print stdout
Even copied fix thism_ references
Should check chunksget0 exists
Put logic _CODE_ together METHOD_4 discussed
Is really needed Maybe removed efficiency reasons I dont know often method actually used
need check You argue statements methods
Perhaps extract delete method
Have merged master I thought I fixed include exception message I mightve pushed yet lets make sure exception alert That please make edit I havent pushed Ill deal conflict creates one
Same
shouldnt VAR_1 TYPE_1 Either none actually I dont think really need introduce TYPE_1 caller careful METHOD_3 calling null value
remove
attribute TYPE_2 final TYPE_1
Use instead switch 2 options
I guess return TYPE_1 _CODE_ clear
Does make sense leave _CODE_ private method They really used potentially causes confusion lane something changes
chrome I would run test firefox
Move METHOD_2 checks separate line Calling inline looks messy
minor need add explicit type argument
static import Base64encode _CODE_
need synchronize value VAR_2 immutable
You remove line done _CODE_
In Blast Furnace removed _CODE_ check kept
Not sure replaced I prefer matter taste needs revert
Id go original version I find easier read called often
Need set prefix Effective Java 2e doesnt I slightly dont like recognize Im oddman
Not sure id go events yet Model upgrade emitting events either Status flags change would properly set Lets go baby steps introduce events yet unless good reason mentioned need
must immutable null thismap thismap else throw new _CODE_ add also _CODE_ would really appreciated
return TYPE_1 TYPE_MANAGERgetParameterizedType _CODE_ _CODE_ _CODE_ _CODE_
I thought changing METHOD_1 put big change current change doesnt break existing behavior looks goodsafe nitpicking ifelse might straightforward
unnecessary parens around VAR_1 null
might want use constants constant left side SYSTEM_FOLDERequalsgetAssetName
Any reason using _CODE_ instead directly accessing
Never used
int _CODE_ n
Goal get usages VAR_1 This means node needs become observersubscriber VAR_5 maintain references _CODE_ VAR_15
shouldnt values METHOD_2 null help _CODE_
Why needed And places addedremoved castsgenerics
cast
Same hereone thing Ive noticed location null _CODE_ exceptions get thrown We probably check null
I dont understand testing field name empty Shouldnt removed
This probably return VAR_2 prevent cycling step size back zero And return VAR_3
wonder put null exchange make reading easier If dont worry
I believe line incorrect removed
public _CODE_ cant lower visibility without deprecating first
redundant call super automatically inserted compiler Also class child Object
Looks like keft one
This already covered line 524 isnt
Same The new flag VAR_5 passed used _CODE_
Same public
suggestion return EXCLUDED_EVENT_TYPEScontainseventgetName ACCEPTED_COMMENT_TYPEcontainsdocType
Id initialize builderheaders METHOD_5 clear cp
Not sure really readable previous version
Why change visibility METHOD_1 case
Please consistent final parameters
pattern null
Adding new constructor parameter would breaking change unfortunately The way around create new constructor takes VAR_4 additional parameter deprecate existing ones
Minor change log line url correctly reflect _CODE_ loaded
nan
static import
Race condition Two fragments call method find functions Both dont find function Both get remote functions simutaneously Should synchronization remote checks either serialized limit number resyncs per unit time
minor appears TYPE_4 could singleton
Use thisrun VAR_3 null avoid code duplication
nit inline
Looks like two things happening inside The node scanning could possibly thread scheduled interval
If context turn completions return new VAR_1
Revert VAR_1 nonnull _CODE_
reason instance field could static final
nit Druid code convention like _CODE_ _CODE_ _CODE_ sum
Should change moved 1763
I assume implementation would likely call _CODE_ _CODE_ comes following _CODE_
Again either update spec refer method Also additional user VAR_2 since VAR_2 would nonstandard
Typically I Spec visible factory methods instantiate Is purpose let created directly enduser level
int VAR_3
The code says otherwise It looks like fixed one spot
This assignment could removed
This duplicated remove
Error closing METHOD_3
It doesnt appear assertion necessary
Remove whole block l4954 since moved static initialization
This doesnt look right Shouldnt _CODE_ null
I think TYPE_1 suffix omitted methods name
This minor nitpick VAR_1 null datacontainsValueVAR_1 much efficient VAR_1 null programming languages handle _CODE_ using short circuit logic
VAR_8 might null Although I agree thischannel fully depends AsyncRabbitTemplatethisVAR_8 lets modify avoid noise potential_npe By way would better provide message anyway It used event downstream _CODE_ canceled due message _CODE_ true null And minor need _CODE_ prefix thischannel
Following comment second argument _CODE_ method updated TYPE_2name In addition check return value _CODE_ If value null return TYPE_2 instead
This looks wrong
advantage compare 0 b b 256
nit make final
Considering expected exception test seems like _CODE_ superfluous really want _CODE_
TYPE_5 int
_CODE_
Add days period
unneeded change
I really prefer VAR_3 used everywhere consistency even nonpublic _CODE_
spelling deterines
Im fine server side classes case _CODE_ inside corecommon module correct class also visible _CODE_ compiler far I know emulate METHOD_2 method _CODE_ Thats reason I remember comparison via classname method emulated always compare js two strings feel free test guys Im wrong lemme know Im agree change
1
navis wondering need include Tier logic
Probably crash bad format string
Duplicates METHOD_6
Looks redundant
_CODE_ never returns null
Shouldnt clearing entry _CODE_ Similarly whenever compensate complete callbacks finish successfully
Is package private intentionally Also method test probably used
This looks backwards This would attempt create VAR_7 neither VAR_3 VAR_4 provided
Why constructor
whats point
Why use variable names b instead VARVAR_3 VAR_3
Please split test several testing case separately
This changes default behaviour would lead different results consumer updates mp3agic We could future keep decision prefer id3v2 id3v1 consistent whole library This go another pull request signed mpatric
I think dont need set VAR_4 VAR_5 thisdatabase id TYPE_3 null already
I dont think constructor needs modified intended called VAR_2 majc
move thisprinted false align stack order
If invert default says false like I 11804 dont many changes lambdas unfurl anonymous classes including staticmethod unlimited staticfield VAR_1
This validated assertion well
TYPE_1 name mandatory
Why returning TYPE_1 instead plain int
Yeah VAR_1 probably guessed landmark storage half landmarks least 12 something
No need final
necessary
return null I think meant false
dmzaytsev We able inline VAR_1 VAR_3 VAR_4 since oneuse variables
Remove
Why next invoked
Why VAR_1 Run lookup VAR_1 _CODE_
debugging logging level log error
Remove system outs
Checkstyle violation antcheckstyle _CODE_ hometravisbuildspringprojectsspringintegrationspringintegrationftpsrcmainjavaorgspringframeworkintegrationftpsessionFtpSessionjava157 construct must use _CODE_ You verify locally using gradlew clean springintegrationftpcheck
Same method return void dont want nuxeojavaclient outside class
Looks like changed mind decided use setter ctor I mean doesnt look like still justification final
key used
I think condition opposite
Code style Curly braces around else statements
The VAR_2 code path never used please remove I think general want avoid unused code since confuse readers sleeper bugs awake someone ever tries use code
I would suggest _CODE_ make secret answer validation case insensitive
minor package private
METHOD_1 designed mostly called indirectly e g method constructor accepts Object args In case I see point use instead _CODE_
Not case sure VAR_1 belongs sub class VAR_2 belongs super class So origin code _CODE_
call method METHOD_4
Same seems METHOD_3 exact thing code
Unnecessary braces
What happVAR_6ns wVAR_6 throw whatVAR_6vVAR_6r thrown bVAR_6forVAR_6 iVAR_6 throw VAR_6
Instead check String values equal
Can one constructors call one Cleaner code way
I think line _CODE_ code line 112 useless
Please fix _CODE_ implementation 11 replacement removed code right
I dont think check intentional If thisVAR_1 VAR_1 could moved inside block
Id rather use String VAR_5 VAR_5toString That way ever end anything else String fail know something wrong But point You could make _CODE_ return VAR_3 directly Right _CODE_ method converts VAR_3 String VAR_2 converts back VAR_3 And far I tell VAR_2 uses value since call _CODE_ ever happen VAR_5 null SortMissingValueMISSING_FIRST SortMissingValueMISSING_LAST
dont need 2nd paramnamelength _CODE_
_CODE_ throw _CODE_ element doesnt exist never null You could use _CODE_ get element null makes sense remove null check allow _CODE_ thrown Same _CODE_
I imagine leftover debugging
Maybe one thing I looked second time Is check really needed If VAR_1 null immediately return null given VAR_3 unique wont match conditions eventually reach return null
Add another method isGroovy3 maybe initialize values static final constants
_CODE_ says type parameters needed
Could please change bit Stopping timer nearly important actually closing resource stopping timer throws kind exception stop resource Could something like try superVAR_1 finally _CODE_ This guarantee VAR_1 resource always exception thrown cases resource exception takes precedent newer versions java exception show Suppressed exception
Why new METHOD_2 cant us
Remove public modifier
Same I think probably leave constructors around They really harm
I think would better call end _CODE_ method Just VAR_1 instance created
If user didnt set VAR_3 builder well get _CODE_
Why cant return numberget
Please use _CODE_ VAR_12 instead
Try create nice generic static method parameters Move method use method
Delete _CODE_
This needs synchronised otherwise threads might see updated value VAR_1
args necessary It doesnt appear used
VAR_4 constructed fixed capacity
nullable annotation
x doest seem used Presto code base I would put size right line 156
would need VAR_3 VAR_3failOnUnknown
Code style Always use curly brackets space
Ive minor performance concern By looking TYPE_5 code case xml escape ends done 5 chars replacement doublequote ampersand lessthan greaterthan xml apostrophe The VAR_4 string scanned linearly Then use _CODE_ slash replacement builds pattern matches replaces How manually create Pattern provide regexp matching 6 chars perform replacement Alternatively linear string scan code replace 6 chars pass
Great place lambda java return Iteratorsiterator VAR_1 new _CODE_ Override public TYPE_7 METHOD_2 return VAR_2 factoryapply VAR_1 Override public _CODE_ VAR_4 return VAR_4
Consider using Singleton pattern For example within _CODE_ codebase see X12EntityExceptionBuilderjava
return value correct If another thread comes brings us safe mode first say still safe mode
Missing substitutions suggestion _CODE_ parse VAR_4ue system property integer Using default VAR_4ue VAR_3 VAR_4
That last TYPE_1 VAR_3 thing make task ids unique could randomly generated string things would still work fine
Another static import
And careful casting long int basically make sure never cast long IntegerMAX_VALUE int Here casting early cast finding difference guaranteed less IntegerMAX_VALUE This return _CODE_ _CODE_ IntegerMAX_VALUE int _CODE_ _CODE_ IntegerMAX_VALUE
seems using line existing coding pattern though minor
Did want initialize Java defaults
nullable Why go public _CODE_
reduntant METHOD_4 call
It seems like two deadlinerelated methods could static
Please add
I think remove VAR_4 field
You call _CODE_ _CODE_ instead _CODE_
majority changes simply passing VAR_1 around codebase
rm public
Is nullempty VAR_3 allowedexpected
Since mocked VAR_1 store get shouldnt need actually put right
fluent
The recursive call pass false get field result
Please add
Wouldnt grealy simplified using primitive ints
Maybe common stuff could moved utility class something avoids repeated code
Formatting
Imo could simplified _CODE_ placed right try block start since f cannot null point But way _CODE_
could return _CODE_ save branching
oops typo
missing final
If _CODE_ enabled also METHOD_1 TYPE_1 repeatedly call destroy operations
timler I think use class comparison using _CODE_ instead instance check different subclasses cant considered equal eg Donor Donation id
ditto
checked construction time If guy excluding values enum throw beautiful _CODE_ Hence METHOD_1 declare throwing TYPE_2
Please remove invocation Right test would pass even without _CODE_ modification If remove invocation test would fail without modification Otherwise looks good
This looks unused _CODE_ mean use LOG_PATH instead LOG_HOME last property belowdel Never mind I see This copied _CODE_ report sample input It looks like active log path archives stored path Since using property test lets remove
Are caching result application regular expression String Unless good reason demonstrate benchmark seems really bad idea
VAR_2 never null
shelan need declare every method final
Single quotation marks needed line 145 We use escape class names strings The problem appears classes
You need add annotation well otherwise delegate ie actual VAR_1 implementation decorator get Singleton annotation
I would assume java return extractingextractor VAR_2 That create _CODE_ map different assert type
actually really need VAR_2 parameter
There 3 param constructor call reduce code rep
1 _CODE_ parameter never used 2 May make method private _CODE_
suggestion _CODE_
_CODE_ lets rename iterator
suggestion _CODE_ since otherwise obvious nodes name change somewhere
whats point The method always false DefaultDebugExecutorEXECUTOR_ID without changes
line builder method _CODE_ context sensitive
isnt needed anymore right
Unnecessary still enabled default core disabled wizard
Moving assertion test actually make test readable reading assertion gives idea _what expected behaviour_ Hiding assertion bad pattern I know used lot legacy code I wouldnt like used new tests
Is change required
_CODE_ throw Throwablespropagatee
assuming much Better equals
seems like METHOD_1 accept TYPE_3 instead TYPE_1 Seems like unhandled VAR_1 thrown non TYPE_3 VAR_1 gets used
There brackets preceding order make clear new code intended part loop
Isnt enough throw logging exception instead also logging locally
I read three times get negation Maybe simpler read suggestion _CODE_ return _CODE_ _CODE_ _CODE_ _CODE_ else return Optionalempty
It clear passing _CODE_ context constructor even test pass environment looks odd
scontext1context
Close METHOD_6 Or even better trywithresources
_CODE_ Result integer multiplication cast long _CODE_ rule
More likely meaningless access changes
Minor anyway
This line _CODE_ VAR_1 The parameter named VAR_1 VAR_2 Alternatively parameter could renamed VAR_2 match semantics setters
Restore visibility fields methods class package level unit tests moved jaggrcore
That would require resize underlying map default load factor 075 Lets use new _CODE_ _CODE_ followed add VAR_2
nit This result double logging
Has message null checked point Also guarantee VAR_2 length greater 0
Hmm The Encoders _CODE_ property string output events Coupling separator output events regex use split message string seem ideal I think regex use split message string separate separator string use events
This one doesnt make much sense created instance
Consider adding wildcard front string well Right searching _CODE_ match _CODE__0015 searching 0015 Since query string escaped currently possible use _CODE_ wildcards queries something general user So searching 0015 match _CODE__0015
Checking Not null sufficient We dont need check _CODE_ clearing list
double wait
Can remove instead doesnt need called 2 lines
A copy constructor TYPE_1 might appropriate public getter method
I think VAR_1 solid _CODE_ might useful something like java return Poolid _CODE_ VAR_1 VAR_1 May even need VAR_1 VAR_1_CODE_ returns java return Owner id _CODE_ key _CODE_ null alone shouldnt happen unless something else wrong probably safe allowing
Missing close bracket
Where consider activity multiple time windows multiple locations etc If job sequence activities I propose consider within activity We need take account assignedscheduled activity single time window must single locations However may multiple time windowslocations choose Maybe differentiate ordinary activity scheduled activity First holds information locations multiple time windows etc Latter concrete assignment route driver
_CODE_ Severity _CODE_ Remove unused private METHOD_1 method rule
wouldnt false something always false
Looks like field never read
These VAR_4 checks used Such checks already present call site TYPE_1 This kinda breaks responsibility pattern
wanna derivation VAR_8 future
minor nit static implies final functionsmethods dont need final
I think use _CODE_ annotation Aztec method Kotlin allow Java side call method without new extra parameter Check answer _CODE_
METHOD_8 returns generic type _CODE_ C implementation necessary include cast TYPE_7 It doesnt seem clean edit I looked figured issue Poor use generics Change class definition _CODE_ remove need cast old java public abstract class _CODE_T extends GeneratedMessageV3Builder K extends _CODE_T _CODE_ new java public abstract class _CODE_T extends GeneratedMessageV3Builder K extends _CODE_ extends _CODE_T K
Hmm maybe move check _CODE_ catch block close also
This constructor yields _CODE_ called default constructor called therefore map created Please consider either Calling default constructor first Moving initialization map instance initializer Initialize options inline ie _CODE_ String options MapsnewConcurrent_CODE_ String I know Java 7 necessary specify String String twice please make easier compile rosjava older Java versions
Another access change _CODE_ violation little If needed lets change
called resource
use _CODE_ instead
If _CODE_ METHOD_4 activated thMETHOD_4 throws _CODE_ I recommend add _CODE_ statement
Please keep info level
Remove unnecessary final modifier local variables modified classes
Im 100 sure I think way around feedssize seems expected value This problem also present tests Before failing test showed something failed assertion Now shows actual value expected value misleading exchanged
Are disallowing zoom controls reason Im noticing lot calls made We probably standardize common function set settings maps Or common mode operation
Gratuitous whitespaceonly changes avoided minimize work cherrypicking etc
I tighten I would _CODE_ _CODE_ something effect This leaves lose end bugs
I think need superclose
Should avoid blocks braces
could block simplified java public TYPE_1 METHOD_1 VAR_1 new TYPE_2 VAR_2 null METHOD_2 disVAR_2 null METHOD_3 return
pynicolas I think worth rename method removal last parameter
Fantastic coverage thank
I dont think want call Filedelete filter since attempt delete file fails youll wont get exception since old _CODE_ N_CODE_ call right You probably want something like path try _CODE_ catch Exception e Or maybe specifically _CODE_ return false Better propagate errors though return true If allowed let _CODE_ handle better error messages case failure That said interest propagating actual error users I would suggest using functional interface method like void _CODE_ p throws _CODE_ instead _CODE_
You remove L162 well value longer used
Actually since VAR_3 really supposed extended could replace VAR_2 instanceof VAR_3 Cant null instance VAR_3 Also I would put VAR_2 test instead
This unnecessary called via _CODE_ superfill
markobekhta Is still leftover Ie planning revert change per discussion Same question places _CODE_ used
Fix error message something like Select event view Also labeled event screen Service exception Replace event appropriate label
Static import METHOD_7
nan
If _CODE_ overridden instead I think method could continue private Perhaps I missed something
suggestion public void _CODE_ int VAR_1 final TYPE_1 responseTYPE_1
Is error log call necessary warning call stack trace included
suggestion private static String _CODE_ String VAR_1
nit thisVAR_3 VAR_3 null VAR_3 nVAR_3w RuntimVAR_3ExcVAR_3ptionVAR_3
unnecessary cast
Please extra check test method
whats motivation need update layout _CODE_ charge sure safe update layout
combine two lines
This assumes always least one entry possible may
input parameter VAR_4 getting used anywhere VAR_1 method
For negative number VAR_9 defined developer code loop never executed evaluation VAR_3 statement performed turn may hide potential exceptions test
Sama kuin yllä
Does _CODE_ async
check null become required pass null _CODE_
I wonder null default wont generate empty property VAR_3 needed
Id return VAR_1 time reasons keep way time Id ok
Can use alphabetical order
It better standard _CODE_ leftavailable Sorry I didnt suggested form
What backward compat Can provide deprecated constructor
return String one line
Maybe use directly VAR_4 METHOD_4 without pass
remove return VAR_3 catch
Just add remove
WSTUtilsLIVERELOAD_SERVER_TYPEequalsservergetServerTypegetId even safer covers _unlikely_ case null id
protected
I think accident Could revert could explain change necessary
looks like copied initcan extract private method instead
I believe receive clear assertion failure message let Hamcrest compare objects assert use check equal When actualequals VAR_6 used hides information Hamcrest use make assertion failure message clearer suggestion _CODE_ notVAR_6FormValidationerrorfailMessage
Why asserting
Couldnt privateprotected My quick look didnt show use outside class
How throw TYPE_1
_CODE_ already invoked Operation I dont think need
minor need repeat type argument constructor
Same
Theres redeclaration error got fixed parent branch That needs get merged
extra
brackets dont match coding style
Why else
What tables
Any reason one public yet others protected
java return METHOD_2 0 channelwritebuffer want make elegant
Is Systemoutprintln call really needed If remove call needed replace logger call
In theory cell factories set directly fxml import _CODE_ import _CODE_ _CODE_ fxidmetricResults_CODE_ _CODE_ _CODE_ _CODE_ TYPE_3 _CODE_ _CODE_ _CODE_ fxidscopeHierarchy_CODE_ _CODE_ _CODE_ _CODE_ TYPE_4 _CODE_ _CODE_
You need METHOD_2 since theres one implementation _CODE_ METHOD_2 used METHOD_5 interface _CODE_ _CODE_ dispatchers different implementations
_CODE_
nit I know parts class put METHOD_2 calls inside another method call lets sake slightly better readability METHOD_2path path null _CODE_
null acceptable value VAR_1 You use null represent value selected need TYPE_3
I guess TYPE_4 exist disregarding calling METHOD_1 METHOD_1 needs enrich
protected
sure best exception _CODE_ throw TYPE_1 instead ignoring
_CODE_ return false
Shouldnt new TYPE_5 _CODE_ INT_1 instead new TYPE_5 1 INT_1
Again cant store plugin plugin shared Or serializing plugin config handle table properties If VAR_7 set via Drill web console I dont think want encourage people create plugin configs table VAR_7 require file distinct file suffix cause confusion Already _CODE_
You statement
I think METHOD_9 needs synch _CODE_ updated
Pretty sure also supposed localization key
Add null checks nonnullable properties
Simplify one line
Personally I prefer separate modules This module could work without parser one Id prefer remove lMETHOD_4e add TYPE_1 list default modules METHOD_4 _CODE_
unnecessary
retain This looks like possible memory leak
bug ditto
Can VAR_2 null Perhaps better invert classNameequalsVAR_2
seems false also valid response
remove line
I havent actually tested code 1 use METHOD_1 2 _CODE_ call dynamicThemeMETHOD_1
Although proposed changed technically correct please revert sake readability
usually next line
This cast indeed removed new code doesnt follow Hibernate code style There space opening parenthesis missing space closing parenthesis See particular see code style configuration Eclipse _CODE_ _CODE_
Could call helper method java private static void _CODE_ _CODE_ throw new _CODE_ yet implemented
Please add attribute holder exception parameters
The test failing line Here error _CODE_ Unable continue expectation wasnt satisfied quickly enough junitframeworkAssertfailAssertjava50 orgwordpressandroidsupportWPIdleridleUntilReadyWPIdlerjava48 orgwordpressandroidsupportWPIdleridleUntilReadyWPIdlerjava37 orgwordpressandroidsupportWPSupportUtilswaitForConditionToBeTrueWPSupportUtilsjava281 orgwordpressandroidsupportWPSupportUtilswaitForElementToBeDisplayedWPSupportUtilsjava236 orgwordpressandroide2eflowsSignupFlowcheckEpilogueSignupFlowjava53 orgwordpressandroide2eSignUpTestssignUpWithEmailSignUpTestsjava27 _CODE_ Method orgjunitrunnersmodelFrameworkMethod1runReflectiveCallFrameworkMethodjava50 orgjunitinternalrunnersmodelReflectiveCallablerunReflectiveCallablejava12 orgjunitrunnersmodelFrameworkMethodinvokeExplosivelyFrameworkMethodjava47 orgjunitinternalrunnersstatementsInvokeMethodevaluateInvokeMethodjava17 androidsupporttestinternalrunnerjunit4statementRunBeforesevaluateRunBeforesjava80 androidsupporttestruleActivityTestRuleActivityStatementevaluateActivityTestRulejava527 androidsupporttestruleActivityTestRuleActivityStatementevaluateActivityTestRulejava527 comgithubtomakehurstwiremockjunitWireMockRule1evaluateWireMockRulejava73 orgjunitrulesRunRulesevaluateRunRulesjava20 orgjunitrunnersParentRunnerrunLeafParentRunnerjava325 orgjunitrunnersBlockJUnit4ClassRunnerrunChildBlockJUnit4ClassRunnerjava78 orgjunitrunnersBlockJUnit4ClassRunnerrunChildBlockJUnit4ClassRunnerjava57 orgjunitrunnersParentRunner3runParentRunnerjava290 orgjunitrunnersParentRunner1scheduleParentRunnerjava71 orgjunitrunnersParentRunnerrunChildrenParentRunnerjava288 orgjunitrunnersParentRunneraccess000ParentRunnerjava58 orgjunitrunnersParentRunner2evaluateParentRunnerjava268 orgjunitrunnersParentRunnerrunParentRunnerjava363 orgjunitrunnersSuiterunChildSuitejava128 orgjunitrunnersSuiterunChildSuitejava27 orgjunitrunnersParentRunner3runParentRunnerjava290 orgjunitrunnersParentRunner1scheduleParentRunnerjava71 orgjunitrunnersParentRunnerrunChildrenParentRunnerjava288 orgjunitrunnersParentRunneraccess000ParentRunnerjava58 orgjunitrunnersParentRunner2evaluateParentRunnerjava268 orgjunitrunnersParentRunnerrunParentRunnerjava363 orgjunitrunnerJUnitCorerunJUnitCorejava137 orgjunitrunnerJUnitCorerunJUnitCorejava115 androidsupporttestinternalrunnerTestExecutorexecuteTestExecutorjava56 androidsupporttestrunnerAndroidJUnitRunneronStartAndroidJUnitRunnerjava384 androidappInstrumentationInstrumentationThreadrunInstrumentationjava2145 And screenshot fails Screenshot_1559223815
I guessing work case necessary cleanup trying make sure I missing anything review
2 operations one flatmap sufficient
use values instead METHOD_6
ditto VAR_8 function
fired job submission
Change Objectequals Doublecompare part previous commit
nit make final
METHOD_5 METHOD_6 VAR_8 maybe remove VAR_8 essage
Minor two calls could collapsed since _CODE_ handles nulls fine
Remove ones
Remove cast
add braces
The VAR_4 moved doesnt seem used jar METHOD_4 already I guess
Need
Dont use METHOD_4 doesnt come user input config file Just use VAR_3 null
VAR_1 argument used
I know existing code Im thinking whats purpose code looks like necessary unit test
nit inline variable
trying avoid scheduling flows past right Can please add small note nit else statement required
Please add static import METHOD_4
please enclose single statement clause curly braces per recommended practice
_CODE_ Severity _CODE_ Do forget remove deprecated code someday rule
vkuchyn method named VAR_8 Please see chapters explanation
Any chance race condition concurrent threads try add entries one ends replacing
Use static call Theres need instantiate util class every time
Remove synchronized
Probably crash bad format string
vilchikelena Do need block
Similar comment
Backward incompatible change VAR_1 used return null throwing null pointer
rcpeters create key acquire lock key
use trywithresource pattern
This process referenced used test class
Delete empty line
The original idea behind delaying checks actual usage disable _CODE_ might still want Druid nodes able deserialize _CODE_based objects For example maybe used _CODE_ aggregators ingest tasks disabling _CODE_ still want able view old completed tasks task table metadata store So I think worth able create objects even _CODE_ disabled make sure _CODE_ never actually compiled
No need call METHOD_3
Typo method name METHOD_4 METHOD_1
please throw original exception
The VAR_2 false flow looks wrong If null passed TYPE_3 throw probably want VAR_3 null case
chain creates
Switch arg order use varargs
In METHOD_2 calling _CODE_ VAR_5 But creating VAR_5 later We assign VAR_5 calling method But VAR_5 creation also takes VAR_6 probably inside METHOD_2 method On side note I dont see _CODE_ VAR_5 using VAR_5 VAR_6 anyway Not sure passing first place
Should called finally instead The TYPE_2 set _CODE_
var ever used
I think made complex function Can think like way reduce nesting private boolean _CODE_ value return _CODE_ CharacterisSpaceCharvaluecharAt0 CharacterisSpaceCharvaluecharAt1
Nit checking exception message brittle I would say checking receive _CODE_ enough
Can explain check used Why readonly VAR_1 able get effective VAR_2
This sum parent self max
Tas supprimé la ligne vide à la fin de la classe
The question VAR_3 supports filtering relates multiple values
This means _CODE_ mapping symbol alias rather way around original right This confusing
I would add check VAR_3 null everyone overwrite current VAR_3 null Or create new VAR_3 _CODE_ methode VAR_3 null
sort
Useless cast well Mathpow returns double
suggestion void _CODE_ VAR_1
I guess could assert without temporary variable
minor could set null
Still idea would need VAR_2 building score projection
reduce null _CODE_ VAR_6 falsenull
I think would simpler implement VAR_4 VAR_3 referring _CODE_ something like int partial Mathsignumthisline otherline return partial 0 Mathsignumthiscolumn othercolunn partial
Never mind I see code thing
If making public isnt way verify loaded right Also isnt protected enough
inverno
put previous
Use VAR_4 field
index argumentssize
probably dont need introduce extra local var _CODE_ value assign VAR_7 saves line
Shouldnt throw exception instead
I think dont need log places METHOD_1 called _CODE_ logs
Do need change tests Were still using VAR_5 METHOD_3
In locations code interprets null forever lets maintain convention fix code _CODE_
In test start number null zero Please create test also actually null
nit Java 8 lambda function
complaint lgtm says json _CODE_ comlgtmjavaqueriesjavaunsynchronizedgetter _CODE_ 2 message text This get method unsynchronized corresponding set method1 synchronized locations _CODE_ _CODE_ uri _CODE_ _CODE_ _CODE_ index 4 region _CODE_ 151 _CODE_ 30 _CODE_ 151 _CODE_ 50 _CODE_ 5186 _CODE_ 20 Could unintended side effects
I would rather keep METHOD_2 since TYPE_8 Renaming methods didnt help avoid ambiguity I referencing
public
Missing generic return
VAR_2 cannot null
Same thing mutation
According rfc code METHOD_2 opposite
I know purpose _CODE_ test seems unnecessary unless depends _CODE_ instead _CODE_
Use expression MathMETHOD_2doubleseconds factor otherwise METHOD_2 method return IntegerMAX_VALUE input greater IntegerMAX_VALUE Its input parameter METHOD_2 method evaluated float therefore returns integer instead long
Arrange act assert java String _CODE_ _CODE_ assertNull_CODE_
Add _CODE_
If null would explicit choice user Reject exception
minor private
need check VAR_2 null reach
Id suggest calling init method context file instead
I think condition needs top start _CODE_ 1 instead _CODE_ INT_1 I think generated code getterssetters rules fields _CODE_ _CODE_ Or I wrong
Is change purpose Looks like infinite loop
Why final else removed
final class may breaking change overrides
I would keep condition null list set null
_CODE_
Lets add path VAR_3 It makes sense
Nullable et après tu fais assert null
erdemedeiros lets remove system outs
If constructor called builder remove public modifier
Does mean event type found VAR_1 would get stored event queue
VAR_5 inferred based type
instead testing _CODE_ _CODE_ check METHOD_4 METHOD_5 alias runMETHOD_4 I think better test something like _CODE_ METHOD_5LMETHOD_5trange0 1000METHOD_4 methods
VAR_2 null would best invert equals check java bucketsequalsVAR_2
Add fail ensure method call failed
We force refreshes
It feels like could well use _CODE_ get rid __MAX_VALUE__ altogether
VAR_3 crying_cat_face
This raw type please use parameterized type _CODE_
TYPE_2 enum used
Id rather introduce separate factory interface default customizer similar 754 default handlers It feels weird pass null annotation use case specifically _is_ annotation eg java interface _CODE_ _CODE_ _CODE_ _CODE_ TYPE_3 method TYPE_4 param int index
old code didnt throw I think rather returned null
может тогда protected раз он такой internal
need assign VAR_1 var since used could collapse 2 lines 1 instead
Id rather introduce field called file containing content TYPE_1 meaning type message however use appending file content future somehow Actually change uses text field file content use tags signalizing reindex without need change abstract type
Should java public boolean _CODE_ obj return thisVAR_2equalsobj Indeed class delegation design pattern attributes except VAR_2
Dont need _CODE_ well
Instead calling init explicitly could call call default constructor VAR_1
condition determines value rather action think method think ternary appropriate int buffer VAR_1 TileCanvasViewGroupFAST_RENDER_BUFFER TileCanvasViewGroupDEFAULT_RENDER_BUFFER _CODE_ buffer
You say _CODE_ instead namelength 0
The test isnt full It doesnt prove async applied Im sure test pass even without async true Please develop testcase reflect expectations
Is intentionally bitwise _CODE_
Here need fail default In plugins default create empty _CODE_
Im guessing dont want name null either Should specified assumed obvious
If METHOD_1 get called often change _CODE_ _CODE_
Maybe instead null order avoid _CODE_ check
Shouldnt index initialized MAX_INT order trigger 1st call
Im sure parameter VAR_2 used method body
Also null check cool
This expected exception matching row database ignore instead
I dont see condition replaced
Can revert BuildPRODUCTequalsgoogle_sdk
remove METHOD_5 please
Please restore original formatting
Is possible declare function throws TYPE_2 instead trycatch Other functions similarly Will _CODE_ still fail reasonably throw
Its unlikely VAR_1 could null
Here change meaning VAR_3 METHOD_7 accepts backup parameter _CODE_ uses internally original meaning _CODE_ _CODE_ false reasons Maybe passing around _CODE_ parameter object carrying index backup info need think others would flexible extensible
因为没有成员这个可以声明为 static 了
This needs TYPE_3
Is correct Its never set null
In order test runs successfully debugger required artifact test development
I wonder method final others similar What reason final methods
Also need check line 257
Same thing could _CODE_ VAR_17 primitive
Strange parentheses VAR_3 maybe cast
I find fail wo trycatch misleading _CODE_ either trycatch _ _CODE_ _
No need break across multiple lines
Why property keys equal formatted templates
Could probably private instead protected would preferred
This method could static since depend local state Same _CODE_
Do really need
ISPN5507 marked resolved sure
Please make constructor packageprivate We use tests need expose publicly
Same comment always using _CODE_ _CODE_ Also didnt test Timestamp
ditto others
Do need static
Im sure one Please pull _CODE_ isnt related timing lets run ad hoc examples make sure dont run nasty overflowsign related problems
Same
This bug need pass VAR_3 instead VAR_2 Since _CODE_ I fix branch push
This I fine want keep java final TYPE_5 element VAR_2 _CODE_ VAR_3
curious returns new TYPE_1 however previous test null directly returned
Should method return null buffer yet created buffer VAR_1 error Right may throw exception upon calling METHOD_3
suggestion return _CODE_
VAR_2 null would best invert equals check java bucketsequalsVAR_2
VAR_2 message
Breaking change class public
Missing generics TYPE_1 Adding least empty allow compiler derive correct generic type provided METHOD_3 method signature enough information
methods public except one
inlined
The parameter seems wrong
Delete throws VAR_6 Also
What plans fellow
VAR_1 casting redundant
起動時にエラーが発生して _CODE_ が実行される前に METHOD_1 が呼び出されたりしないかしても大丈夫かどうか気になりました
Redundant else block
METHOD_1 method needs marked private
Could minimize scope synchronized statement
Annotate param Nullable
It false default And I pointed previously dont need specify _CODE_ explicitly It implied second TYPE_4 ctor Right minor still hurts eyes smile
This likely unnecessary The set VAR_2 expected contain elements See also _CODE_ places constructor used
I dont know put inside method Should temp table considered staging directories
beware initializing map rather populating Dont think need change tis class
Since already synchronized maybe well put _CODE_ inside block doesnt need _CODE_ To reduce two synchronization mechanisms one
maybe return false would better
Why change
VAR_2 null check constructor _CODE_ call needed
dont need check VAR_1 null next condition check covers
In current code check _CODE_ passed VAR_6 include VAR_6 task treat _CODE_ owned VAR_6 contained assignment _CODE_ VAR_6 assignment create new I think existing code close old tasks suspended bug Pondering Im sure would best solution since things would happen 1 users changed partitiongrouper rare deprecating _CODE_ 2 users changed code hence changed topoVAR_11y case taskA_B longer mean thing In either case facing much severe issue resuming suspended tasks Maybe better still VAR_11 _CODE_ resume task
use _CODE_ instead _CODE_ _CODE_ return position even _CODE_ defined 67i8urnoid
Why Nullable
Is used logging
This replaced method reference ie VAR_1 Channelspipeline
This order changed This might break existing rules right
return _CODE_ encoders
What purpose throwing The value seems replaced throw caller could catch exception value overwritten anyways
cause potential _CODE_ VAR_1 null doesnt
If VAR_7 boolean primitive could avoid condition block
minor I would call _CODE_ METHOD_7 check fails uselessly made call _CODE_
I remember us talking decoupling synchronization class I tried completely remove synchronization still didnt solve regression according benchmarks I ran way back september something Back I probably messed something I would love see benchmark result confirm fix
TYPE_5 necessary
unused collection VAR_13
_CODE_ use
Not sure need reference particular nodes setup
indentation
Make logerror statement And needs space
variable null right
breaks backward compatibility _CODE_
Why
Doesnt seem like change needed
This minor detail _CODE_ methods work like _CODE_expected actual valid whole test files Also please format file space
seems TYPE_1 thrown method
This already done method
I think line means _CODE_ needs METHOD_1 method
_CODE_ VAR_2 false
This check useless VAR_1 never null
Remove redundant null checks
change assertion per discussion
Is pattern Weird METHOD_1 METHOD_1
Perhaps override ensure capabilities set properly per bug You declare new class inline java public void _CODE_ VAR_3 VAR_4 new VAR_3 anonymous subclass assertThatVAR_4getCapabilitiesisEqualTonew _CODE_
Shouldnt something similar also done getterdefined properties methodlevel constraints
Here generated sometimes _CODE_ exception VAR_4 found _CODE_ Map different id current storage managers
I woudl remove else VAR_2 wrapper says false VAR_1 GridCoverage2D want fall back METHOD_2 check anyways
Why isnt called like set
Dont need METHOD_2
Why static others Same function _CODE_
Add java _CODE_ Just dont worry future additions parents METHOD_1 function called
minor static import METHOD_2 readability
wrap
Remove
TYPE_2 thrown
small thing _CODE_ shorter
either remove else add pair curly brackets
We replace null VAR_1 all_VAR_1 verification get exception You changed initial order statements
If type converters shouldnt support VAR_1 maybe makes sense mark method final
PVAR_1rsonally I would add two mVAR_1thods instVAR_1ad using thVAR_1 VAR_2 paramVAR_1tVAR_1r SomVAR_1thing likVAR_1 java _CODE_ TYPE_1 VAR_1 final String contVAR_1nt sVAR_1tupAndRVAR_1gistVAR_1rPopovVAR_1rfinal TYPE_1 VAR_1 final String contVAR_1nt HowVAR_1vVAR_1r fVAR_1VAR_1l frVAR_1VAR_1 kVAR_1VAR_1p
_CODE_ Severity _CODE_ Remove empty statement rule
keyword unnecessary
These two checks seem unrelated actual check want perform
I would write return servicesgeturl
Call METHOD_1
Please consider adding overridden version _CODE_ int Logger constructor accepts Duration encapsulate type conversion
Method reference METHOD_3 eg mapValidationMETHOD_3 I tried need types return METHOD_2 ffMETHOD_3mapValidationMETHOD_3 _CODE_
The new method implementation synchronized
Cant deleted
I would declare local variable makes method complex needs
ensure attribute null prevent _CODE_
Should keep coding format change VAR_2
Needs update _CODE_ since Rpluralsedit_action_contribution_count contains
return null _CODE_
Why catch VAR_12 If theres good reason catch least interrupted status restored
Shouldnt temp file delete come METHOD_3 _CODE_
This assert needed since hit line 228 procedure TYPE_3
Not really related pull request I think assume full short subpaths Base path still configurable
change impl _CODE_
Field marked nullable Remove null check annotate field accordingly
I cant find usage variable Should used If remove
Should final _CODE_ In general METHOD_4 implementation looks clear stiffly _CODE_ end delegates METHOD_1 So check METHOD_3 twice looks like redundant Unfortunately I dont see flexible solution yet Maybe _CODE_ flag
responsestatuscode
I think passing VAR_2 could sufficient couldnt To mirror whats done identity provider
Why test assign VAR_2 directly rather passing VAR_1
You use version catch block make succinct catch _CODE_ TYPE_3 ex VAR_2 true
Drop unnecessary use throughout
Please add also getters VAR_3 VAR_4
If clientid undefined return immediately look service registry
might good idea make sequencer client take array instead well instead extra transform
VAR_3 free variableit conceptually like field
You together
maybe simply return null VAR_1 set anywhere null anyway result variable declared
Seems like need set VAR_5 VAR_6 VAR_7 set Before method
I would use _CODE_
_CODE_ handle
ganncamp actually thMETHOD_3 null check required _CODE_ METHOD_3 nullable never null
Not required rely _CODE_ achieve purpose
It return
even need set _CODE_
could private _CODE_ doesnt subclasses far I know
This method seems thing previous line
Default config back
_CODE_ unnecessary
You directly return instead creating String first
If combine last two return statements might well one However I think old way makes code easier readunderstand
I think able call instanceof null fail instanceof
Remove finals parameters keep fields
Maybe use _CODE_ get rid synchronized keyword On side note I noticed havent enabled parallel attribute _CODE_ annotation So completely get rid need ensuring Thread safety
If getting right one one mapping escalator type authenticator nametype Authenticator nametype necessarily correlated I name kerberos authenticator George I wanted Theres also restriction two Authenticators type maybe makes sense hypothetical implementation running two instances different namespace similar concept makes sense So mapping specific escalator instance authenticator instance I suggest adding property
Why final VAR_3 Same issue line 130 Since final normally used local variables spock Id remove
Должны поддерживаться все форматы для целых чисел Например VAR_3 10x
Same issue variable names
Same issue variable names
VAR_8
suggestion VAR_2 null VAR_2getInitLevelcompareToInitMilestonePLUGINS_PREPARED 0
public private
To avoid relying strings custom exception extending VAR_2 int detail field set one constants But I ok done
Is reason package private On fluent builder feels odd
private
Never set empty string TYPE_2 Gathering strings source code fail
This could moved outside loop
I guess VAR_7 remain final
Does throw TYPE_1
Better return VAR_4 found _CODE_ capability satisfies return cond
Oops good catch
These tests _CODE_ They dont depend server
Close VAR_4
As
_CODE_ also supports similar way serverside See SSL_OP_NO_TICKET page
Roll back changes handler We check whether VAR_1 disposed handler methods
VAR_1 may null needs check
look like without declaration one line suggestion long VAR_1 _CODE_
These two could _CODE_
blocking one test could related method
Some VAR_2 entries _CODE_ table partitioned Need handle
Here use METHOD_3 directly map
suggestion VAR_2 0 VAR_2 VAR_3 0
Private constructor
We remove assignment local variable VAR_7
operands directly initialized _CODE_ VAR_3 super constructor required
duplicates METHOD_1 _CODE_ move _CODE_ something similar
Should return null
See comment
Shouldnt METHOD_1 cursors setting m_METHOD_1dtrue
Can reverse condition clarity
Shouldnt return immediately save unnecessary cycles Or least break loop
To improve readability return optional METHOD_3
Semantic change We want duplicates
Remove log line Call METHOD_1 instead lambda avoid duplicate code
Is assignement became useless _CODE_ VAR_3
I think forgot change return _CODE_ METHOD_3
Same
лишние пробелы в начале и в конце
I wonder throwing everywhere VAR_1 message calling line 123127
Why public
этого здесь точно не должно быть Метод init отвечает за инициализацию сессии и подписки на нее а не чтото другое Во вторых никаких манипуляций с _CODE_ на TYPE_3 не должно быть мы ж это обсуждали
remove METHOD_4 make VAR_5 long
Nit private
Please remove unnecessary null check name Its already tested constructor
Nit This put _CODE_ Same checks
used
If event fired delete operation METHOD_3 method validating
need use Stringformat parameter Either provide directly throw new _CODE_ must greater 0 maybe improve message somethign like throw new _CODE_ must greater 0 provided 0 VAR_3
Note put one line METHOD_1 This improve readability several arguments helps spot unchecked arguments
Per discussion mark servers _CODE_ even _CODE_ Otherwise may redirect traffic possibly much smaller set _CODE_ servers take
since two arguments passed asis string concatenation nice consequence using formatters dont need _CODE_ Of course issue _CODE_ makes code readable
This compile
Can setup Header _CODE_ using instance _CODE_ TYPE_3 You could _CODE_ contain one outer _CODE_ containing two children _CODE_ one Header one VAR_3 You would need add back header _CODE_ method
Since know _CODE_ could _CODE_ _CODE_
I think key escaped well
goes protected
nit This concise java _CODE_ null VAR_2 null Port range must present null
This seems wrong The _CODE_ method never called
This check could made getting node cursor No need spend time _CODE_ though gone 34 comes
nit Please dont change initialization order It would good theyre aligned definition order
java VAR_3 _CODE_ VAR_2 VAR_3 This code already _CODE_ class
I think still need call METHOD_3 since need propagate state _CODE_ well
Why java return CERT_PATTERNmatcherdatafind PUBLIC_KEY_PATTERNmatcherdatafind PRIVATE_KEY_PATTERNmatcherdatafind
Again use trywithresources
class also used integration tests module server different file system position
Should deserve _CODE_
Similar
Часто повторяется лучше сделать метод METHOD_4 в классе _CODE_ или Events
Add also test exercises fallback
I cannot tell correct Why VAR_6 instead new VAR_10 Also missing _CODE_ VAR_6storeName Deletes On last project ended inconsistent metrics names ab mixed a_b We either watch via code reviews try something like _CODE_ I think code reviews fine need vigilant soon someone dashboard alert set metric name permanent
Gary make ctors final props _CODE_ specs protected possible extension So I wont include extensions _CODE_ 3167 avoid conflicts two fixes Thanks
Your indentation way use 2 space indentation We also always use curly brackets single statements
_CODE_
danielezonca I think VAR_1 extends _CODE_
Can revert keep order deterministic
Shouldnt comparator means add new item VAR_3 size exceed VAR_4
Should use _CODE_ instead empty string comparison
ditto
final String name final int VAR_1
key strings public static final String class
We inline two vars
nit Remove extra brackets
needs method static
suggestion _CODE_ _CODE_ VAR_1 Runclass _CODE_ Launcherclass _CODE_ thisVAR_1run VAR_10 VAR_11 listener else throw new VAR_8 may easier follow
Code formatting
You keep previous line default size nonarg constructor already RingBufferLogHandlerDEFAULT_RING_BUFFER_SIZE
When matching models routing key routing key _CODE_ expected identical property name command So method name validated As remove get prepending routing key comes method
protected needed Android Studio warns Screenshot 20190313 17 28 17
I would personally preferred else block I fine
I think dont need create table test Just call procedure see fails
Remove TYPE_4
A lot changes logic Im curious driver returns non null object type returns true _CODE_ Ive see happen primitive types never object types
isnt _CODE_
flagging theres bigimportant todo
This seems odd What
Nit use VAR_1 null return instead
We dont really need call super
Sounds like generic method name specific parameter name String attribute
difference VAR_1 null VAR_1 null true false _CODE_ nothing We simply call _CODE_ _CODE_ returns null active VAR_1 way find really VAR_1 active
_CODE_ VAR_6 probably missing
Fix formatting Run formatter phase maven _CODE_ doesnt anything since _CODE_ checked METHOD_3 returns null TYPE_1 directory It return empty directory doesnt contain files
Instead altering method signatures would readable overloaded method signature accepts singular VAR_8
Seems compilation issue new VAR_7 new VAR_7String
change private
_CODE_ test please equals hashcode
arg could final
Can make method names consistent I think set vs add slightly different implied semantics We might want implement true set later would maintain single header value keyalso need remove method Maybe
It would better id VAR_2 constructor Id VAR_2
Maybe omit check since method called known sure first chunk needs notification also longer prefixed maybe
VAR_6 final _CODE_ What synchronization
maybe rename param item
It reads bit strange fall METHOD_5 know request doesnt need coordinator Maybe clearer slight restructure java _CODE_ _CODE_ transactionManagerMETHOD_5nextRequestHandler else For noncoordinator requests METHOD_3 prevent tight loop node available timeMETHOD_3retryBackoffMs _CODE_
Could annotations parameters
error rather METHOD_4 We sending back 500 user
Lets change visibility test classes methods please
clickable
private protected
Any reason VAR_2 ignored Shouldnt passed
one needed automatically zeroed _CODE_ needed
Id either remove message expand bit ie Refreshing info server X
Access private
_CODE_ would better
Why fetch task
This pretty lonely semicolon wink
I think teamcity complaining TYPE_1 never thrown
Nice
int rather TYPE_2
I particularly favor METHOD_4 lenient approach may mask runtime problems inability create table I would recommend adding overrides relevant connectors cassandra case Or could introduce separate preparatory commit _CODE_ method see _CODE_
timur27 could please completely remove VAR_2 variable requested thanks
Right equivalent 30 class place youre using field isnt shadowed intentional
Isnt middle true wrong It _CODE_ That means well start reading arbitrary block boundary Since binary format clear scan forward beginning next record done Sequence File restricted _CODE_ Also file zipencoded never block splittable since Zip files cannot read arbitrary offset This creates issue blocksplittable attribute right constant But file zipencoded never block splittable Any way handle fact And way test behaviour
You return _CODE_ 0
Static import METHOD_3 But also stay asis
info instead METHOD_2
Changes file look unrelated could revert
removed
Rather changing contract compilers match perhaps follow existing pattern pass new String
Nullable TYPE_1 VAR_3
static import
VAR_1 forcing deleting authorization
Consider
thissvg
Just return result _CODE_ instead using variable immediately returning The variable necessary I think even Codacy wil complain
This doesnt sound right readonly txs optimistic locking
The default implementation METHOD_1 wait forever Whats reasoning using _CODE_
METHOD_3 shouldnt ever return null Based Python _CODE_ functions return VAR_2 object every time In case fact empty factors minimum_requirements return VAR_2 minimum_factors set false 0
It better use java _CODE_ since cannot overridden whereas _CODE_
Have also migrated unit test
Docs
I think resultsdisconnect finally block always want release connection back
I would silently ignore one passing null parameter In words would remove check assume VAR_1 null If turns null better caller automatically get _CODE_ chewing quietly
Mind changing type _CODE_ TYPE_1
return VAR_3 instanceof TYPE_1 TYPE_1 VAR_3 null wdyt keeps instanceof closer cast concise
The payload already closeable Close payload avoid deprecation warning
VAR_3 _CODE_ general uses nullable properties indicate presenceabsence options
Why METHOD_1 check If map get return null
Id prefer noargument version order follow pattern _CODE_
There non _CODE_ students _CODE_ students thus switching order probably improve performance
Wrong code Should id null _CODE_
This method contains assertion _CODE_ Shouldnt _CODE_
Woa Im sure I like public
This finally block create TYPE_5 TYPE_5 VAR_3 try finally FileHelpeVAR_3afeCloseVAR_3
suggestion _CODE_ hence failed write byte array
Instead line dont call _CODE_ VAR_4
Just return _CODE_ Nice approach though Should good push youve tidied
So means VAR_2 unknown type considered serializable Should consider making unknown check inside METHOD_5 provide behavior rules using Im saying since rule S2118 using METHOD_5 also reporting arguable issue similar message run unknown type Make Unknown class Serializable dont write
general rule thumb follow think would log unless exception swallowed last destination exception In case exception set passed someone else log eventually If log exception swallowed might double logging pollution log
remove
Use array instead iterator
The removal public breaks _CODE_ module generally VAR_1 available things use _CODE_ might think inuse lack whatever module facade workspace
Unnecessary parens around return value
Did consider adding VAR_6 VAR_7 render adding VAR_6 parameter html render I think would nicer designwise single page could rendered multiple times different VAR_6s I think might also make impact Renders smaller methods call html would need VAR_6 seem VAR_6 parameter already
Dont need create new TYPE_4
Do VAR_3 null null check conditions necessary
Is really necessary add check Doesnt _CODE_ prevent login request reaching point
consider pros cons operation level vs trycatch higher level ie _CODE_ thread
Nit You use static imports Mockito methods
Same
This could actually replaced slightly efficient line return VAR_1getBooleanQUERYABLE_FIELDtrue default VAR_1s considered queryable This looks value VAR_1 whereas pullrequests original code actually looks field twice Considering method called frequently make efficient possible
nit specify explicit name We dont handlers well
Isnt always false
remove
I prefer move methods Simulation better create also two methods change package private remove also existing related _CODE_ Scenarios remove header Otherwise easy forget cleanup Scenarios inconsistent data
This one static
TYPE_2 equals consider two null equal case _CODE_ changes
Nested METHOD_2 invocation seems unnecessary But maybe I missing something
This Block shortened sharesetIsFoldermPathendsWithFileUtilsPATH_SEPARATOR
Now could make parameter final thats main point TYPE_1 _empty_ class posting doesnt appear much Unless subclasses TYPE_1 somewhere I see DrlTYPE_1 case could make abstract
VAR_2 param doesnt seem used ctr source always used get cache container
parameters final
typo VAR_12 VAR_13
Please inline remove
This needs removed
I cannot find infinispan routing options Is removing ltinfinispanrouting cachecontainerweb cacheroutinggt
remove
true plenty good
You remove console outputs production
Debugging Remove
new String redundant
A missing semicolon causes project fail compile
creating separate put method Environment parameter avoid using null
nit merge line METHOD_1 returns VAR_2
info
Do need This seems like creating circular dependency _CODE_ TYPE_2 _CODE_ depends TYPE_2
Remove ORDER_MAP_ENTRIES_BY_KEYS
This looks like result bad merge
A small trick make TYPE_5AR_1 also implement Func0MapK TYPE_5 assign map factory function course cant use constructor delegation assign final fields explicitly This way need extra class
would want true
break loop VAR_6 found
You make METHOD_3 call part SERVICE_FAILURE_ACTIONSPointer constructor
This actually sideeffect leaving VAR_8 end test state thats different state test This could lead strangeunexpected failures case testsuite execution order changes etc Can restore original state using tryfinally block Thanks
TYPE_8 compiled Please move outside method
It looks like bounds check also done String constructor Can check line still necessary
Why list
Maybe would good include causing exception user knows couldnt created
There null check VAR_4 prior calling _CODE_ method Maybe something like _CODE_ VAR_5 VAR_4 null VAR_4_CODE_null
need one two cases encrypted true either simple adaptive I dont believe useful think
Is reason calling METHOD_4 twice
Method called _CODE_ VAR_13
Can instantiation objects equals method broken condition Theres lot going simple equality check would easier follow impls instantiated earlier _CODE_
rm 54
This _CODE_
Mapgetkey already returns null key contained map
several layers wrappVAR_2g VAR_2to TYPE_10 one It looks like done VAR_2 method
Just collapse two statements VAR_1 METHOD_2
I would instead _CODE_ VAR_3 VAR_4 null _CODE_ VAR_4 null _CODE_ point spending time checking cache used theres VAR_4 provided
Should primitive
public usually final
trycatch block constructor _CODE_ Shouldnt something like _CODE_ something
jomarko If nothing preventing move _CODE_ update I wrongly indicated method I meant _CODE_ one
VAR_11 already
It private
_CODE_ VAR_1 static end initialized multiple times time _CODE_ instantiated I check vehicle_icons0 null previous code make sure didnt pay initialization penalty This even important loading vehicle icon types You add similar _CODE_ block around initialization VAR_1 something like VAR_1containsObaRouteTYPE_BUS type check
Several methods class need public package local
This hard read please move nonnull checks
Has VAR_7 VAR_7 1
think always use validation query
else redundant
We change return type METHOD_2 implementation avoid cast
Extract constant
You inline calls METHOD_1 assignments
Since definition VAR_5 VAR_4 type parameter casting may needed
A newline
This could null I think
Can keep order previously That 1 notify ad click 2 launch click target
Can call version METHOD_1 instead java public static byte METHOD_1byte data throws TYPE_1 return METHOD_1data 0 datalength
exception left bubble fail test If METHOD_1 fails means repository shutdown properly
Why calling METHOD_1 instead calling constructor directly
This look correct terms isolation objects Why call needed
Make final
Global listener catch METHOD_4 You dont need METHOD_5
Very minor thing technically dont need check The _CODE_ ensures component thus dont need check null
Itd better throw exception If theres problem download stack trace printed junit wont know anything The failure would come later file found With exception thrown junit report lot clearer naive user knows nothing test understand better went wrong
I believe public static void _CODE_ extends TYPE_2 expectedTYPE_2 Theres need make method generic value used place
_CODE_ _CODE_ supported
return Promise symmetric start
What It seems like strange thing
suggestion f null _CODE_
thread safe
No need METHOD_5 METHOD_4 method throw _CODE_ The rationale null checks constructors places ensure object invariants exception occur right time know provided null In case caller get _CODE_ proper stack trace Occasionally might want explicit check provide better message shouldnt needed theres one object Now VAR_2 argument method put directly lambda capture wed want null check ensure capture valid
new _CODE_ new TYPE_4
Please add even oneliners
Wont generate _CODE_ VAR_1 null Perhaps 2 steps check Optional would make
Parameter type missing generic type Wildcard VAR_3 possible generify method T use VAR_3T _CODE_
Unnecessary boxing
I think better dereference channel finally block case METHOD_2 failed METHOD_1
This change shouldnt necessary rebase patchset I already changed behavior pathtraversal guard return INT_1 instead INT_2
Move line statement We dont need execute VAR_2 null empty
nit Just _CODE_ _CODE_ VAR_5 null avoud copy pasting argument checks
We create multiple _CODE_ method another one created L299
How use _CODE_ youve done _CODE_
Shouldnt mean new rules get lowest position highest priority
Im wondering would better default final method _CODE_ called something sensible like foo checks VAR_3 true calls METHOD_6 calls METHOD_7
Theres difference primitive type boolean class TYPE_1 seem using primitive rest code Use boolean return type
static import METHOD_2
METHOD_3 Isnt better use logger
Please change code match replaced I wanted sure exception thrown
Lets make public
please add curly braces
Please log exception well full stack trace
Seems like could go build
Does truly need done _CODE_ could guarded _CODE_ alone It fine _CODE_ issue code fix I need see arjunacore test case shows reasoning cant sole change _CODE_
Should Deprecated
debug leftover
I thought going switch use Rule _CODE_ temp directories
Nit No need final
saw _CODE_ change VAR_3 null VAR_3getApplication null happened _CODE_ classpath due annoying Eclipse behaviour
Isnt supposed create return new yet database VAR_1
use
ah I think might actually need synchronized two methods Add keyword synchronized METHOD_1 _CODE_ _CODE_
TYPE_1 needed instead int
nit public
Create ticket improve Sonar rules
Why The original code work anymore I direct passthrough underlying curves
whats thinking behind showing everythings _CODE_ Is particular reason dont want show summary matching fails
No need check view type _CODE_ suffice
change METHOD_2 warn error No need include inside
I thought catch exception call close rethrow
left debugging
_CODE_ spacing need new line But wait see theres changes youll need make reviewers
Cant move check _CODE_ extend common Hive test class
Please include unrelated changes single pull request Thanks
Youre defined application service try get projectspecific service store state application level use projectlevel configurable You decide level needed cases
Is change still required
nit merge two lines
would old _CODE_ contain VAR_4 _CODE_ method get called
factor TYPE_3 VAR_2 static field initialize METHOD_1 method
_CODE_ null null
sort
I think manual get followed null would efficient right new TYPE_5 always evaluated element found
Typo
Try keep param order method context throwable start
_CODE_ style considered unnecessary else actually possible compiler errorwarning eclipse I think java compilers
personal preference take suggestion account I would go ifcond return 1 return 0
shorten intervals cluster shorten Or last line wait anyways If line anything
I suppose null check irrelevant METHOD_2 would thrown exception missing method already
Out curiosity INT_1 Is yield control things get chance VAR_1 every 1INT_1th sleep time
nit invert statement positive conditions easier understand
We must alter constructors public facing _CODE_ Could instead add new one please Admittedly number constructors gets unwieldy probably add kind builder eventually
manstis synchronized removed method calling METHOD_1 overload already synced
bulb _CODE_ could replaced VAR_1 efficiency
I think lambda expression could passed directly _CODE_
It would better initialise member variable point declaration ie _CODE_ VAR_1 new TYPE_3 instead checking still overwrite list points save unnecessary check
Normally mutable pojo usually need set modify _CODE_ So I dont strictly required dropped We reintroduce later anyway
better
Static import
Please add relevant tests _CODE_
I guess could assert without temporary result variable
TYPE_5 issue
null case
I think would nicer VAR_3 extraction implicit ie magically happens call METHOD_6 need manually extract VAR_3 call _CODE_ This would make simpler users remove method public _CODE_ Yes may require reworking METHOD_4 implementation I find following sequence bit clunky unnecessary String VAR_3 _CODE_ withColumnsVAR_3 The METHOD_4 able figure columns VAR_2
I prefer use trywithresources follow java _CODE_ VAR_1 VAR_1FactoryopenSession TYPE_3 VAR_3 VAR_1getMapperTYPE_3class TYPE_4 name new TYPE_4 namesetFirstTYPE_4Fred namesetLastTYPE_4Flintstone int rows VAR_3insertTYPE_4Annotatedname _CODE_ assertEquals1 rows
Whats null check
If exception thrown wrap _CODE_ tryfinally block guarantee resources properly closed
Missing override _CODE_ value
synchronized
necessary
This directory probably defined common place want move another location single update
question account colo single replica
We need check offset length arrlength
It looks _CODE_ TYPE_2 really need
Why cant VAR_4 used instead
I think could get rid VAR_3 variable corresponding else block well
Is use curly brackets necessary returning void value
I would actually recommend removing throws TYPE_4 interface Any checked exception dealt calling _CODE_ ex I think helps unify failure handling paths caller needs deal
Could put characters back end TYPE_6
Seems like VAR_4 could also scoped class logs message want capture right
You wont need test nullity _CODE_ java VAR_6equals_CODE_ Because point already know VAR_6 null
Shouldnt pass null There overload
Nit Remove extra newline
See comment _CODE_ method
case could make sense
I would rather check null VAR_1 return false rather passing VAR_7 method nullable
please swap arguments exclude negative logic VAR_4 VAR_4endsWith VAR_4 VAR_4
_CODE_ Change instancereference static reference rule
Its kinda odd permission array passed along instead invoking callback VAR_1 get VAR_4 Passing VAR_4 array would simpler design
I think METHOD_9 called directly METHOD_3 right METHOD_5 call
public nonpublic class public removed
getting little towards magic side Id put _CODE_ parens
You need _CODE_ response data
Why two beans static Looks like overhead Although isnt critical Never mind
Minor typo variable name
Maybe move method separate _CODE_ class
Is TYPE_2 thrown anything method Or return void throw TYPE_2 instead
Given instance method Id remove method
consider use TYPE_3
else redundant
This mVAR_2thod looks thVAR_2 samVAR_2 public boolVAR_2an _CODE_ _CODE_ final String VAR_1 VAR_2 simplify lVAR_2ast _CODE_ param complVAR_2tVAR_2ly unusVAR_2d potVAR_2ntially rVAR_2movVAR_2 onVAR_2 thVAR_2sVAR_2 mVAR_2thods complVAR_2tVAR_2ly Also plVAR_2asVAR_2 updatVAR_2 thVAR_2ir Javadocs
doesnt thing try catch block
2x thisvalue value L64 L66
Same issue variable names
If dont make static need second parameter VAR_2 field class
This actually intended see start method called line 189 VAR_2start please revert We need annotate METHOD_3 method line 177 SuppressWarningssquid3AS1217 We intentionally start new VAR_2 yet rather wrap METHOD_3 call session
Redundant cast int
Why instead return obj instanceof TYPE_2 _CODE_
immediately clear X_ flags also _CODE_ null X_ flags used yet imagine set false defined set true needed
need catch
Ditto
This hardcoded constant value simply name I know wont change anything practice case people copypaste code
I believe _CODE_ 1 isnt
return _CODE_ _CODE_
Is synchronized necessary
_CODE_ instead Would ever really happen
params final
jaypatel512 I discussed last day I think might want either line called The _CODE_ idempotency header It doesnt hurt set null force regeneration since _CODE_ shouldnt really matter anyway The mask request _CODE_ set true maskinghiding sending _CODE_ header also ok _CODE_s However since dont reset state VAR_1 someone reuses VAR_1 multiple calls could cause weird behavior While working making VAR_1 threadsafe Im hoping majority usages VAR_1 new one used per request This partially legacy backwards compatibility thing
Just use VAR_1 declared class field
mpaladin I would prefer using meaningful name identifier tree class name
Why include name comparison VAR_3 enough
This internal make Nonnull Then VAR_4 could also Nonnull could VAR_4s If want signal error throw exception
Does additional list creation new TYPE_2 provide benefits compared following java thiscollectors _CODE_
This line isnt required It temporary hack disable kafkazookeeper jmx
add Nullable
This closed best would use trywithresources
Redundant given
nit remove
1 Whats advantage using TYPE_4 rather allowing null 2 VAR_1 objects meant small light If really want use TYPE_4 initialized classlevel rather every instance But change along lines please let know Q1
Same wrt logging protection
operator required
This particular change needs integration tested It also great unit tests coverage
This bit double negativey Wouldnt VAR_1 TYPE_1 else return false readable
jimma Can please introduce new constructor public TYPE_2 String source String name String message call instead TYPE_2ignored Can call constructor TYPE_2ignored well Thx
This actually intended see start method called Please revert We need annotate METHOD_3 method line 270 SuppressWarningssquid3AS1217 We intentionally start new VAR_2 yet rather wrap METHOD_3 call session
Same times left public please
We reuse METHOD_1 Iterable VAR_1
choose make synchronized VAR_2 bVAR_2 rather label entire static method public static synchronized VAR_1 init
_again_
either parameter annotated _CODE_ null check removed
inline
Why null check Are expecting VAR_7 null real scenarios If check allow tests pass null I think pass noop consumer instead get rid condition many similar places
Why VAR_1 used For reference following codes I used use java public int _CODE_ VAR_1 return _CODE_ _CODE_ multiSmrgetGarbageSizeUpToVAR_1 reduce0 b b
Didnt problems shortcutting vs _CODE_
Could use _CODE_
For curiosity method called multiple threads
private
Either add curly braces per coding conventions reduce ternary
This redundant We protected _CODE_ _CODE_
nitpickmodeon Can change thisctx ctx nitpickmodeoff
withMillisOfSecond0 necessary used
Can add _aClassisEnum_ end diff 1 line instead 7
_CODE_ variant
null check seems unnecessary given yoda condition
_CODE_ would called concurrently rite Do need current status _CODE_
use please
whoops removing
_CODE_
Why copying empty list Why nodes null _CODE_ _CODE_ VAR_12
If used marked deprecated since 111
Put _CODE_ first cheaper evaluate
backwards compat
This isnt going return null would better wrap METHOD_2
You use _CODE_ provide view base set view class dont need later cast actual view
Consider try TYPE_2 VAR_1 already use TYPE_2 Also TYPE_2 instance could also handle try section eliminating tryfinally Mind order VAR_1 closes though
simply _CODE_ VAR_1 would enough
Method doesnt throw exception
make constructor one
afacit vvv noise
This shouldnt closed used
There VAR_3 _CODE_ TYPE_3 VAR_1 Make private
Note parameters elsewhere gone rebase
It private
Unnecessary call
Its outwith _CODE_ opening file input might start file position anywhere beginning might good add warning constructors Javadoc
I think general avoid using remote callback error like might suppress errors Best would handle spec management call testing container started
We cant change signature published methods
Not sure one taba90 even default implementation supports still want override default check
Minor thing Im generally happy reassigning method parameters
tryfinally
Probably conflict 722
_CODE_ checks node instanceof TYPE_1 therefore need check VAR_2 null explicitly
false Why null
Can also rename parameter
nit put VAR_6 next line
No need intermediate VAR_3 variable
Please add Nullable
Please remove public modifier
We process removing logger calls lets add
nan
method parameter VAR_3 longer used
As int VAR_2 boolean VAR_3 params used maybe remove
The VAR_4 list added hash code _CODE_ I dont think change result case reason isnt consistent
could call thisproperty VAR_4 data null
Hmm might surprising Wont cause test executor thread called VAR_1 end build Do think could instead get _CODE_ name use assertions Or otherwise make assertions agnostic name thread
VAR_2 wont null VAR_2Length _CODE_ 0
method call
shouldnt always happen test infrastructure
Apparently cases present String would
Also need Basic usage
And also refer L55 _CODE_ The accept method change anything instance returns modified copy VAR_4 discarded
one nit put outside method since method METHOD_1 doesnt indicate METHOD_4
_CODE_
Dont need _CODE_ call
Should initialize list size childrenlength
I think lazy
These two guys replaced single _CODE_ The METHOD_5 also method reference METHOD_5Queuenew
Needs finally might get interrupted
Better prevent null first place ie fail early _CODE_ import static _CODE_ _CODE_ listener
_CODE_ VAR_2 _CODE_ VAR_2 otherwise first fails complete boolean expVAR_2sion shortcircuit waits wont get executed
Null expected suggested check explicitly rather operate via exception handling antipattern java
While youre touching could lambdafied Braces newlines see fit source_withSaveFilesBeforeCommand _CODE_ sendLoadCommandToConsoledevtoolsload_all VAR_2 Build
small typo node read none also doesnt actually check null let message seem suggest
Please use _CODE_ assertThatdiscoverhasSize1
good catchm path I wonder somehow preserve message I see TYPE_2 bad way dealing exception message Maybe clean Is bad keep VAR_9 clean stuff separate commit
I think parameter _CODE_ _CODE_
nit seems like prefer put else return elsewhere codebase
Fix indentation tabs instead spaces And may use static import
Did forget add _CODE_
Isnt use TYPE_3 returning null contradictory Surely checking METHOD_7 _CODE_ would better
Works anyways bit weird return TYPE_1 would look better returning TYPE_2 thats transformertranfsorm method Not critical issue fix like
Whats intent behind Generally want allow changed point Is something particular requires update
_CODE_ I think name null rest two evaulation ConstantsANYHOST_VALUEequalsname ConstantsLOCALHOST_VALUEequalsname likely evaluates true non localhost chances whole condition become true depends IP_PATTERNmatchernamematches So better understanding performance point view I think would better change name null IP_PATTERNmatchernamematches ConstantsANYHOST_VALUEequalsname ConstantsLOCALHOST_VALUEequalsname What yu say
Unnecessary change
It might better override _CODE_ rather append VAR_1 get orgvoltdbexceptionVAR_1 VAR_1 _CODE_ _CODE_ called stack trace printed
_CODE_ threadsafe multithread add might wrong You protect
Since already TYPE_2 ctor extra TYPE_3 variable redundant
hard code basic
Should VAR_1equalsppc64 checked There binaries ppc64 VAR_1 type
_CODE_ call methods They shouldnt make METHOD_1 theres one path call METHOD_1
It shouldnt public
If want remove link account allow set null We remove _CODE_ test
Arent urls like filesomepathmyjarorgfoobar The often used java urls indicate inside zip sure used kind though I agree contains false positives like tonyjarvis endswith might false negatives like myjarorg
Would better field _CODE_ table indicate purposeconcentration rather hardcoding something may may exist _CODE_ Maybe okay temporarily
nit Only VAR_1 parameter used I dont think need check anything VAR_1 METHOD_2
Why return new node instead failing one
Why force VAR_1 4 digits And btw happen new reason VAR_1 added 5 digits In case could good idea put format static variable near enum
Why keep TYPE_3
Thinking verify actually INT_1 active iterations stopping client Same reaper timeout
parentheses around instanceof check necessary
Remove
VAR_2 moved within clause statement
Unless reason otherwise return int TYPE_1 shouldnt set value 0 default That way call METHOD_1 initializing theyll get _CODE_ better corresponding bug
Should synchronized
Swap order numbers together
Flip move VAR_1 call inside
change packageprivate access
This requirement simply chain methods make readable java TYPE_5 _CODE_ _CODE_ _CODE_ VAR_4
field name VAR_3 parameter name VAR_4 please stick one
remove Stringformat
I find original version easier read case
call VAR_1 VAR_1Desc make code easier read
Why expected output changed
Why required Or _CODE_
format able deal Enums fine need call name
The VAR_2 parameter even used means rest changes class necessary
Im pretty sure setting local variable must happen within synchronized block maybe old location set happening sure state machine otherwise may observe old stale value Also Id merge change commit creates classes
private
remove synchronized
vilchikelena Highlighting may take time users clue whats happening may better either add progress report METHOD_1 file analysed
Hey kirillvlasov sorry picky seems extra set brackets
pbludov romani Any reasons shouldnt default
Could rename function _CODE_ function name METHOD_1
arguments wrong order
Either brackets put METHOD_5 line
Can move changes new class _CODE_ reduce overhead operators need functionality
Same inside VAR_2
I recommend moving line _CODE_ event handler already one unnecessary
I think need make constructor public In _CODE_ may used method copy instead using constructor
如果用StringBuilder了那仍然应该用append方法不用再用 额外创建很多String对象
Just work servicesaddnew _CODE_ VAR_4 You save line declaring VAR_2 object
VAR_1 must read synchronized block
although nice use java8 optionals sometimes easier read old fashioned null checks
Are sure line correctly
Minor may would better check value expected
Whaat 2
Add braces else blocks maintain consistency rest codestyle
You need create exception requires change default behavior Please use standard one usecase
Does still need synchronized
This needs VAR_4 message As throw new UnrecognizedAuthenticationMethodExceptionVAR_4 _CODE_
Can TYPE_6 extends TYPE_3 need references
Compile error mcenderdragon
This test occasionally fail
There need flush
Could repeated logic message tasks memberside map proxy hidden within TYPE_2 eg TYPE_3 _CODE_ name Data _CODE_ Data value long ttl long _CODE_ ttl VAR_3 return new _CODE_ else return new _CODE_
exper0 lets move final VAR_17 next line maintain correct indentation
lets use VAR_2 value
always METHOD_3
int VAR_1 would make everyone including style checker much happier
nit VAR_2 enforce _CODE_ true
You pass values string resource avoid See Formatting strings section
I think hide Snackbar since survey Snackbar show Explore feed
This constructor useful It kept populate _CODE_ like default constructor
Should VAR_3 used instead VAR_5 _CODE_ left intentionally make sure VAR_7 removed
really necessary destroy activity anyway
finals TYPE_1 TYPE_3
make VAR_3 take VAR_2 location argument remove global variable VAR_2 It seems really needed reducing global state good general
Dont think method going throw TYPE_1 We get rid
throws exception
If value _CODE_ _CODE_ return _CODE_ anyway I understand explicit
pass long null check look used
It might good add sanity check validate _CODE_ empty catch users forget call add Mockito something similar eg call verifymock without chaining method call mock
cant return VAR_7
else VAR_2 0
Please fix typo
Do want return skip older _CODE_ call
I believe shouldnt close handle It closed _CODE_ method I think also probably ignored handle still binded active transaction
class doesnt much predicate pushdown Just rewrite constanttrue VAR_3
No need add extra property binding want test old property still works
Since TYPE_3 shared runs tests usually I noticed reversion original settings eg _CODE_ _CODE_ I see tests passing wonder done anyway correctness
Please implement _CODE_ provide debugging state information debugging purposes
Move _CODE_
Why use java assert Ktool null Can call METHOD_1 instead
In places weve using try resources syntax Might appropriate
Now dont need VAR_2 field anymore make variable local method
cvrebert obj jso
As general rule If youre unsure whether METHOD_3 warning dont You discovered principal problem mutable objects The easy fix use immutable objects whenever possible _CODE_ looks like could easily made immutable So definitely instead METHOD_3ing warning
Method equals used instead
Add _CODE_ check mandatory fields annotate Nullable parameters constructor null
Hmmm Id prefer METHOD_1 frequent case VAR_5 must unfortunately else taking screenshot
add descriptive name instead element Maybe _CODE_ input field
imho would easier read java TYPE_2 VAR_3 _CODE_ VAR_3 null break
And
Why make methods static
minor could use TYPE_5 value instead avoid one call
If swallowing exception dont need METHOD_5
This VAR_8 I got 2 VAR_5 The variant information added VAR_2 _CODE_ Since already added _CODE_ readds existing variant metric By removing line starts work correctly
Please avoid using devloper names code Can replace something else
Please update VAR_5 thisVAR_5 common practice within team prefix class members
Please use TYPE_3
Why need type parameter
You dont need Predicatesor
shouldnt _CODE_
cast seems dangerous optional stored
perhaps multiple lines
I generally like singletons synchronized TYPE_2 instantiated one place anyway thats single threaded nit
final
Cant _CODE_
_CODE_ return true point return false end method
Instead duplicating code replace method body _CODE_ VAR_2 VAR_3 true
We call init method first instead letting _CODE_ us
If want lazyload manager instance would okay use lazy holder idiom I believe code minor race condition
nit I feel could internalize VAR_3 creation including null check VAR_3 _CODE_
I dont think need move VAR_5 Otherwise _CODE_ nothing name Keep VAR_5 inside VAR_2 help refactoring directly replacing _CODE_ _CODE_
TYPE_4 closeable class created object never closed Maybe use trywithresources statement
I would use METHOD_2 name function without parmeters Maybe add parameter
It refactor Moreover grouping could hidden somewhere tree like _CODE_ 1
necessary
Is way tell _CODE_ channel bad state without manually METHOD_4
Make final
useless parentheses
Here need take sequence number wrap around account Alternatively could unconditionally set VAR_1 prevent VAR_1 set end set However I dont like adding kind logic setters Maybe itd better _CODE_ method
instead METHOD_2 could return free vars definition Same _CODE_
I wonder dont emit event case Another thing I think case using _CODE_ update _CODE_ database currently dont update case use normal _CODE_ _CODE_ tasks Isnt little bit inconsistent Here index persist VAR_1
VAR_4 could member variable class instead constructed various methods
The previous log message removed since trivial logic
Sorry deprecated doesnt mean remove test We must ensure continues work removed
I would test first METHOD_4 unknown faster test add varmethod id And way I understand exclusion unknown method VAR_1 variable VAR_1 unknown If Im correct METHOD_2 entirely dropped test first METHOD_5
Ternary true false
I love use static imports u
Typo
The additional null check seems unnecessary You could return _CODE_
This effectively 0 sure makes difference Might also read slightly simpler inverted ie METHOD_5 outside block
Does seem used Reminder quantile function tries best create classes count data might disagree even distribution might happen The percentage report actual class distribution desired one
Below also work need reassign name _CODE_
I find bit strange declare lambda variable used next line I dont think using Stream _CODE_ gives lot terms clarity I would use old fashioned TYPE_2 extends TYPE_3 VAR_5 VAR_5s VAR_1 _CODE_ VAR_5 else _CODE_ VAR_5
dont need youre already calling _CODE_ public constructor right
Parameter annotated Nullable
Lets put together previous line java TYPE_1 VAR_4 _CODE_ tableMetadataBuilderDEFAULT_TEST_ORDERS
pass null TYPE_2 create default _CODE_
remove line
Since pass null last parameter times least class create another constructor
This evaluate incorrectly
I might bVAR_1 missing somVAR_1thing sVAR_1VAR_1ms mVAR_1thod doVAR_1snt throws TYPE_2 PVAR_1rhaps throw VAR_1 thVAR_1 VAR_1nd
I playing using curl got _CODE_ VAR_3 null 500 error Some error checking would nice
This kind hurting head Maybe Im bad mental boolean logic Since default value VAR_2 false would simpler change Boolean boolean constructor parameter write thisVAR_2 VAR_2 boolean type default false provided json
I think better use _CODE_
_CODE_ value
private
need
Do need inner loop
Do want make change inside _CODE_ _CODE_ count errors rebalance command well
necessary
Should static _CODE_ methods
double
public
Dtto
Are prepare commands 0 VAR_4 common
Wrap whole block VAR_13 null simple VAR_10 else inside
really btw wouldnt return _CODE_ _CODE_ DoublePOSITIVE_INFINITY slightly better used ternary op line
sure private methods METHOD_1 _CODE_ add much could inline
Please remove field references arent needed We use required sometimes assignments constructor consistent assignments required
This seems needed
usually denominator dont use setget syntax like java flip data _CODE_ por favor
Why join declaration assignment
Where VAR_5 updated
clibc I dont know enforce Java 7 minimum might best go Java 6 syntax
Is get naming convention required _CODE_ Otherwise lets avoid _CODE_ name method message See
Wondering fix test good example things done But maybe tests like worth fixing
Could change direction getter public TYPE_1 METHOD_1 TYPE_1 return outsetup
please use brackets even singleline cycles
Make package private suggestion int METHOD_1
I would make errors unmodifiable
public
make packageprivate
Dont eager near cache anymore
I dont think needs trycatch block shouldnt unrelated _CODE_ helper
rewritten return VAR_1 null VAR_1length 0 null new StringVAR_1 VAR_3
This cast necessary bypass generics limitations compiler We cant remove
How inlining VAR_1
Please revert Override permitted even source 5 source 6 come updated parent _CODE_
Logic reversed java _CODE_ throw return
else redundant Consider dropping
Please add Javadoc comment explaining needed
No _CODE_ path uses path file system It file part VAR_5 two different things overlap certain cases
TYPE_4 good idea best practice remove TYPE_4 May TYPE_2 would better
The first argument _CODE_ methods offset right Should index changed offset
Same The new flag VAR_3 passed used _CODE_
lets move return statement dont need extraneous check
dont use TYPE_2 translated languages
Suggested v value name
removing explicit initialization worse better
This must done property level private final _CODE_ VAR_9 new TYPE_9 We going change property More final provides performance optimization Meanwhile volatile gives us degradation careful choosing use For example convention use properties strictly configuration options And use properties changed concurrently internally enduser doesnt control ensure proper access Like running example
Nitpick use return _CODE_ _CODE_
Can simplified return new _CODE_
TYPE_3 subclass TYPE_2
Should METHOD_2 VAR_2 It looks like _CODE_ would able proceed state check state yet kind START_EXITED_ might fail succeeded
I think _CODE_ shouldnt necessary
I think would simpler without final else clause Just initialize null
nit convention use exact name null variable
Access private METHOD_3 methods Also merge one method
keep return type boolean return value _CODE_
Please undo Calling METHOD_5 even dont want METHOD_5 TYPE_3 really really odd
I would make allow equal case meet requirement Is specific reason strict
Uh would put inside _CODE_ block I would put _CODE_ outside since name null
event
We need distinguish computedenriched static properties Either return null enrichedPropertiesgetPropertyComputedPropertiesNODE_INFO
synchronized I see message handlers synchronized instance Hopefully given enough thought class members arrive conclusion external facing methods synchronized
Is response guaranteed nonnull point
Well need second usage _CODE_ replaced _CODE_ well
String TYPE_1 needed
prondzyn index
Im sure _CODE_ message helpful users
This statement necessary loop would handle negative case
Could use _CODE_ instead checking size 0
private meant used within class protected meant used subclasses
Declare outside
파라미터 순서가 TYPE_2 TYPE_1 int 가 되야 하지 않을까요
think done every test possibly moved _CODE_
_CODE_ go wrong There couple plugins want rewrite VAR_1 mavenshadeplugin flattenmavenplugin This VAR_1 target directory cleaned However basedir stay
remove
Doesnt need synchronized
The dictionary value row number They arent sorted
I guess TYPE_2YPE_1 extends TYPE_2 analogous _CODE_
As assertions wrong way around
Is change still necessary
So looks correct I still dont see reason k variable For And I would prefer loop like equivalent loop much clear java int j _CODE_ j _CODE_ 1 j procedureapplyi _CODE_ valuesj
I dont understand thisdestination used clarify
I would always call METHOD_1 regardless mode make sure METHOD_1 noop wasnt started That way implement modes dont update piece code
Usually add helpers first parameters methods
пробел
Why 1
This _CODE_ change allowed
Do really want keep logfatal
You need check VAR_3 null
_CODE_ reason gettier line
private
chnge error
Use single catch block
Needs default value false case _CODE_ false
Nit I think METHOD_2 noop VAR_1 empty probably dont need check
true false
VAR_2 buildProviderVAR_2 _CODE_
I think default constructor TYPE_1 dont pass constants
believe throw _CODE_ _CODE_ null
No need check VAR_2 LongMIN_VALUE
thinking possible zknode could deleted state set _CODE_ lock held That detected retry An alternative retrying would increment allocating counter first block decrement second sync block Code deletes node would allocating counter 0 Another alternative would use readwrite lock
keep private
Here VAR_3 VAR_2 every codec opposite
Why remove This makes shortcut check instance
nice maybe try finally
Dont remove old constructor deprecate Binary compatibility
Binaryclient arguments usually byte instead strings
Maybe clearer use _CODE_ _CODE_
As far I understand start column replaced Calcite need check well
Shouldnt calling _CODE_ VAR_1 value concise distroproperties
As I mentioned potential _NullPointerException_ gap The _else if_ expression expanded else _CODE_ null _CODE_getMessage null
Fix formatting please see note importing default Eclipse prefs
Remove
Rename variable VAR_2 _CODE_
Most arguments nullable initialized builder copying another statement need clear attributes
need public package local good
nan
We already _CODE_ need call _CODE_ unless Im missing something All need call _CODE_ externalizer would used
private
I think _CODE_
Call requires _CODE_ level 11 10
suggestion isViewDisplayedgetViewByIdRidbutton1 We simplify isViewDisplayedgetViewByIdRidbutton1 false isViewDisplayedgetViewByIdRidbutton1
We cleanup bundle destroyed rather using VAR_3 hook
static import
This implementation looks correct I think unit test sure prevent regressions I think testing boundary cases arrays length 1 2 3 would sufficient cover possible cases 0 alen1 0 alen1
This one
The check based _CODE_ like I said one Why Well conceptually correct And practically would allow exception message include METHOD_7 name use compliance mode Right error message tell corrective action Also _CODE_ performant check compared String comparison come first
Can unroll use new Configurable method instead
ditto
I really dont agree change generally Im one extracting casts local variable I find really readable really useful debugging Now I even dont understand cast needed element already TYPE_2 need remove cast dont
If many changes please pass TYPE_4 instead VAR_2 VAR_3
No need check _CODE_ need end commit _CODE_ 11 Simply call eventcommit
set final everything
I would expected opposite Since called running payment operations _only_ want fetch deleted payment method _CODE_ operations shouldnt false
Nit declare TYPE_1
Because TYPE_4 also complex property check come _CODE_ In local tests I got _CODE_ Trying access member null object mimetype trying write blob property treated complex
The position adjustment restore wrapped tryfinally dont want buffer left invalid state exception thrown
VAR_1 must integer
I think harder read previously searched specific types otherwise fell return false default Now fall folded complicated expression
Remove
METHOD_2 mandate update right Do need call METHOD_4
This code almost METHOD_1 make call one place delegate another I think _CODE_ Jenkins hierarchy
This loop invoke virtual calls per VAR_3 could slow large input I dont think lead performance degradation segment merge prominent bottleneck However I would recommend adding notes
Nullable
zeer matig geschreven methode maar bon
_CODE_ Severity _CODE_ Replace lambda method reference sonarjavasource set Assuming 8 greater rule
I dont think needs changed Definitely shouldnt need add _CODE_ checks sure _CODE_
Id say TYPE_1 statements within _CODE_ block something disabled doesnt get monitored
Same
I think remove _CODE_ since always end hiding It might good opportunity clean Fragment bit I ended making bunch changes I trying things I thought commit somewhere share proposed changes We dont make changes course totally Feel free cherrypick commit recommit branch like
You reuse METHOD_1 method I much like
This cause unit test failures wouldnt seen otherwise It must _CODE_ without _CODE_ parent nodes matched since every class class
something meaningful key found Seems like would error condition This seems like may mask issues
You using result anymore call dbexecute _CODE_ 33 _CODE_ b _CODE_ b _CODE_ 1 _CODE_ _CODE_ _CODE_ without storing result variable
nice thanks
Case INT_2 redundant
I think use _CODE_ method rather recreating
_CODE_ Make METHOD_1 static method rule
needs take Dates _CODE_ Strings
It doesnt synchronized _CODE_ already grabs _CODE_ lock calls METHOD_1
Log error level I dont think put stack trace end result crashing system seems issue METHOD_2
Use _CODE_ _CODE_ static import
It could imported statically
Do need added docs
needs Override
need declare throws exceptions
Its bit confusing put VAR_9 others filters rows included Maybe move variable main _CODE_ class
The two lines merged one
Sorry concern isnt _CODE_ would null point VAR_2 would null Because change _CODE_ possible METHOD_2 return null So wed want suggestion VAR_2 null _CODE_testVAR_2
The _CODE_ solution would make METHOD_4 _CODE_ return null Null _CODE_ valid anymore 111
_CODE_
Maybe worth removing call Objectsequals VAR_2 VAR_3 null
please use static import METHOD_2
I think overkill memory allocation We revert back model 06 used thread safe data structure
One titerator
Have pass _CODE_ rather accept null atleast mark Nullable
Is _CODE_ used message And want full stack trace exception want message
This VAR_6 argument unused Can remove method call
long instead TYPE_1
Consider clarifying current expected values exception message
need parenthesis
Please elaborate returning VAR_3 VAR_2 blank
TYPE_2his effectively hides problem carpet TYPE_2he problem VAR_1 factory cannot guarantee property handle type _CODE_ VAR_2 With solution could pass method representing _CODE_ request _CODE_ would compile fine At runtime would get exception eventually would compile TYPE_2heres nice solution I think theres readable one remove entire commit replace beginning method _CODE_ By construction know VAR_2 returns values type TYPE_2 public _CODE_ METHOD_1 handle null try handle _CODE_ VAR_1createPropertyHandle name VAR_2 And something similar orghibernatesearchmapperjavabeanmodelimplJavaBeanPropertyModelMETHOD_1
Race condition
isnt going true time
u change TYPE_2 _CODE_ _CODE_
static import array
Should logic part METHOD_2 function
I think logging doesnt belong method kept initialize method
Youre kind missing return
1 I surprised didnt I wonder returning size used may better _CODE_
waiting inside _CODE_ thread It done way already fix could look
You call _CODE_
I think thing comment lines One thing blank lines inside comments probably counted comment lines
This wont get called situations Systemexit succeeds
vilchikelena How testing recursive nature _CODE_ For example matchesfoodecoratorprop matchesfoodecoratorprop1 2
As method change state unlike others I would prefer declare static
_CODE_ Please change builderconditions buildersettings
Line long Please add wrapping
private
I noticed If assertion fails delete method executed causing potentially causing problems followup tests Can move After method making VAR_7 global field final block Thisi true test well I guess move After method work use cases
METHOD_1 Also doesnt seem perform optimization
Open ticket
Add check platforms map otherwise throws _CODE_
inline operations similar use _CODE_
Is really better For strings _are_ equal faster strings arent slower Id guess comparisons strings equal old code perform better
You reading VAR_1 checking null later change like VAR_1 VAR_1getPropertieshasResourcePlan return
return dont assign
I would make constructor protected cannot directly instantiate abstract classes See answers discussion
Since Jackson make private get rid Deprecated want
We could use shortcut keysupportsnode
_CODE_
right check
Add object VAR_2 please
Please add final
Two
passing _CODE_ upwards Isnt _CODE_ already executing actions _CODE_ Why similar kind manual dispatch logic already exists _CODE_ I think Im missing something
Please add _CODE_ message constructor TYPE_2 class instead creating proxy TYPE_5
Why pass whole name constructor argument That would mean could get rid _CODE_ seems like win
Is needed
static import
Shouldnt warning log else branch actual code _CODE_
Strictly speaking else 230 completely unnecessary since line 229 return statement Why keep line 228 add VAR_1 null right new line
wouldnt simply return null VAR_2 null Using 0length string effect less visible
Replace first _CODE_
You dont need cast since youre accepting TYPE_1
Are position create tests class Take look examples
The protocol mandatory isnt necessary
This check needed VAR_1 never null based call path
You rm public
The return value method switched METHOD_2 going return previous value true already VAR_3 false This opposite return true update recorded false VAR_1 already _CODE_ This used control server sends messages client VAR_3 could make happen frequently enough beginning way frequently
Should METHOD_3 call inside
Couldnt check VAR_2 null Seems wouldnt need _CODE_ variable well
I think better use trywithresources also fix Sonar complaining I mean smth like java try TYPE_3 VAR_2 EGitUtilsgetTYPE_3project VAR_2 null return null return EGitUtilsgetCurrentBranchVAR_2
dont copy orderer
If youre need locking A static initialiser might simpler
This value isnt changed always INT_1 return INT_1 directly
Stylistic nitpick usually case Id invert conditional top return empty value immediately top function rather wrapping bulk real code conditional block Is idomatic Java style
Wouldnt ifelse If unsubscribed previous lines I dont think ever go flow
Just consistency please use final boolean VAR_3
java VAR_2 VAR_3 new VAR_2 try VAR_3resetVAR_2 catch VAR_6 exception fail
s3aequalsmUrigetScheme Should also check s3 risk uri scheme s3a s3
Please use switch statement
обычно в конструкторе имена параметров совпадают с именами объектов класса которые они задают так понятнее для чего они нужны public VAR_1 String name IVAR_1Region IVAR_1Region thisname name _CODE_ IVAR_1Region в данном случае все и так понятно но если конструктор большой то в нем проще разобраться будет
Nullability annotations
remove
This method causes several build warning
Should _CODE_
Again detail personal taste I prefer see business code root level method java TYPE_1 VAR_1 m_annotationFinderfindAnnotationgetConstructorOrMethod TYPE_1class VAR_1 null return new String0 return VAR_1getGroupFilters
Id like understand reason extra _CODE_ creation object encoding
curly brackets avoid goto fail
need VAR_1 cant simply iterate list flatten
사소한 거긴 하지만 가 되지 않도록 순서를 변경해 주세요
Why need _CODE_ _CODE_ _CODE_ hive work without specifying _CODE_ schema default
Should assignExecutor1 _CODE_ Also know 1 nonexistent executor
No trailing white space lines
Is possible column index negative How Should
You probably dont want VAR_4
vilchikelena Why need check null VAR_1
adavid9 please add throws TYPE_6 use TYPE_8 within _CODE_ foreach
Just sake short codebase size 0 could replaced _CODE_
Does need Object VAR_1 instead primitive long Former issues null
Im curious change made The VAR_3 thread safe METHOD_2 needed update VAR_5
Shouldnt default true taken _CODE_ new _CODE_
removing response thing figured VAR_4 must always coming together response even used time could future
This existing code seems code try block METHOD_5 finally ensure METHOD_5 occurs even write error occurs
oh good catch
false
I think visible click fail assertion needed
could simplified VAR_4 null return new _CODE_ else VAR_7 url VAR_4getUrl
Not blocker please put space
No need parenthesis even produce Sonar issue
VAR_2 null VAR_2length 1 1 would make sense
I would add METHOD_2 method enforce fact explicitly target one
Why add
use string literal
likely worth lookingflagging removing _CODE_
delete VAR_1 constructor changes
duplicating checks Already METHOD_6 check
The parameter VAR_1 never used Should passed METHOD_1 suggestion METHOD_1ArraysasListVAR_1
VAR_3 unused
Method private
A number tests dont actually throw TYPE_1 Will please remove throws signature unnecessary This way expectations test clearer
ivange94 remove assertion title identifier
I wonder atomic operation
public visible testing protected
Is VAR_2 still used If remove
nit Id initialize order parameters first service location
Can pass operator lower upper The used boolean operator previous next
private
In assert method first argument expected value second one actual value Can swap file match definition
Lets make vcov _CODE_ ccov _CODE_
This probably package rather protected
Can append cause admins chance identify cause fix
Is reason want bitwise _CODE_ instead Did want explicitly avoid shortcircuiting
Is testing console log works Can delete dont need
probably dont need condition
For consistency could use _CODE_ _CODE_ please
_CODE_ thats 2 spaces right
Can get class VAR_1
Shouldnt maybe threadsafe list
spacing code style
The _CODE_ _CODE_ methods also found _CODE_ class Could find way one copy
This seems redundant Its checked two lines
nit spacing
Can METHOD_4 method accept null storage strategy Substitute _CODE_ null Doing save null checks anywhere else method called
Might want add reasoning It properly cancelling threads downloads workers might need files adds ton complexity uncommon case
Remove final The reason
This backwards incompatible change cannot merged
TYPE_2 VAR_3 instead TYPE_2 VAR_4
Curious removed optionals arguments Both cases work particular usage things keep mind Jackson handle optionals fine reading json missing key absent optional Not relevant case always lookout uses constructor would cause something like breaking change For particular case _CODE_ used model something read json But cases releasing new version changed constructor would break users
No need null check
Please convert VAR_1 absolute path Otherwise jadx skips resources run file without full path like jadx someapk
Overall I like refactoring especially deduplication However I suggest using early return well braces statements suggestion VAR_3 VAR_4 _CODE_ VAR_4null return null String VAR_6 VAR_4getSourceName VAR_6null VAR_6 MiscgetFileNameVAR_6 return VAR_6
As method private I dont understand value adds
Should synchronizing VAR_4 rather
Isnt different way get androidowncloudcom instead using hardcoded string
Why _CODE_ synchronized one I need know _CODE_ stuff used determine behaviour correct methods I hope provide correct answer anyway
Is method useful end users testing If testing I would maybe make public
As I said _CODE_ changes please
ochaloup The parser cant It needs preserve read xml introduce default values management model user put xml The subsystem use default value _CODE_ configure runtime services whats stored management model reflect user provided configuration It appears method called _CODE_ method I think eliminating else block throws METHOD_7 would fine
likely want specific edgecase fixtures ensure deserialization works needed
You might want move call _CODE_ The reason fast user switching account switch occurs come back activity youll stuck handle old _CODE_ variable VAR_3 wont updated
pedrofvteixeira VAR_4 used METHOD_5 call Is purpose
I think better use _CODE_ start
Can meaningful error message Expect VAR_1 VAR_3 get
Injection constructors package private Remove public modifier
Javadoc args needed
I would java else VAR_3 return new _CODE_ VAR_2 true VAR_7 else return new _CODE_ VAR_2 false VAR_8 3 branches easier follow least
ditto readability int result name null 0 _CODE_
I feel grouping three things access array increment return wrong new version making less clear Perhaps would clearer written int offset position return Arrayget array offset
I think cleanup part _CODE_ Here tests well
Same The new flag VAR_4 passed used _CODE_
Please move check null check bellow since already checking thiskey null
This technically public since public class _CODE_ execute apparently bypasses privilege checks using reflection
dont typically use get getters right VAR_3
Can simplified return Objectsequalsrevision thatrevision Objectsequalsurl thaturl
suggestion _CODE_ VAR_4 VAR_4close
I understood condition first read great thanks lot small things I think become important long term easier maintan 1
unnecessary else
_CODE_
Enumvalues creates array time invoked better cache statically iterate index avoid garbage created iterator
Could rather call thisresponsestatus responsereason sure checks throws _CODE_
None callers seem use return method Is okay Is needed
I believe I misled previous review need additional configuration formatteroff VAR_3 _CODE_ _CODE_ _CODE_ _CODE_ _CODE_Servicesnew _CODE_ VAR_8 formatteron
Please add final
private
A minor comment This else moved become first else needed one else VAR_1 VAR_5 0 VAR_8 VAR_9
The METHOD_3 method take _CODE_ METHOD_2
wont compile You throw assertion error like _CODE_ Btw I think _CODE_ _CODE_ flavour ie inside _CODE_ _CODE_ helper base flavour mainly
Id expect union _CODE_ 1 2 _CODE_ _CODE_ _CODE_ 1 2 test asserts result _CODE_ _CODE_ 1 2
Accessing profiles trigger starting VAR_2 cause already started exception
I would recommend rename method VAR_3 reflects underlying configuration option accurately
Ive asserts build method prevent duplication null check If user passes null thats ok long dont call build call something else
final missing Same ones
Codacy Issue found Use explicit scoping instead default package private level
Why go data container check Why call cacheget
It looks like VAR_4 isnt used anymore
Maybe add _CODE_ Then switch type primitive boolean remove ternary
We convert _CODE_ local variable _CODE_ return new ConfigurationunderlyingFs_CODE_
_CODE_
This return redundant removed
Why need implemente METHOD_1 METHOD_2 Could explain little bit
Should inverted
This means METHOD_2 called twice common use case I would add private _CODE_ VAR_1 _CODE_ _CODE_ call rest METHOD_1 methods
Lets keep boxing please focus _CODE_ new _CODE_ If want go whole code base consistently use one boxing style thats different _CODE_ _CODE_ But I prefer know boxing unboxing takes place since free gives compiler opportunity flag unintentional boxing unboxing let programmer decide thats really happen
atarix83 What would happen Base _CODE_ includes port number While less frequently seen I seen sites run _CODE_ port 8080 example It looks like _CODE_ would fail port either 80 _CODE_ 443 _CODE_S
Can remove OPENNLP922 changes one style across equals _CODE_ implementations
Can make methods private I know youre using unit test I think use deencapsulation feature testing framework right The interface class changed accommodate unit test
This good Why VAR_7 passed ctor Ideally VAR_7 VAR_4 _CODE_ passed like Does VAR_7 class work mediator level If cleaner approach would remove VAR_7 related code mediator write _CODE_ class extending mediator add VAR_7 code original mediator methods You return _CODE_ LightblueVAR_4 based config
Static import METHOD_2
Another case returning conditional
Please remove assert statement replace whole lambda expression _CODE_ The situation able retrieve substitution one type parameter never occur However occurs dont want rule fail analysis assertion error want fail badly It means facing problematic situation want feedback afraid user It responsibility semantic analysis fail encounter impossible situation rules From coverage point view also wont able cover cases cant build
Possibly throw assigning
nit _CODE_ reusing instance gquery jquery goodpractice performance reasons
nitpickmodeon Can change thisVAR_5 VAR_5 nitpickmodeoff
Order expected actual values wrong
Can use signature without exception It doesnt look like VAR_9 thrown remark
TYPE_2 _CODE_ example constructor taking collection You could write return new TYPE_2LOMBOK_ANNOTATIONS
Same better wrap classloader creation inside method
Leftover
suggestion _CODE_ _CODE_ check host otherwise client disconnects canceled outgoing negotiation
This really necessary control We suppress warning instead
Why change call Both calls equal previous one shorter I missing something
Make public since constructor logically part public _CODE_ class Access controlled class level If wanted later make class public wouldnt need change access constructor
given TYPE_3 becomes closable shall use trywithresource safety
Maybe return path Can somehow _CODE_ differ path
Codestyle
It pattern min True max must True It necessary check min
I would recommend group together parameters generic every method eg _CODE_ VAR_1 TYPE_2 VAR_2 TYPE_3 context String VAR_3 It much easier read interface easier figure parameters important boilerplate Intellij utility changing method signatures It allows easily change parameters order
This statement checking property allowing corrected times
是否可以直接 return _CODE_
No need
This compare value instead
Lambda replaced method reference
Maybe simplify return normal_equalswindownormal_
Make public consistent _CODE_ classes Not sure public class package private
need class member
I guess else required since block return personally Id find easier read TYPE_1 VAR_4 _CODE_ VAR_2 VAR_4 null TYPE_3 VAR_4 StringUtilshasTextVAR_2 new TYPE_3targetObject VAR_2 new TYPE_3targetObject VAR_4 thisconfigureHandlerVAR_4 return VAR_4 feel free ignore
Is change _needed_ It preferably shouldnt happen
_CODE_ use _CODE_ instead accessing private member
Наличие поля _CODE_ делает его не thread safe
need cast
Please annotate parameters Nullable
Id prefer set VAR_3 0 let socket bind ephemeral VAR_3 Theres chance collision way
I dont think introduce another histogram Instead send different ones normal get vs replication get
Redundant cast It seems done automatically _CODE_ Please check avoid
Arguments VAR_1 VAR_2 unused Maybe remove
We didnt use custom action bar No need use
Can thisVAR_2 _CODE_ VAR_2
_CODE_ viewexpand else viewcollapse view public void expand _CODE_ _CODE_ presenter public void METHOD_5 METHOD_5getDataType
calling _CODE_ make sure app installed dropins location configured
Extract 05 float field _CODE_ Ignore I removed unused method
Missing raw type
returns VAR_2 combine line next
Maybe dont need print stack trace ignore
I dont get VAR_3 field declared TYPE_4 instead TYPE_2
Ich weiss nicht ob ihr euch das später anschauen wolltet aber du kannst hier seit Java8 auch Lambdas verwenden Siehe _CODE_ hier oder auch hier oder ähnliches im Internet Dh du kannst aus den Zeilen 80 bis 87 ein lambda statt einer anonymen Instanz Objekt verwenden Damit wird der Code kompakter und lesbarer _CODE_ TYPE_6 errors invocationgetArgument1 _CODE_ invalidemail return null whenvalidatorvalidateMETHOD_7 METHOD_7
Конструктор должен быть публичным
VAR_6 VAR_3 maybe
This looks like go back package visibility
reason disabling cache descending order queries
This declare TYPE_3 returned provide much type information bean factory possible
We remove never used
This function single line inline return
element parameter never used
fchauveau null handling source intended
Für die Branch Interior Path Coverage überprüft man _CODE_ 0 1 INT_1 Schleifendurchläufe
Good catch
The _CODE_ necessarily nodes VAR_2
I find harder read
I wonder shouldnt keep old constructor use extra boolean argument
Correct braces throughout please
need address element twice perform multiple checks operations series onBrickAtPositionbrickPositiononVariableSpinnerRidinsert_item_into_userlist_spinner _CODE_ _CODE_
Shouldnt synchronized
Maybe divide double
delete use default _CODE_
Why changing Generally done avoid expensive resolution message log Here case In fact doesnt perform worse _CODE_ simply forces 2 METHOD_6 enabled checks
probably best also include name used super class constructor well Perhaps use _superid name_
suggest changing VAR_7 true false VAR_7
Are two lines definitions necessary Isnt shorter use _CODE_ assert
unnecessary casting
Since comparing constant object need use Objectsequals java return TYPE_3equalscostsgetOrDefaultnodegetId TYPE_3
Doesnt _CODE_ include size _CODE_ pointers
I think safety clear code use instanceof TYPE_3 well
_CODE_ VAR_7 return VAR_6 で良さそうな気がする TextUtilsってクラスは知らなかった便利そうだね
Useless blank line
Is reason collapse VAR_3 null VAR_3handlerequest response _CODE_
This simplified return expression And nullcheck could avoided initialising VAR_4 field _CODE_ VAR_4 otherwise given constructor
Why need
fire outside block
Should public A component calls incorrectly could invalidate cache every component
If subclasses inherit common implementation goal using instance method preferred ie nonstatic Using static methods inheritance purposes bit antipattern
The TYPE_1 never thrown
You dont use VAR_4 new cli right
Do really cast Am I missing something No strong feelings
I smell incoming _CODE_
_CODE_ already part static import No need use fully qualified name line 40
Id also _CODE_ We probably rely sensible impl METHOD_2 _CODE_ _CODE_ case
Maybe define int outside Not sure gets optimized I introduced bug String I became bit cautious things
nan
still creating new contexts
nit dont usually use final method Also side note dont use final tmp variables
VAR_6 constructed fixed capacity
use _CODE_
This correct _CODE_ _CODE_ need copied stay unchanged instead update Ordercopy copy fields
Please add Javadoc change method
You could use noarg constructor instead
Do really need check anything Surely enterprise edition supports constraints
Did want ideally package protected
Move TYPE_1 VAR_1 new TYPE_1driver
This kind beats purpose METHOD_3 method This code force hibernate execute two _CODE_ statements insert update I think move METHOD_3 _CODE_ Create new empty resource VAR_5 Copy values Then pass filled resource VAR_5 _CODE_ You enable Hibernate _CODE_ logging hibernatecfgxml see _CODE_ statements executes
ResponseStatusHttpStatusNO_RESPONSE void return type Same enable
Why synchronized
break loop early finding target module
private _CODE_
I dont know good solution open VAR_3 constructor sort exception tests Use openWikiPageVAR_3 instead test case
Please use compact oneline syntax java VAR_2 null return consistency blocks code parts
Could assigned field directly
In cases passing stylemanager necessary Calling _CODE_ always work
ekondrashev 1 means
think wrapping It scheduling level The problem scheduler finicky
I think would cleaner _CODE_ defined factory constructor _CODE_ Os_CODE_ map underlying type us making shortcut responsibility Os class _CODE_ The everywhere else
difference _CODE_ _CODE_
I like pattern use supplier compute error message use one used _CODE_ _CODE_ arguments
Can add exception second parameter Otherwise wont able tell error happened message
actually dont need cannot work since _CODE_ server domain sockets _CODE_ client thats simple test necessary
We probably make overload since public _CODE_
fail
You comparing _CODE_ _CODE_ What mean
TYPE_1 runtime exception dont need declare
Shouldnt done VAR_1 saved instead
Hmmm
Why non static anymore
Thanks simplifying Will please also remove final keyword local variable
please call _CODE_ give null ignores fragment position given rules constructor
Still thread safe Needs done startup postconstruct
Does need public
b b INT_1 missed
See comment likely original code correct cleaning reference without running cleaner
add space _CODE_
This seems weird If caller knows enough pass VAR_2 wouldnt able call method VAR_2 false
If hit often I would vote making info
Why need Is necessary test
missing curly braces also places
If validation exception thrown assertions ever get executed
binary bodies 60 Probably best leave VAR_3 add another _CODE_ revise issue 83
Constructor private Make static factory method
_CODE_ statements implementation throwing VAR_4 I think remove throws clause related import tests
required attribute name remaining attributes optional
directly constraintsdomainscount 1
Minor I wouldnt static import clarity
Should third argument _CODE_ VAR_1 VAR_4
Please update indentation configuration VAR_9 one
Not sure going create separate constructor disable deselect mode It aint important feature warrant one Better use new _CODE_
따로 result 변수없이 바로 return new LinkedHashMap가 좋을 것 같습니다
super reference removed METHOD_2 static
This minor would mind switching _CODE_ dont superfluous null hanging around I think functionality since one parameter method delegates two parameter method provides null second parameter
remove change comment
_CODE_ already default warmup mode need specify
seems every time spout deactivatedactivated starts reading file beginning may desirable
Again I dont think log message adds much
Do use _CODE_ use Groovy never Java bundles Add service reference _CODE_ add executor service constructor class requires As side note also make service dependency optional like
lets return copy TYPE_1 instance class mutable
So _CODE_ blocked call Is reason I asking since general convention Presto seems using _CODE_ cases
new array list returning set enough worry exposing internal state simply using _CODE_ enough
public
I dont think need log message
Minor You might want support String VAR_2 instead char VAR_2
Dont check VAR_1 already checked _CODE_ method
I assume list never null right
Lets add end instead beginning Its less common operations
Please use static imports TYPE_2 methods
No need _CODE_ This advanced VAR_2 already
whats point The method always false DefaultDebugExecutorEXECUTOR_ID without changes
mag 1 try weg
Avoid intermediate variable directly assign VAR_2
Same
Should check acceptable type VAR_1 object like everywhere
Override
Do need When Or belong _CODE_
If possible suggestion _CODE_ Local Configuration _CODE_
Hmm I mean I thinking case _CODE_ _CODE_ Does make sense
This also cause inconsistent states multiple admins visiting manage Jenkins page time I cant see simple way current approach except full rethink Moving one _CODE_ instance might help
Traccar targets Java 7 higher use diamond operator right hand side
Same I would avoid lambda
Not critical I find counter intuitive lookup method also clear move end start method
This read easier others splitting check using guards style _CODE_ return false _CODE_ null return false return true And want ask But isnt original code much compact optimized No The compiler create basically binary code versions Besides even differences binary dont matter Code always optimized readability understandability severe problem software development
Nit else redundant
I think someone send _CODE_
Remove Systemoutprintln
This still referring VAR_1 Im surprised working
We prefer use TYPE_3 internal null checks If readability ternary problem could pulled method thats something like instead java private static String _CODE_ _CODE_ return _CODE_ null _CODE_getAddress null _CODE_getAddresstoString null
Is perhaps join understandable remember 0 means wait forever
Dont blindly cast check returned tile entity actually TYPE_1 might change get updated
Do mean sVAR_3gth VAR_3
Please add Javadoc public methods
java _CODE_
Id add METHOD_1 make VAR_2 field Boolean This make sure someone sets field instead defaulting false
Use instead We dont nest _CODE_
inline
really feel wrong
use equals instead
initialization separate assignment line120
Remove redundant check protected modifier constructor
szczepiq Is really needed _CODE_ filters already TYPE_2
Looks odd use buffer couple lines METHOD_2 since refer thing
Would nice sanity check cohort doesnt contain active membership patient
rm public
nit add braces ifelse statement
This filter If return passing end element event next content handler well end unbalanced tree Is really correct
You call fail allocate This suggests VAR_3 writable state
changed protected
I see methods _CODE_ never VAR_4 tokens Im sure good thing Will able rewrite _CODE_ integration example
Should return value previous line
public _CODE_ VAR_2 thisVAR_2 VAR_2 _CODE_ _CODE_ h2
The additional constructor parameter unnecessary Only values needed construct service name appear The VAR_2 name obtained configure _CODE_
For performance improvement I think better pass TYPE_2 METHOD_2 regex
Code Smell Code Smell Code Smell Make VAR_1 static method squidS2325 See _CODE_ ISSUE_KEY AWF65MK3GUleEzPZFu4E
Unreachable stmt
We dont need pass VAR_2 since already know false point
Either brackets put METHOD_1 line
I dont think equals test necessary
Will work json false json false etc I think argsaddjson also removing json line 82 work
VAR_2 necessary
make ifthenelse since dontt need increment line Also split line since dont include statement line
I included fix test code cleanup see 51
What use VAR_2 variable
make public part _CODE_ I thinking methods implementation If make part _CODE_ support
done internally TYPE_5 What uses
You add null check selected VAR_5 may installed yielding null Menu Item
Can elaborate _CODE_ relationship equals I think override equals _CODE_ take innertypes consideration
consider making change commit introduced TYPE_1
I would sort lines subcommands
_CODE_ stream fscreatenew Paths3ntestbuckettest initiate upload creating stream closing immediately assertEqualss3getAcl _CODE_
davecramer Would better _CODE_ instead using reference equality Otherwise difference write behavior TYPE_1 value 235959999999999 using TYPE_1MAX even though valueequal
This function could potentially called simultaneously multiple threads would lead race condition better make synchronized
It looks like second check _paramssize 0_ removed If params null paramsget fail After two cases If params contain _CODE_ two checks instead three paramssize removed If params contain _CODE_ also two checks current implementation size place replaced size get
Can stick existing coding style omit VAR_5 prefix
My _CODE_ says cast redundant redundantcast
nit merge lines METHOD_1 return given argument
else redundant
Why public Now anyone instantiate class class public constructor public
Can use super constructor hopefully keep VAR_5 final
needs donetrue
Can move yet
You consider dropping occurrences meaningless
use _setup_
req This unnecessary
Nit use _CODE_ instead
As assertions wrong way around
please use separate lines
Things avoid creating commits Mixing two unrelated functional changes If fix bug always add necessary changes commit nothing
Im almost tending use _CODE_ specific exceptions case instead reusing _CODE_ _CODE_ Were validations right We could create _CODE_
Please replace change something similar b b INT_1
would work also removing import suggestion _CODE_ adviceArray0 instanceof VAR_11
Looks like synchronized block Perhaps METHOD_2 method could refactored slightly returns key found directly null otherwise
Use Objectsequals VAR_3
Minor Unnecessary type declarations initialization There lot class Im going address individually
space
Should comparison equals
return array null arraylength 0
probably cast string call _CODE_ also could shortened return String get key
please keep body line
Double Nitpick normally harmelss unless end statements like return break etc I think
Itd better decorate VAR_2 constructor
No need instantiate String name In fact need variable really This calling _CODE_ parent Surely METHOD_2 It calling METHOD_2 child works ie falls back _CODE_ Id change matrix branch
These vary dangerous methods public This lead procedural programming difficult determine object valid state Can made private
This doesnt make sense please explain
You dont need METHOD_3 null check
Casting feels wrong Can get rid
Can use junits Ignore annotation link github issue bumping compiler Something like Ingore
parameter sequence swapped VAR_1 min correct
METHOD_3
danielezonca Please keep model name view one synchro property seget model _CODE_ element view name
delegate METHOD_1 two functions also name would bit confusing _CODE_ Maybe rongrong could provide suggestion
Wouldnt best put organization parameter second place
All code need format druids code style 所有的代码格式化成druid的代码格式
Minor code flow suggestion VAR_1 null return VAR_1 return VAR_2 _CODE_ _CODE_
obstripe totally random really need duplicate collection classes nothing autogen realizing I havent asked
VAR_2 _CODE_ added STANDARD_ALIASES instead creating aliases
name não é um bom nome de variável Acho que oc erto aqui seria value ou cep mesmo que acha
Can rename method use abbreviation exactly obvious _CODE_ means contexts
I think _CODE_ case buffered data In case obtaining byte result
Could please replace blocks _CODE_ produces checks internally avoid copying possible
public
Is METHOD_5 needed since METHOD_4 returns List